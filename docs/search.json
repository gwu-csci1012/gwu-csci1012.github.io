[
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Schedule",
    "section": "",
    "text": "Home » Schedule"
  },
  {
    "objectID": "schedule.html#schedule",
    "href": "schedule.html#schedule",
    "title": "Schedule",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n\n\n\n\n\n\n\nDate\nTopic(s)\nWednesday Lab Date\nFriday Lab Date\nAssignement(s)\n\n\n\n\nWeek 0\nYour First Program, print\n01/17/2024\n01/19/2024\nModule 0 (Due January 22, 2024 by 11:59 PM)\n\n\nWeek 1 [01/22/2024]\nIntroduction to Functions\n01/24/2024\n01/26/2024\nModule 0.1 & Module 0.2 (Due January 29, 2024 by 11:59 PM)\n\n\nWeek 2 [01/29/2024]\nLooping: for Loops\n01/31/2024\n02/02/2024\nModule 0.3 (Due February 05, 2024 by 11:59 PM)\n\n\nWeek 3 [02/05/2024]\nIntegers\n02/07/2024\n02/09/2024\nModule 0.4 & Assignment 0 (Due February 12, 2024 by 11:59 PM)\n\n\nWeek 4 [02/12/2024]\nString\n02/14/2024\n02/16/2024\nModule 0.5 (Due February 19, 2024 by 11:59 PM)\n\n\nWeek 5 President's Day - No Class!\nFloating Points\n02/21/2024\n02/23/2024\nModule 0.6 & Assignemnt 1 (Due February 26, 2024 by 11:59 PM)\n\n\nWeek 6 [02/26/2024]\nLists\n02/28/2024\n03/01/2024\nModule 1.0 (Due March 04, 2024 by 11:59 PM)\n\n\nWeek 7 [03/04/2024]\nConditionals\n03/06/2024\n03/08/2024\nModule 1.1 (Due March 11, 2024 by 11:59 PM)\n\n\nWeek 8\nSpring Break - No Class!\nNo Class\nNo Lab\nNo Lab\nNothing assigned\n\n\nWeek 9 [03/18/2024]\nFunctions\n03/20/2024\n03/2/2024\nModule 1.2 (Due March 25, 2024 by 11:59 PM)\n\n\nWeek 10 [03/25/2024]\nBooleans & Built-ins\n03/27/2024\n03/29/2024\nModule 1.3 & Assignment 2 (Due April 01, 2024 by 11:59 PM)\n\n\nWeek 11 [04/01/2024]\nwhile loops, I/O\n04/03/2024\n04/05/2024\nModule 1.4 & Module 1.4 (Due April 08, 2024 by 11:59 PM)\n\n\nWeek 12 [04/08/2024]\nnumpy Arrays\n02/10/2024\n02/12/2024\nAssignemnt 3 (Due April 15, 2024 by 11:59 PM)\n\n\nWeek 13 [04/15/2024]\nExamination\n04/17/2024\n04/19/2024\nModule 2.0 & Module 2.1 (Due April 22, 2024 by 11:59 PM)\n\n\nWeek 14 [04/22/2024]\nAdvanced Topics\n02/24/2024\n02/26/2024\nModule 2.2 & Assignemnt 4 (Due May 01, 2024 by 11:59 PM)\n\n\nWeek 15 [04/29/2024]\nExtra Lecture\n\n\n\n\n\n[04/30/2024]\nMake up Day\n\n\n\n\n\n[05/01/2024]\nDesignated Monday\n\n\n\n\n\nWeek of May 04 to May 10\nExam Week"
  },
  {
    "objectID": "faq.html",
    "href": "faq.html",
    "title": "FAQ",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "units/unit0/modules/module0.2.html",
    "href": "units/unit0/modules/module0.2.html",
    "title": "Module 0.2: Functions: a first look",
    "section": "",
    "text": "Home » Unit 0 » Module 0.2"
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#objectives",
    "href": "units/unit0/modules/module0.2.html#objectives",
    "title": "Module 0.2: Functions: a first look",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module, for simple HelloWorld-like programs, you will be able to:\n\nDemonstrate function calls.\nUse mental tracing to identify output without execution.\nAdd numbered comments to show an execution trace.\nIdentify and correct syntax errors related to the above objectives."
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#an-example-with-function-calls",
    "href": "units/unit0/modules/module0.2.html#an-example-with-function-calls",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.0 An example with function calls",
    "text": "0.2.0 An example with function calls\nConsider the following program:\n# define a function we'll use later\ndef print_big_M():    \n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *')\n\n# define another one we'll use later\ndef print_big_O():    \n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****')\n\n# Print MOO using the above defined functions\nprint_big_M()\nprint_big_O()\nprint_big_O()\n\n\n\n\n\n\n0.2.1 Exercise\n\n\n\nType up the above in animal_sounds.pyand run it. Also save the file so that it can be submitted (You will need to save the appropriate files for everysuch “type up” exercise).\n\n\nLet’s point out a few things: \n\nLet’s start by distinguishing between a function definition (which uses def and merely tells Python what the function is about), and invocation (which asks Python to execute the function at that moment).\n\nA function definition is a piece of code that begins with the word def\nA function definition is sometimes also called function declaration.\nA function definition does not execute the code immediately.\nInstead it’s like saving in one place a bunch of instructions that can be invoked with just the name of the function.\nThis saves writing lots of code if a group of code can begiven a name (in this case, a function name).\n\nA function definition has 5 elements: \nA function with a given name is defined just once.\nA function invocation merely uses the name, along with parentheses:\nprint_big_M()\nWe’ll later see examples where some things can go between the parens.\nWhile a particular function is defined once, it can be used any number of times:\n\nIn fact, that is the whole purpose of defining functions.\nEach use of a function is a single line of code, which saves us the trouble of rewriting all the code that was inside the function for each time we need it.\n\nFunction definitions also help isolate code so that one doesn’t have to see or understand what’s inside to use it.\nWe’ve already used such a function before: the print function.\n\nThe printfunction is defined internal to Python.\nWe don’t type its definition, nor do we see it.\nWe just use it as often as we like.\n\nImportant: Please pay careful attention to indentation\n\nThe line that begins with def should NOT be indented.\nOther lines that belong to the function should be indented.\nThere are other forms of indentation that we’ll point out as we proceed - they’re all important.\n\n\n\n0.2.2 Video\n\n\n\n\n\n\n\n0.2.3 Exercise\n\n\n\nWrite your own animal sound that uses one function at least thrice with an exclamation mark at the end, e.g. print the big version of BAAA!. Write your code in my_pet_sound.py. Once your program is working, say the sound out aloud to celebrate. (Why not?)\n\n\nNext, let’s see how functions “work” by making a small change to the program:\ndef print_big_M():\n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *')\n\ndef print_big_O():\n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****')\n\nprint('Step 1')\nprint_big_M()\nprint('Step 8')\nprint_big_O()\nprint('Step x')\nprint_big_O()\nprint('Step y')\n\n\n\n\n\n\n0.2.4 Exercise\n\n\n\nType up the above in animal_sounds2.py and run it.\n\n\nLet’s explain using an analogy: \n\nWe’ll use the analogy of a house to describe a program and its parts (the functions).\nA program’s execution starts at the very top.\nIn the above case, there are a number of definitions:\n\nDefinitions are merely “processed” but not executed.\nIt’s understood that the definitions may be invoked later.\nIn our house analogy, we walk past these “rooms” to the main lobby.\n\nThe first real line of code is the print('Step 1')statement.\n\nThink of this section of code as the “main lobby”.\n\nAfter this, we see the line (also a command) print_big_M()\n\nThis is an instruction that causes the computer to “go to the print_big_M()room”.\nWe then head to that room and start executing commands in there.\n\nThus, the third command that gets executed is print('*   *')\nWe’re still in the room with more commands to go, and the next one (4th so far) is print('** **')\nContinuing, we execute the last line in the room, which will make this the 7th one executed.\nAfter we leave the “room”, and this is important, we continue execution after the invocation that brought us to the room.\n\n\n\n\n\n\n\n0.2.5 Exercise\n\n\n\nType up the above in animal_sounds2.py and run it.\n\n\nAt which step (which step number) do we execute the last line in print_big_O? And then, at which step do we enter print_big_O the second time and print its first line? In animal_sounds2.py replace x and y with the correct step number. Don’t forget: non-coding responses to exercises go into module2.pdf (one PDF per module).\n\n\n0.2.6 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#calling-functions-from-other-functions",
    "href": "units/unit0/modules/module0.2.html#calling-functions-from-other-functions",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.1 Calling functions from other functions",
    "text": "0.2.1 Calling functions from other functions\nConsider this program:\ndef print_big_M():\n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():\n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\ndef print_two_big_Os():\n    print_big_O()\n    print_big_O()\n\nprint_big_M()\nprint_two_big_Os()\n\nYes, we can write our functions that call our own functions.\nIncidentally, did you notice the escape sequences?        ⇒ We improved the output.\n\n\n\n\n\n\n\n0.2.7 Exercise\n\n\n\nType up the above in animal_sounds2.py and run it.\n\n\nUse this idea to rewrite your own animal sound in a file called my_pet_sound2.py. That is, add an additional function to your earlier program my_pet_sound.py that is analogous to print_two_big_Os() above.\n\nOnce again, let’s trace through some steps: \n\n\n\n\n\n\n\n0.2.8 Exercise\n\n\n\nLook at the example above. What step number is represented by the question mark (?) next to the second print_big_O() inside the print_two_big_Os() function? What line in the program represents step 15? Discuss the program to correctly identify “step-15” with your TAs.\n\n\n\n0.2.9 Video\n\n\nMental execution:\nWe will use the term mental execution for the above exercise of tracing through the execution without actually compiling and running the program.\n\n\n\n\n\n\n\nNote\n\n\n\nMental execution is extremely important in developing programming skill        ⇒ Please be sure to practice this with every program you read or write.\n\n\n\nWe can’t emphasisize this enough. Really.\nRemember:\n\nExecution starts at the top of a program and goes downwards.\nFunction definitions are processed (understood) but not executed.\nWhen a function are invoked, execution “goes” into the function to execute the code in there."
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#more-about-functions",
    "href": "units/unit0/modules/module0.2.html#more-about-functions",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.2 More about functions",
    "text": "0.2.2 More about functions\nAbout function names:\n\nConsider the function name print_big_M.\nThis is a name we chose.\nWe could just as easily have called it my_crazy_function:\ndef my_crazy_function():\n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():\n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\ndef print_two_big_Os():\n    print_big_O()\n    print_big_O()\n\n# Use the different name:\nmy_crazy_function()    \nprint_two_big_Os()\nIn other words, the compiler does not look into the English meaning of function names.\nWe choose function names to help us read programs.\n\nBeware of name clashes:\n\nConsider the following program (that has a mistake):\ndef print_big_M():\n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_M():      # A mistake! We meant to have typed\n    print('*****')      # print_big_O()\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\n# What happens now?\nprint_big_M()\nIn this example, we have functions with different content but with the same name.\n\n\n\n\n\n\n\n0.2.10 Exercise\n\n\n\nImplement the above in name_clash.py and discuss the program to understand the comments (text followed by ‘#’ symbol) with your TA.\n\n\n\nWhat we see is that the second definition replaces the first.\nThe program runs but this error is not identified as such by the language. Instead, we need to be careful not to unintentionally make such a mistake.\n\nThe order of function invocation matters. For example, consider:\ndef print_big_M():\n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():\n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\ndef print_two_big_Os():\n    print_big_O()\n    print_big_O()\n\n# We've changed the order here:\nprint_two_big_Os()\nprint_big_M()\n\n\n\n\n\n\n0.2.11 Exercise\n\n\n\nType up the above exmaple in animal_sounds3.py and run it make sure there are no errors."
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#a-peek-at-the-future",
    "href": "units/unit0/modules/module0.2.html#a-peek-at-the-future",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.3 A peek at the future",
    "text": "0.2.3 A peek at the future\nOnce again, we will present a small program with features yet to be explained, by way of getting you comfortable and yet curious.\nHere’s the program:\nimport tkinter as tk\nimport random as rand\n\nwindow = tk.Tk()\nw = 500\nh = 400\ncanvas = tk.Canvas(master=window, width=w, height=h)\ncanvas.pack()\n\n# A function that draws a random circle\ndef draw_random_circle(color):\n    x = rand.randint(0, w)\n    y = rand.randint(0, h)\n    size = rand.randint(0, w/10)\n    canvas.create_oval(x,y, x+size, y+size, fill=color)\n\n# draw 100 circles\nfor i in range(100):\n    draw_random_circle(\"cyan\")\n\n# Standard colors: \"black\", \"red\", \"green\", \"blue\", \n# \"cyan\", \"yellow\", \"magenta\"\n\nwindow.mainloop()\n\n\n\n\n\n\n0.2.12 Exercise\n\n\n\nType up the above program in random_art.py and execute it.\n\n\nNow let’s point out a few features: \n\n\n\n\n\n\n0.2.13 Exercise\n\n\n\nUse the same code in random_art2.py and then add and modify it to create your own art, and include a screenshot in module2.pdf. When you quit your program, instead of x-ing out the window, type control-c (“control” key and “c” key pressed together) while the cursor is in the output window.\n\n\nAbout control-c\n\nThe standard keyboard has some keys that act together with other keys, in effect modifying them.\nThe shift key is the most obvious one: pressing the shift key along with another key either capitalizes a letter or types the symbol “above” in a two-symbol key. For example, the ampersand & is “above” 7 on the same key as 7; thus, pressing shift and 7 achieves typing &\nOn a Mac, you’ve probably used the command key, and on Windows, you’ve used control.\nThe control key, when used with other keys is often used in programming contexts.\nOne such case is to use control-c (control and c together) to terminate the execution of a program.\nHowever, to do this, you first need to click into wherever the program is executing. This is typically the output window (where the output appears).\n\n\n0.2.14 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#and-now-for-something-strange",
    "href": "units/unit0/modules/module0.2.html#and-now-for-something-strange",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.4 And now for something strange",
    "text": "0.2.4 And now for something strange\nConsider the following program:\ndef print_big_M():   \n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():   \n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n    print_big_O()    # We're invoking the function from within\n\nprint_big_M()\nprint_big_O()\n\n\n\n\n\n\n0.2.15 Exercise\n\n\n\nBefore doing this exercise, please read this page on how to stop endlessly running programs. Now, type up and execute the above program in my_strange_example.py. Use comments (text followed by ‘#’ symbol) to describe the error if any in the python-file.\n\n\n\n\n\n\n\n\nHint\n\n\n\nYou might get a “recursion depth exceed” error. Ask your TA about what this error means.\n\n\nThe term recursion is used when function calls itself: - In the above example, it’s an obvious error        ⇒ Nothing useful is accomplished.\n\nLater, we’ll learn to use recursion to solve problems.\nIn fact, recursion is one of the most powerful computational problem-solving paradigms.\n\n\n0.2.17 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.2.html#another-reminder-about-computerese",
    "href": "units/unit0/modules/module0.2.html#another-reminder-about-computerese",
    "title": "Module 0.2: Functions: a first look",
    "section": "0.2.5 Another reminder about computerese",
    "text": "0.2.5 Another reminder about computerese\nHow is your computerese coming along? Are you now much more confident with folders, files, zip files and such? What about editing, and saving?\nDon’t forget that you can always review the material on computerese from Module 0.\nPlease check that your module2 folder has the right files before you zip and upload. Does it look like one of these sample screenshots:\n\n\n\nMac\n\n\nor\n\n\n\nWindows\n\n\n?\n Previous Module: Module 0.1 Next Module: Module 0.3"
  },
  {
    "objectID": "units/unit0/modules/module0.1.html",
    "href": "units/unit0/modules/module0.1.html",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "",
    "text": "Home » Unit 0 » Module 0.1"
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#objectives",
    "href": "units/unit0/modules/module0.1.html#objectives",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nLearn what a comment is, and how to write them.\nWrite programs with multiple prints\nEscape sequences\nIdentify new syntactic elements.\nUnderstand case-sensitivity.\nWrite a function and examine proper indentation.\nFind and fix errors"
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#comments",
    "href": "units/unit0/modules/module0.1.html#comments",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.0 comments",
    "text": "0.1.0 comments\nA comment is like a note-to-self that you include directly in a program as a way to explain something to yourself for later, or to someone else who reads your program.\n# This is a comment\n      # This is one too, but not recommended \n\nprint('Something')      # And so is this\nLet’s explain:\n\nA comment begins with a # and ends at the end of the line.\nAnything written as a comment is not treated by your computer as a “command” or as programming intent.\nThus, as far as programming goes, the above program is as good as:\n\nprint('Something')\n\nYou can insert comments in various places in a program: \n\n\n\n\n\n\n\n0.1.1 Exercise\n\n\n\nUnder your unit0, create a module0.1 folder (if you haven’t already), and then write up the above in my_comments.py. Fix the second comment to start at the beginning of the line, and add an entirely new comment line of your own.\n\n\nSometimes one needs a comment to spill over multiple lines, as in\n# I wrote this program at midnight\n20 seconds before the deadline\nprint('Something') \nNotice the missing # in the second line of the comment.\n\n\n\n\n\n\n0.1.2 Exercise\n\n\n\nWrite up the above in comment_error.py. Remember to save the file (and do this for every exercise in the future that involves a program). Use comments (text followed by ‘#’ symbol) to describe the error in the python-file."
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#whitespace",
    "href": "units/unit0/modules/module0.1.html#whitespace",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.1 Whitespace",
    "text": "0.1.1 Whitespace\nConsider the following program:\nprint   (  'Hello World!'     ) \nNotice the spaces inserted in various places.\n\n\n\n\n\n\n0.1.3 Exercise\n\n\n\nWrite up the above in whitespace_example.py. Does the program run? Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\nConsider this variation\n  print('Hello World!')\n(Two spaces before print).\n\n\n\n\n\n\n0.1.4 Exercise\n\n\n\nWrite up the above in whitespace_example2.py. Run and check if you are getting any errors.\n\n\nFinally, look at:\nprint('Hello     World!') \n(Extra spaces between Hello and World.)\n\n\n\n\n\n\n0.1.5 Exercise\n\n\n\nWrite up the above in whitespace_example3.py. Run and check if you are getting any errors.\n\n\nLet’s point out a few things:\n\nSome kinds of whitespace, even if ill-advised, is permitted.\nWhen starting a line of code, proper indentation is expected, which is why we got an error when we indented the line starting with print\nThe extra spaces between Hello and World are perfectly acceptable if the goal is to print them. Printing accepts whatever spaces you want printed."
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#strings",
    "href": "units/unit0/modules/module0.1.html#strings",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.2 Strings",
    "text": "0.1.2 Strings\nA string in Python is a sequence of letters, digits, or symbols (like $ or *) surrounded by either\n\nA pair of double quotes, as in: \"Hello World!\"\nA pair of single quotes as in: 'Hello World!'\n\n\n\n\n\n\n\nNote\n\n\n\n\nWhichever quote you use to start a string must be used to end the string.\nThe ending quote must be on the same line as the starting quote.\nThere are special techniques to handle long strings that need to spill over multiple lines (which we’ll see below).\nThis raises some questions:\n\nIs it possible to print a single line but with multiple print statements?\nHow does one print a quote?\n\n\n\n\nFirst, note that we can use single or double quotes for different strings in the same program:\nprint('Hello')\nprint(\"World!\") \n\n\n\n\n\n\n0.1.6 Exercise\n\n\n\nConfirm that Hello and World! get printed on two lines by writing the above in my_string_example.py\n\n\nA print statement prints the string within parenthesis and then goes to the next line of output, which is why we see World! on the next line.\nTo keep printing on the same line:\nprint('Hello', end=' ')\nprint('World!')\n\n\n\n\n\n\nNote\n\n\n\nWe’ve reverted to using single-quotes for all strings, which will be our preference.\n\n\n\n\n\n\n\n\n0.1.7 Exercise\n\n\n\nConfirm by writing the above in my_string_example2.py.\n\n\nWe’ll now go the other way and have a single string itself contain a directive to spill over to the next line.\nprint('Hello\\nWorld!') \nNotice the backslash \\ followed by n inside the string: 'Hello\\nWorld!'\n\n\n\n\n\n\n0.1.8 Exercise\n\n\n\nWrite up the above my_string_example3.py. Run and check if you are getting any errors.\n\n\nStrings can embed special so-called escape sequences that begin with backslash.\nThis will give us one way to print a quote:\nprint('My friend\\'s friend\\'s dog\\'s friend')\nAnother way is to use one set of quotes to delimit the string that are different from the ones used within:\nprint('My friend\\'s friend\\'s dog\\'s friend')\nprint(\"bit my friend's dog's ankle\")\nprint('who yelped \"owww\"')\nHow does one print a backslash itself? By using a double backslash:\nprint('The backslash character, \\\\, is less intimidating now')\n\n\n\n\n\n\n0.1.9 Exercise\n\n\n\nWrite a program called practice_escaping.py that prints out\n  \"    \"   \\\\\\\n  \"    \"    \\    \n  \"\"\"\"\"\"    \\    \n  \"    \"    \\    \n  \"    \"   \\\\\\  \n\n\n\n0.1.10 Video\n\nAnother use of backslash: to make long strings\n\nSometimes we need to type in a really long string.\nThe following does NOT work:\n\nprint('An Ogden Nash poem:')\nprint('The camel has a single hump; \nThe dromedary, two; \nOr else the other way around. \nI’m never sure. Are you?')\n\n\n\n\n\n\n0.1.11 Exercise\n\n\n\nWrite a program called my_string_example4.py with the above program and run it. Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\nTo spread a single string over multiple lines, one uses a triple quote as in:\nprint('An Ogden Nash poem:')\nprint('''The camel has a single hump; \nThe dromedary, two; \nOr else the other way around. \nI’m never sure. Are you?''')\n\n\n\n\n\n\n0.1.12 Exercise\n\n\n\nWrite a program called my_string_example5.py with a 5-line limerick.\n\n\nEmpty strings: - It is possible to not have anything in a string, as in:\nprint('')\n\n\n\n\n\n\nNote\n\n\n\nThere are no letters, digits or anything between the two single quotes above.\n\n\n\nSuch a string is called an empty string.\nOdd as it may seem, empty strings are useful (we’ll see later) when you want to add strings to make a longer string."
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#case-sensitivity",
    "href": "units/unit0/modules/module0.1.html#case-sensitivity",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.3 Case sensitivity",
    "text": "0.1.3 Case sensitivity\nWhat if we had used uppercase P instead of lowercase p in print?\nprint('Hello World!')\n\n\n\n\n\n\n0.1.13 Exercise\n\n\n\nWrite up the above program in case_error.py and run it. Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\nWhat if we changed the case inside a string?\nprint('helLo WoRLd!')\n\n\n\n\n\n\n0.1.14 Exercise\n\n\n\nWrite up the above program in my_string_example6.py and run it to see if it works.\n\n\nPython is case sensitive but strings are like data inside programs, which means they can be whatever we like.\n\nThe two strings 'Hello World!' and 'helLo WoRLd!' are fine as two different strings, if that’s we want.\nHowever, Python has only one print and so it won’t recognize Print (with capital P)."
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#a-peek-at-the-future",
    "href": "units/unit0/modules/module0.1.html#a-peek-at-the-future",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.4 A peek at the future",
    "text": "0.1.4 A peek at the future\nWe will occasionally jump ahead and present an example of a program that does something advanced, just so you get a feel for what’s coming.\nWith these examples, we’ll only ask you to type up the program and run the program.\nAnd then we’ll point out a few features, just so that you get acquainted with features that you’ll eventually encounter.\nimport tkinter as tk\n\nwindow = tk.Tk()\ncanvas = tk.Canvas(master=window, width=500, height=400)\ncanvas.pack()\n\nfor i in range(1, 10):\n    fontSize = i * 20\n    fontStr = 'Times ' + str(fontSize) + ' italic bold'\n    startx = 200 + 10 * i\n    starty = 20 + i * 20\n    canvas.create_text(\n        startx, starty, text=\"Hello\", font=fontStr, fill='grey')\n\nwindow.mainloop()\n\n\n\n\n\n\n0.1.15 Exercise\n\n\n\nWrite up the above program in hello_gui.py being careful to type it in exactly as shown above, paying attention to every keystroke. Run it to get something like:  If something went wrong with the typing, you can instead download hello_gui.py but only after giving the typing a good try.\n\n\nNow let’s point out a few features of the program, and we’ll focus on the middle section: \nOur belief is that by showing you bits and pieces of advanced code, you’ll be primed to absorb these concepts when we work through them.\nOne of the most important things to observe about is that some code is indented:"
  },
  {
    "objectID": "units/unit0/modules/module0.1.html#a-reminder-about-computerese",
    "href": "units/unit0/modules/module0.1.html#a-reminder-about-computerese",
    "title": "Module 0.1: A few more getting-started examples",
    "section": "0.1.5 A reminder about computerese",
    "text": "0.1.5 A reminder about computerese\nAs you complete Module 1 and ready that for submission you might want to review: - Did you make your module1 folder? Did you ensure that the m in module1 is lowercase and that there’s no space module and 1? - Are your Python programs from this module in that folder? - Did you make your module1.pdf in this folder? Does it have the non-coding questions answered within? - Do you recall how to make a zip?\nIf it’s a bit hazy, please make sure to review from the material on computerese from Module 0.\n\n Previous Module: Module 0.0 Next Module: Module 0.2"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html",
    "href": "units/unit0/modules/module0.4.html",
    "title": "Module 0.4: Integers",
    "section": "",
    "text": "Home » Unit 0 » Module 0.4"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#objectives",
    "href": "units/unit0/modules/module0.4.html#objectives",
    "title": "Module 0.4: Integers",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module, for simple HelloWorld-like programs, you will be able to:\n\nCreate variable declarations.\nAssign values to variables by simple assignment, and print them out.\nDistinguish between integers in strings versus actual integers.\nDemonstrate ability to perform operations on integers for a desired output.\nSimplify expressions with constants to single value.\nEvaluate expressions with variables in them.\nConvert English descriptions of operations into expressions.\nMentally trace execution with expressions and calculations.\nMentally trace expressions and calculations inside for-loops.\nProduce desired output using for-loops and calculations.\nIdentify new syntactic elements related to the above.\n\nAnd, once we’ve worked with integers, we’ll also do some “number crunching”."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#first-an-analogy",
    "href": "units/unit0/modules/module0.4.html#first-an-analogy",
    "title": "Module 0.4: Integers",
    "section": "0.4.0 First, an analogy",
    "text": "0.4.0 First, an analogy\nSuppose we have boxes. Consider the following rules about “boxes”:\n\nEach box can store only one item.\n\n\n\nThe possible things that can be stored inside are called values.\nThus, at any given moment, a box’s value is whatever’s inside it.\nEach box has a unique name:\n\n\n\nThere is a cloning process that works like this: \n\nThe value inside one box is cloned.\nThe cloned value is placed inside another.\n\nThere is a strange shortcut notation to specify cloning: \n\nHere, the = (equals sign) does NOT mean “equals.”\nIt has been repurposed to mean “clone”, “copy,” or, in programming-language jargon, “assign”.\n\nHow to say it: “x is assigned the value in y”.\nImportant: Remember, a box can hold only one value at a time.\nThe technical term for our informal “box” is variable."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#integer-variables",
    "href": "units/unit0/modules/module0.4.html#integer-variables",
    "title": "Module 0.4: Integers",
    "section": "0.4.1 Integer variables",
    "text": "0.4.1 Integer variables\nWe’ll now start working with “boxes” (variables) that hold integers (whole numbers like 3, 17, 2097, but not numbers like 3.141).\nConsider this program:\ni = 5\nprint(i)\n\n\n\n\n\n\n0.4.1 Exercise\n\n\n\nType up the program in my_variable_example.py. Also save the file so that it can be submitted (Remember: you need to save the appropriate files for every such “type up” exercise).\n\n\n\nNow let’s examine key parts of this program:\nFirst, i is the name of a “box” (of sorts).\nThe term used for “box” is variable.    \n⇒ i is a variable.\nTo put something in a variable, we use assignment  \n⇒ with the repurposed = (equals) sign. \nWhen we print a variable, what gets printed is its value.   \n⇒ Thus, the number 5 gets printed \nImportant: What you see on printed out is the number 5 and NOT the letter i\nThus when you see print(i)you should think:\n\n“Hmmm, the print function is going to print the contents of variable i”.\n“I wonder what’s inside i?”\n“Let me look in the program to see what was the most recent value that got written into i”.\n\n\nFor example:\ni = 5\ni = 3\nprint(i)\n\n\n\n\n\n\n0.4.2 Exercise\n\n\n\nType up the above in my_variable_example2.py and confirm that 3 is what gets printed.\n\n\nBy way of explanation: \n\n\n\n\n\n\n0.4.3 Exercise\n\n\n\nIs it possible to not have a value in a variable? Consider this program:\ni\nprint(i)\nType up the program in my_variable_example3.py. Use comments (text followed by ‘#’ symbol) to describe the error if any in the python-file.\n\n\nThus: when you make a variable, you need to put something in it. - Next, let’s look at assignment between variables: - This is the analogue of cloning between “boxes”.\nConsider this program:\ni = 5\nj = i     # The value in i gets copied into j\nprint(j)  # Prints 5\n\nWe say, in short, “i is assigned to j”.\n\n\n\n\n\n\n\nTip\n\n\n\nWe’ve used comments above to annotate and explain.\n\nWe’ll do this often, knowing that comments are not executed.\n\n\n\n\n\n\n\n\n\n0.4.4 Exercise\n\n\n\nConsider this program:\ni = 5\nj = i\nprint(j)\nprint(i)   # Did i lose its value?\nType up the program in my_variable_example4.py and use comments (text followed by ‘#’ symbol) to describe what happens with print(i) # Did i lose its value?\n\n\nThe above example illustrates that the value in i gets copied into the variable j, which means that the value 5 is still in the variable i.\n\n\n\n\n\n\n0.4.5 Exercise\n\n\n\nConsider this program:\ni = 5\nj = i\nk = j\nprint(k)\nTry to identify the output of this program just by mental execution. Type up the program in my_variable_example5.py and confirm.\n\n\n\n\n\n\n\n\n0.4.6 Exercise\n\n\n\nConsider this program:\ni = 5\nj = i\ni = 0\nk = j\nj = 0\nprint(k)\nTry to identify the output of this program just by mental execution. Type up the program in my_variable_example6.py and confirm.\n\n\n\n\n\n\n\n\nNote\n\n\n\nA copied value does not change if the original is changed\n\n\nFor example, consider:\ni = 5\nj = i      # j now has 5\ni = 0      # We changed i here\nprint(j)   # j still has 5\n\nHere’s the line-by-line execution:\n\nThe first line puts the value 5 in variable i.\nThe second line copies the value in i (which is 5) into j. So j will have the value 5 as well.\nThe third line replaces the value 5 with value 0.\nj still has 5, so the fourth line will print 5.\n\n\n\n\n\n\n\n\nTip\n\n\n\n0 is an actual value, and is not “no value” or “nothing”.\n\n\n\n0.4.7 Video\n\n\n\n\n\n\n\n0.4.8 Exercise\n\n\n\nConsider this program:\nType up the following lines of code in my_variable_example7.py:\ni = 5\nj = 6      \n\n# Add code between here\n\n# and here.\n\nprint(i)   # should print 6\nprint(j)   # should print 5\nAdd some lines of code with the objective of swapping the values in variables i and j. You will need a third variable to be used as a holding place. Thus, without directly assigning the number 5 to j or the number 6 to i, write code using a third variable to achieve the desired swapping of values.\n\n\n\n\n0.4.9 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#integer-operators",
    "href": "units/unit0/modules/module0.4.html#integer-operators",
    "title": "Module 0.4: Integers",
    "section": "0.4.2 Integer operators",
    "text": "0.4.2 Integer operators\nLet’s examine the familiar arithmetic operators +, -, *, /\n\nAddition: +\nSubtraction: -\nMultiplication: *\nDivision: /\n\nConsider this example with addition:\ni = 5\nj = 6\nk = i + j\nprint(k)\n\nWhat happens during execution: \n\nThe values in i and j are added.\nThe resulting value goes into variable k.\n\nA long-ish way of saying this aloud:      \n⇒ “k is assigned the sum of the values of i and j”\nA shorter way:      \n⇒ “k is assigned i plus j”\n\nHere’s an example with multiplication and division:\ni = 5\nj = 6\nk = i * j\nprint(k)      # prints 30\nm = i / j\nprint(m)      # what does this print?\nn = i // j\nprint(n)      # what does this print?\n\n\n\n\n\n\n0.4.10 Exercise\n\n\n\nType up the above in my_variable_example8.py. What is the value of n printed? Change i to 21. What is the value of n printed? Change i to 21. Use comments (text followed by ‘#’ symbol) to describe what happens when you change i to 21. Submit your code with i set to 5.\n\n\nInteger division: - In math, we learned that 1/4 = 0.25 and 21/6 = 3.5.\n\nThis remains true in Python when we do something like\n      i = 21\n      j = 6\n      m = i / j\nOn the other hand, if we wish to perform integer division, we can use the integer division operator:\n      i = 21\n      j = 6\n      m = i // j\nThat is, the result is truncated down to the nearest integer.\n\nExample: 3 // 2 becomes 1 because 1.5 gets truncated to 1.\nExample: 15 // 4 becomes 3 because 3.75 gets truncated to 3.\n\nInteger division is useful when we want to do integer arithmetic."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#expressions-and-operator-precedence",
    "href": "units/unit0/modules/module0.4.html#expressions-and-operator-precedence",
    "title": "Module 0.4: Integers",
    "section": "0.4.3 Expressions and operator-precedence",
    "text": "0.4.3 Expressions and operator-precedence\nConsider the following program:\ni = 5\nj = 6\nk = i*j - (i+1)*(j-1)\nprint(k)\nAbout expressions:\n\nAn expression combines constants (like 1, above), and variables using operators.\nExample: i*j - (i+1)*(j-1).\nThe above expression is really equivalent to: (i*j) - ((i+1) * (j-1)). Here, we added some clarifying parentheses.\nOperator precedence allows us to reduce the number of clarifying parentheses.\nPython precedence follows standard precedence in math: /, *, +, -.\nYou might remember the precedence via the acronyms BODMAS or PEMDAS. (Look it up.)\nThe above expression is NOT the same as: i*j - i+1*j-1.\nAlso, note the change of whitespace:\n\nWe could have written k = i * j - (i + 1) * (j - 1).\nBut k = i*j - (i+1)*(j-1) is easier to read.\n\n\nLet’s dive a bit deeper into precedence and do some examples:\n\nWe’ll use the four operators: add or +, subtraction or -, multiplication or *, and division or /.\nWe’ll use plain ol’ numbers to illustrate.\n\n\n\n\n\n\n\nTip\n\n\n\nThe key to working them out is to use extra parentheses in the right way.\n\n\n\nThe PEMDAS rule:\n\nFirst apply Parentheses, then Exponents, then Multiplication and Division, and then Addition and Subtraction.\n\nExample: 3 + 2*4\n\nHere, we apply 2*4 to give 8\nThen do 3 + 8 to give 11.\nApplying extra parenthesis to 3 + (2*4) makes it clear.\n\nExample: 3(24/3-23)\n\nFirst, work out what’s inside the parens (the P of PEMDAS):\n\nDo div to 24/3 and mult to 2*3 to get (8 - 6)\nThis gives (2)\n\nNow go out and see that we need to do 3*(2)\nWhich gives 6.\nUsing extra parens and spacing makes it clear: 3 * ( (24/3) - (2*3) )\n\nExample: 1 + ( (4 - 1) * 8) / 6\n\nDo the innermost parens first: (4 -1) = 3\nWhich results in 1 + (3 * 8) / 6\nThen the next parens to give: 1 + 24/6\nThen the D in PEMDAS: 1 + 4\nResult: 5\n\n\n\n\n\n\n\n\n0.4.12 Exercise\n\n\n\nUse the PEMDAS rule to evaluate mentally or by hand the expression, i*j - i+1*j-1 when i = 7 and j = 3. Write a code to evaluate the expression and compare your answer.\n\n\n\n0.4.13 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#more-about-expressions-and-assignment",
    "href": "units/unit0/modules/module0.4.html#more-about-expressions-and-assignment",
    "title": "Module 0.4: Integers",
    "section": "0.4.4 More about expressions and assignment",
    "text": "0.4.4 More about expressions and assignment\nThe remainder operator:\n\nThe expression 10 % 3 is “the remainder when 10 is divided by 3”.\nThus 10 % 3 is 1.\nSimilarly 11 % 4 is 3.\nThe remainder operator is sometimes called modulo, as in “ten modulo 3 is 1”\n\nConsider this example:\ni = 14\nj = -6\nk = i % (-j)\nprint(k)\n\n\n\n\n\n\n0.4.14 Exercise\n\n\n\nCan you mentally execute and identify what’s printed? Type up the above in my_expression_example2.py to confirm.\n\n\nOne way to know whether one number cleanly divides another is to apply the % (remainder) operator.\nConsider this program:\nj = 10\nfor i in range(1, j):\n    k = j % i\n    print(k)\n\n\n\n\n\n\n0.4.15 Exercise\n\n\n\nCan you mentally execute and identify what’s printed? Type up the above in my_expression_example3.py to confirm. Then change j to 11 and run the program. When submitting the code, leave j as 11.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIn the above exercise we systematically obtained the remainder when dividing 10 (the value of j) by every possible number less than 10.\nWhenever the output is 0 in some iteration, we know 10 % i is 0 for that iteration.\nThis means i divides 10 cleanly (with no remainder).\nFor example 10 % 5 is 0.\nWhenever a number j has nothing less than j that divides j cleanly, the number is called a prime number.\nExamples of prime numbers: 7 and 11.\nExamples of non-prime numbers: 10 and 15\nThe notion of a prime number may seem like an esoteric topic, suitable for a dinner conversation with mathematicians. But it turns out to have immense practical value: much of cryptography is based on properties of numbers that can be cleanly divided by only two prime numbers.\n\n\n\n\n0.4.16 Video\n\nNow we’ll look at a strange (initially) but very useful type of assignment:\nConsider this program:\ni = 8\ni = i + i/2\nprint(i)\n\nPrior to evaluating the expression, i has value 8.\nOn the right side, the current value of i is used to evaluate the expression.       \n⇒ Thus, the expression evaluates to (8 + 8/2) = 12.\nThis evaluated value then goes into variable i.       \n⇒ After the assignment, i has the value 12.\n\nLet’s use this to compute the sum of numbers from 0 to 10:\ns = 0\nfor i in range(0, 11):\n    s = s + i\nprint(s)\n\n\n\n\n\n\n0.4.17 Exercise\n\n\n\nTrace the changing values of s in the above program using the following kind of table: \nTry writing up the table in a spreadsheet or a document. There is nothing to submit in this exercise.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn this and other tracing exercises involving a table, you can simply draw the table by hand and include a picture. (That is, you don’t have to spend time on making tables inside Word.)\n\n\nConsider this program:\nN = 5\ns = 0\nfor i in range(1, N+1):\n    s = s + (2*i - 1)\nprint(s)\n\nThe program prints the sum of the first N odd numbers.\nRecall from earlier that as i goes through 1, 2, 3, … (2*i-1) evaluates as successive odd numbers 1, 3, 5, …\n\n\n\n\n\n\n\n0.4.18 Exercise\n\n\n\nWrite up the above program in my_expression_example4.py, edit the code to create an outer loop that varies N from 1 to 10… That is, make N a new for-loop variable that ranges between 1 and 10 (inclusive), and ensure that you properly indent the inner (nested) loop that uses i. Observe the pattern in the output and follow what the program is doing.\n\n\n\n\n0.4.19 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#problem-solving-and-pseudocode",
    "href": "units/unit0/modules/module0.4.html#problem-solving-and-pseudocode",
    "title": "Module 0.4: Integers",
    "section": "0.4.5 Problem solving and pseudocode",
    "text": "0.4.5 Problem solving and pseudocode\nSuppose we were given the following problem: write a program to print the first N odd numbers.\nWe’ll solve it in the following steps:\n\nFirst, let’s sketch out a “program-like” outline (not a real program):\nN = 10      \nfor i ranging from 1 to N:\n    Calculate the i-th odd number\n    Print it\nThis kind of rough outline is called pseudocode       \n⇒ We’re meant to do this on paper, prior to programming.\nPseudocode looks a little like code, but is half-English.\nFor any given i, the i-th odd number is:       \n2*i - 1.\nNow let’s put this together into a program:\nN = 10\nfor i in range(1, N+1):\n    k = (2*i - 1)\n    print(k)\n\n\n\n\n\n\n\n0.4.20 Exercise\n\n\n\nTrace the values of i and k in the program above using a table in a spreadsheet or a document. Write up the above program in loop_exercise1.py. There is nothing to submit in this exercise"
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#a-problem-solving-example-with-variables-and-nested-for-loops",
    "href": "units/unit0/modules/module0.4.html#a-problem-solving-example-with-variables-and-nested-for-loops",
    "title": "Module 0.4: Integers",
    "section": "0.4.6 A problem-solving example with variables and nested for-loops",
    "text": "0.4.6 A problem-solving example with variables and nested for-loops\nWe’ll solve the following problem: for any given n, compute       \n1 + 21 + 22 + 23 + … + 2n\nThat is, the sum of consecutive powers of 2.\nAs a first step, let’s see if we can use a loop to compute a single power of 2:\n\nSuppose we wish to compute 2k for some k.\nWe know that       \n2k = 222 … *2        (k times)\nThus, what we could is:       \nStart with p = 1       \nMultiply by 2: p = p * 2       \nMultiple that result by 2: p = p * 2       \n… etc\nIn pseudocode:\np = 1  \nfor i ranging from 1 to k:\n  p = p * 2\nLet’s put this into code and test:\nk = 10\np = 1\nfor i in range(1, k+1):\n    p = p * 2\nprint(p)\n\n\n\n\n\n\n\n0.4.21 Exercise\n\n\n\nTrace the changing values of p in the above program using a table in a spreadsheet or a document. Write up the above program in my_powerof2.py to confirm and submit.\n\n\n\n0.4.22 Video\n\n\nNext, let’s look at pseudocode for the sum of powers (our original problem):\ns = 1    \nfor k ranging from 1 to n:\n    Compute k-th power of 2\n    Accumulate in s\nPrint s\nNow, let’s put this all together:\nn = 5\ns = 1\nfor k in range(1, n+1):\n    p = 1\n    for i in range(1, k+1):\n        p = p * 2\n    s = s + p\nprint(s)\nLet’s point out a few things.\n\nFirst, let’s have our eyes look over the outer-loop and not focus on the details of the inner loop: \nNow look inside the body of the outerloop: \nTry to get a feel for how it executes by looking at the first iteration of the outerloop: \n\n\n\n\n\n\n\n\n0.4.23 Exercise\n\n\n\nMake a table with columns labeled k, i, p and s and trace the program, filling in the table step-by-step. There is nothing to submit in this exercise.\n\n\n\n\n0.4.24 Video:\n\n\n\n\n\n\n\n0.4.25 Exercise\n\n\n\nWatch the video above and try a few other values of n, e.g., n = 3 or n =4. Try to guess the mathematical formula for 1 + 21 + 22 + 23 + … + 2n\n\n\n\n\n\n\n\n\nTip\n\n\n\nAdd 1 to the sum-of-powers of 2."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#shortcut-operators",
    "href": "units/unit0/modules/module0.4.html#shortcut-operators",
    "title": "Module 0.4: Integers",
    "section": "0.4.7 Shortcut operators",
    "text": "0.4.7 Shortcut operators\nRecall the integer-sum program:\ns = 0\nfor i in range(0, 11):\n    s = s + i\nprint(s)\nWe can write this using the “shortcut addition” operator += as follows:\ns = 0\nfor i in range(0, 11):\n    s += i\nprint(s)\nThus, s += i is the same as s = s + i\nOne can read s += i as “add i to what’s already in s, and store the result in s”.\nThis can be applied to the other operators as well:\ns -= i         # Same as s = s - i\np *= 2         # Same as p = p * 2\nd /= 2         # Same as d = d / 2\n\n\n\n\n\n\n0.4.26 Exercise\n\n\n\nIn my_sum_powerof2.py rewrite the example code that computes the sum of power of 2, using shortcut operators where possible."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#when-things-go-wrong",
    "href": "units/unit0/modules/module0.4.html#when-things-go-wrong",
    "title": "Module 0.4: Integers",
    "section": "0.4.8 When things go wrong",
    "text": "0.4.8 When things go wrong\nAs you might imagine, there are many ways to inadvertently create errors.\nIn each case below, first try to identify the error just by reading. Then, type up the program to confirm.\n\n\n\n\n\n\n0.4.27 Exercise\n\n\n\nWhat is the error in this program?\ni = j\nj = 4\nprint(i)\nType it up in error1.py to confirm. Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\n\n\n\n\n\n\n0.4.28 Exercise\n\n\n\nWhat is the error in this program?\ni = 4\nj = 3\nk = ( (i + j) * (i - j) / 2\nprint(k)\nType it up in error2.py to confirm. Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\nWe’ll now see a different kind of error:\nn = 5\nfor i in range(1, n+1):\n    k = n / (n - i)\n    print(k)\n\n\n\n\n\n\n0.4.29 Exercise\n\n\n\nType it up in error3.py to confirm. Trace through the program to understand why there is an error. Use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\n\n\n\n\n\n\nHint\n\n\n\nThe above is an example of a runtime error:\n\nThe code itself is correctly written in that there are no issues with breaking the rules of the language.\nHowever, when i is 0, you can’t divide by 0.\nThis causes a runtime error, meaning the program runs fine until the particular occurence of divide-by-zero."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#python-files-vs-module-pdf",
    "href": "units/unit0/modules/module0.4.html#python-files-vs-module-pdf",
    "title": "Module 0.4: Integers",
    "section": "0.4.9 Python files vs module pdf",
    "text": "0.4.9 Python files vs module pdf\nImportant:\n\nBy now it should be clear what you type into a Python file (ends with .py) verses what goes into your module pdf.\nCode goes into the specified Python file (example: error3.py) and all other answers go into your module pdf (numbered by module#, such as: module4.pdf).\nYour module pdf (a single pdf per module) will have all the non-coding answers for a module. Whereas, a module can have many different Python files.\nThus, in future modules, we will only specify the Python filename with the understanding that you know how to name your module pdf."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#a-peek-at-the-future",
    "href": "units/unit0/modules/module0.4.html#a-peek-at-the-future",
    "title": "Module 0.4: Integers",
    "section": "0.4.10 A peek at the future",
    "text": "0.4.10 A peek at the future\nLet’s now revisit some earlier code hello_gui.py and apply what’ve learned about integers, arithmetic, and for-loops: \nNext, consider this program that uses a for-loop to plot points:\nfrom drawtool import DrawTool \nimport math\n\ndt = DrawTool()\ndt.set_XY_range(0,10, 0,10)\n\nfor i in range(0, 6):\n    j = 2*i + 1\n    dt.draw_point(i, j)\n\ndt.display()\n\n\n\n\n\n\n0.4.30 Exercise\n\n\n\nDownload drawtool.py into your module4 folder. Then, type up the above in my_plot_points.py, and run.\n\n\nLet’s point out:\n\nLet’s focus on the parts we recognize (the for-loop): \n\nSo, when i is 0, j is calculated as 1\nThis plots the point (0,1).\nThen, when i is 1, j becomes 3, which results in the point (1,3).\n… and so on.\n\nThe points are the dots shown in the plot.\nWhen you downloaded drawtool.py, you downloaded another Python program into the same folder.\n\nThis is a program that provides drawing and plotting features.\nWe’ve used one of its features here (plotting points), and will use drawtool.py again in the future.\n\nNotice that the plotted points are along a straight line, implying a linear relationship between i and j.\nWe will occasionally write programs that work with numbers and quantitative concepts. As a result, we’ll encounter mathematical ideas in a different way, through programming."
  },
  {
    "objectID": "units/unit0/modules/module0.4.html#meta",
    "href": "units/unit0/modules/module0.4.html#meta",
    "title": "Module 0.4: Integers",
    "section": "0.4.11 Meta",
    "text": "0.4.11 Meta\nAnother in our series of occasional “meta” sections that will step back from the material to comment on how we can learn better.\nThis was a loooong module with lots of exercises and details. Let’s review:\n\nWe introduced the all-important concept of a variable along with the sense that there’s a “place” in the computer for each variable.        ⇒ The “place” is really in the memory (also called RAM) of the computer.\nAlong with variables is the notion of assignment, which means “copying the value in one variable into another variable”.\n\n\n\n\n\n\n\nTip\n\n\n\nAssignments are amongst the most common of statements in everyday code.\n\n\n\nWhen a variable is of a numeric type like integers, we also need to go over basic operators and show examples.\nFurther complications arose when the operators have variations.\nSince we were on the topic of integers, we took this opportunity to learn how to do some number-crunching.\nWhen we got to nested loops, it got tricky following the values of variables through multiple nested loops.\n\nSo, if you felt a bit overwhelmed, that’s perfectly understandable. If you have to go back to some of the material to review or try some exercises again, that’s fine. You’re going to get better at this!\n Previous Module: Module 0.3 Next Module: Module 0.5"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html",
    "href": "units/unit0/modules/module0.6.html",
    "title": "Module 0.6: Real Numbers",
    "section": "",
    "text": "Home » Unit 0 » Module 0.6"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#objectives",
    "href": "units/unit0/modules/module0.6.html#objectives",
    "title": "Module 0.6: Real Numbers",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module, for simple programs with real numbers, you will be able to:\n\nCreate variable declarations for variables.\nAssign values to variables by simple assignment, and print them out.\nDemonstrate ability to perform operations for a desired output.\nEvaluate expressions with variables in them.\nConvert English descriptions of operations into expressions.\nMentally trace execution with expressions and calculations.\nMentally trace expressions and calculations inside for-loops.\nProduce desired output using for-loops and calculations.\nIdentify new syntactic elements related to the above."
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#what-are-real-numbers",
    "href": "units/unit0/modules/module0.6.html#what-are-real-numbers",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.0 What are real numbers?",
    "text": "0.6.0 What are real numbers?\nLet’s start with some math facts:\n\nWhole numbers like 3, 42 and 1024 are integers.  (As an aside: integers include 0 and the negative ones like -2 or -219).\nThe collection of all integers is infinite in size.\nBut integers are limited because some operations on integers do not yield integers:\n\n30 ÷ 5 gives 6, which is an integer.\nBut 31 ÷ 5 is not an integer, yet it’s a quantity.\n\nReal numbers include all the integers but also numbers like 3.141, and -615.2368.\nThe collection of all real numbers is also infinite. Interestingly, it’s a bigger kind of infinite (but that’s a rather subtle math argument outside the scope of this course).\nThe term real is just that: a term that’s came about historically to describe all these numbers.\nYou might wonder: is there any other kind of number?\nTurns out: yes, there a fascinating (and extraordinarily useful) kind of number called an imaginary number, or more generally, a complex number.  (We won’t be working with these in his course.)\nWhat does one do with real numbers?\n\nThe same operations: +, -, *, /\nWhat’s nice is that applying these to real numbers will always result in real number results.\n\nFor example:\nx = 3.14\ny = 2.718\nz = x + y\nprint(z)\n\nw = z * (x + y) / (x - y)\nprint(w)\n\n\n\n\n\n\n\n0.6.1 Exercise\n\n\n\nType up the above in my_real_example1.py. What is the output?\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou might have seen 5.8580000000000005 as the value of z printed out.\nHowever, you might also have seen something slightly different because of the approximate nature of such calculations, a limitation of computer hardware.\nThese tiny errors are tiny indeed, but vary slightly from one computer to another, generally occuring around the 16th decimal place: 0.00000000000000001\nDo we need to worry about this? Only if we are engaged in complex scientific calculations.\nOccasionally, however, it can matter. For example, if two people calculate mortgage interest (with real consequences) slightly differently, it could lead to a legal conflict.\n\n\n\nQuick review of some relevant math:\n\nOne kind of operation that’s useful is power.\nWe write 26 to mean 2 x 2 x 2 x 2 x 2 x 2 (six times)\nIt’s easy to see that you could make this work for real numbers that get multiplied: 2.566 = 2.56 x 2.56 x 2.56 x 2.56 x 2.56 x 2.56\nBut could you do 26.4? Turns out, yes, you can do this even if it’s not easy to see or intuit. (We would expect 26.4 to be larger than 26 and smaller than 27, which it is.)\nThe next step then is to allow numbers like 2.566.4.\nIn fact, you can take any real number as the mantissa (the 2.56 in 2.566.4) and any real number as the exponent (the 6.4 in 2.566.4).\nLet’s put this in code and introduce a new operator to raise a number to a power, as in 2.566.4).\nx = 2 ** 6\nprint(x)\n\ny = 2.56 ** 6.4\nprint(y)\n\n\n\n\n\n\n\n0.6.2 Exercise\n\n\n\nType up the above in my_real_example2.py. What is the output? Consider 2.56x = y. Can you guess what approximate value of x would make y become 400? Play around with the number 6.4 in the program above and see if you can guess approximately what value would make y become 400.\n\n\nLet’s explore further:\n\nThe technical term for “what is x that would make 2.56x = 400?” is logarithm.\nWe would say: x = log2.56(400).  (Read this as: x is equal to log of 400 to the base 2.56).\nWe can calculate this directly:\nimport math\n\nx = math.log(400, 2.56)\nprint(x)\nHere we’ve introduced some new concepts: \nJust like you can ask Python to calculate logarithms using math.log, you can do other kinds of “calculator” functions conveniently.\nExample: math.sqrt for square roots.\n\n\n\n\n\n\n\n0.6.3 Exercise\n\n\n\nIn my_real_example3.py, fill in code below\nimport math\n\n# Write a line of code here\n\nprint(x)\nto compute the square root of 2 and print the square root (and only the square root - just one number).\n\n\n\n0.6.4 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#going-from-reals-to-integers-and-strings",
    "href": "units/unit0/modules/module0.6.html#going-from-reals-to-integers-and-strings",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.1 Going from reals to integers and strings",
    "text": "0.6.1 Going from reals to integers and strings\nConsider this program:\nimport math\n\nx = 3.141\nprint('x=' + str(x))\n\ni = math.floor(x)\nj = math.ceil(x)\nprint('Rounding down x gives ' + str(i))\nprint('Rounding up x gives ' + str(j))\n\n\n\n\n\n\nTip\n\n\n\n\nThe floor function identifies the integer part of a number like 3.141, in this case 3.\nceil identifies the next higher integer, in this case 4.\nSo, any number with digits after the decimal point like 3.141 lies between its floor and ceiling.\n\n\n\n\n\n\n\n\n\n0.6.5 Exercise\n\n\n\nType the above in my_real_example4.py. Then, add additional lines of code to print the floor and ceiling of 2.718 in the same way that the floor and ceiling of 3.141 were printed above.\n\n\nLet’s point out a few things: \nNext, getting real numbers as input:\nimport math\n\n# input always results in a string\nx_str = input('Enter a number: ')\n\n# This is how we convert a string into a real number:\nx = float(x_str)\n\n# We use str to embed a number in a string:\nprint('The square of the number you entered is: ' + str(x*x))\n\n\n\n\n\n\nNote\n\n\n\n\nWe use the int() function to convert a string representation of an integer into an actual integer ready for arithmetic, as in:\npounds_str = input('Desired flour in pounds: ')\npounds = int(pounds_str)\nounces = 16 * pounds\nprint('Flour amount in ounces: ' + ounces)\nThe equivalent for real numbers is float:\nx = float(x_str)\nWhy is it called so?\n\nObserve that we can write the number 234.56 as 23.456 x 101 or as 2.3456 x 102 or as 0.23456 x 103, or to exaggerate this idea: 0.000000000023456 x 1013\nThe decimal point can thus, be “floated” around by adjusting the exponent (like 13).\nThis is called floating-point notation.\n\nSo, what does it mean to have a string representation of a number versus the actual number?\n\nFirst, consider this program:\nsome_string = '3.141'\nx = float(some_string)\n# Now we can use x in arithmetic\ny = x / 2\n\n\nWe cannot use some_string in arithmetic.\n\nThe following does NOT work:\nx = '3.141'\ny = x / 2\nprint(y)\n\n\n\n\n\n\n\n\n\n0.6.6 Exercise\n\n\n\nWhat is the error in the above program? Now change the second statement from y = x / 2 to y = x * 2. What do you see? Write your code in my_real_example5.py. Submit the version with y = x / 2, use comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\nThe last exercise illustrates the strange way in which operators like + and * are repurposed for strings when used with strings:\n\nConsider this example:\ns = 'Hello'\nt = ' World'\nu = s + t\nprint(u)\nv = s * 3   # Makes 3 copies of s and concatenates them\nprint(v)    # Prints HelloHelloHello\n\n\n\n\n\n\n\n0.6.7 Exercise\n\n\n\nType up the above in my_string_example.py and confirm.\n\n\n\n0.6.8 Video\n\nNow, back to real numbers.\n\n\n\n\n\n\n0.6.9 Exercise\n\n\n\nIn my_conversion_example.py write a program that asks the user to enter a distance in kilometers, and then converts to miles and prints that number."
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#real-numbers-and-loops",
    "href": "units/unit0/modules/module0.6.html#real-numbers-and-loops",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.2 Real numbers and loops",
    "text": "0.6.2 Real numbers and loops\nThere are two ways in which we’ll work with real numbers and loops:\n\nThe first will use integers to drive the loop’s iterations as in:\nfor k in range(1, n):\n    # do stuff\nHere, k, 1, and n, are all integers.\nThe second is more advanced in that real numbers can themselves be used in the range. We’ll tackle this approach later but we’ll give you a preview of what it looks like:\nfor r in np.arange(0.1, 1, 0.2):\n    # do stuff\n\nLet’s start with an example:\nnum_years = 5\ninterest_rate = 5.0\namount = 80\n\nfor year in range(1, num_years + 1):\n    interest = (interest_rate/100) * amount\n    amount = amount + interest\n    print('After ' + str(year) + ' years,', end='')\n    print('amount = ' + str(amount))\n\n\n\n\n\n\n0.6.11 Exercise\n\n\n\nType up the above in my_compound_interest.py. What is the final amount printed? Trace through the iterations above using a table in a spreadsheet or a document, tracking the variables year, amount, interest.\n\n\nLet’s point out: \n\n\n\n\n\n\n0.6.12 Exercise\n\n\n\nIn my_compound_interest2.py, write two successive (not nested) for-loops to compare what happens when $1000 is invested for 20 years in each of two mutual funds, one of which has an annual growth rate of 3%, and the other 8%. Write your program so that it only prints at the end of the program, and prints the amount by which the 8% fund exceeds the 3% fund (at the end of 20 years). Now you know what a 401-K program is about."
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#some-greek-history-via-programming",
    "href": "units/unit0/modules/module0.6.html#some-greek-history-via-programming",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.3 Some Greek history via programming",
    "text": "0.6.3 Some Greek history via programming\n\n\n\nZeno’s paradox:\n\nZeno was a Greek philosopher famous for creating several apparent paradoxes.\nHis most famous one: the hare and the tortoise\n\nSuppose a hare and tortoise are separated by 1 unit of distance, for example: 1 mile. \nSuppose hare is twice as fast as tortoise.\n\nIn the time the hare covers 1 unit, the tortoise has moved foward 1/2 unit.\nIn the time taken to cover this 1/2 unit, the tortoise has moved forward 1/4 unit … etc.\nZeno claimed that by the time the hare catches up, the tortoise will have traveled:        1/2 + 1/4 + 1/8 + 1/16 + … (The dots at the end indicate “keep adding these terms forever”)\nThis is an infinite sum. He said: if you add an infinite number of numbers, you’ll get something infinitely big.\nThus, Zeno’s paradox is: the hare will never catch up.\nLet’s resolve this by writing a program to compute        1/2 + 1/4 + 1/8 + 1/16 + …\nSuch a sum is often called a series.\nLet’s write a program to compute this for any number of terms in the series.\nWe’ll start by noticing that each successive term is half the previous one:\n\n1/4 is half of 1/2.\n1/8 is half of 1/4.\n1/16 is half of 1/8.\n… and so on.\n\nTo compute half of something, we multiply by 1/2.\nHere’s the program:\nn = 5\ntotal = 0\nterm = 1/2\nfor k in range(n):\n    total = total + term\n    term = term * (1/2)\n\nprint(total)\n\n\n0.6.13 Video\n\n\n\n\n\n\n\n0.6.14 Exercise\n\n\n\nType up the above in my_zeno.py. Trace through the values of each of the variables using a table in a spreadsheet or a document\n\n\nLet’s point out:"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#a-statistical-application",
    "href": "units/unit0/modules/module0.6.html#a-statistical-application",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.4 A statistical application",
    "text": "0.6.4 A statistical application\nLet’s use a loop to compute that most basic of statistical things: an average\nFor example, suppose we wish to compute the average of the numbers from 1 to 10:\nn = 10\ntotal = 0\n\nfor k in range(1, n+1):\n    total = total + k\n\navg = total / n\nprint('Average=' + str(avg))\n\n\n\n\n\n\n\n0.6.15 Exercise\n\n\n\nType up the above in my_stats1.py. What is the average?\n\n\n\n\n\n\n\n\n0.6.16 Exercise\n\n\n\nIn my_stats2.py, modify the above code to compute the average of odd numbers from 1 through 9, and check against the answer you get computing by hand. Then, use your program to compute the average of odd numbers between 1 and 100.\n\n\nWe’ll next look at a problem at the intersection of language and statistics:\n\nMany nouns in English are long, especially words ending in “tion” like “conservation”.\nIn contrast, we see a lot of short verbs like “go”, “eat” and so on.\nSo, is it true that English nouns are, on average, longer than English verbs? Let’s find out.\nOne way to do this is to get all nouns and all verbs, compute average lengths and compare.\nHowever, we’ll do this statistically by randomly sampling nouns and verbs.  (Because this is the “stats” section of the module, after all.)\nWe’ll provide most of the code, leaving you to fill out one line:\nimport wordtool\n\nn = 10\ntotal = 0\n\nfor k in range(1, n+1):\n    word = wordtool.get_random_noun()\n    # FILL IN THE MISSING LINE HERE:\n\navg = total / n\nprint('Average word length = ' + str(avg))\n\n\n\n\n\n\n\n\n0.6.17 Exercise\n\n\n\nFill in the missing line and write up the program in my_stats3.py. You will need to download wordtool.py and wordsWithPOS.txt.\n\n\n\n\n\n\n\n\n0.6.18 Exercise\n\n\n\nIn my_stats4.py, modify the above to estimate the average length of verbs. Compare the average length of nouns to the average length of verbs. Do you think n=10 is enough of a random sample? Try higher values of n. What should n be to feel assured that you have a sound comparison?"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#plotting-a-function",
    "href": "units/unit0/modules/module0.6.html#plotting-a-function",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.5 Plotting a function",
    "text": "0.6.5 Plotting a function\nLet’s plot the well-known () function.\n\nWe’ll plot this in the range [0,10].\nLet’s start by picking 20 points to plot.\nWe’ll divide the interval [0,10] into 20 so that the x values (along the x-axis) are\n\n    0\n    0.5\n    1.0\n    1.5\n    ... (20 equally spaced values along x-axis)\n    9.5\n    10.0\n\nPictorially, this is what we’ve done so far\n\n\n\nThen, the y-values are calculated by applying the function:\n\n    f(0)    = sin(0)      =  0 \n    f(0.5)  = sin(0.5)    =  0.48\n    f(1.0)  = sin(1.0)    = 0.84\n    f(1.5)  = sin(1.5)    = 0.997\n    ... \n    f(9.5)  = sin(9.5)    = -0.075\n    f(10.0) = sin(10.0)   = -0.54\n\nFor now, don’t worry about the meaning of this sin function.\n\nJust think of it as, you give it a value like 0.5, and it gives back a number like 0.005.\nWe’ll say more about this below.\n\n\n\n\n\n\n\n\n0.6.19 Exercise\n\n\n\nUse a scientific calculator (included in every laptop) to calculate the sin values for the 20 input values beginning with 0, 0.5, 1, … etc .. until 10. Then plot this by hand on paper. There is nothing to submit in this exercise\n\n\n\n0.6.21 Video\n\nLet’s now do the plotting in code:\nfrom drawtool import DrawTool \nimport math\n\ndt = DrawTool()\ndt.set_XY_range(0,10, -2,2)\nN = 20\nx_spacing = 10 / N\nx = 0\nfor k in range(0, N):\n    y = math.sin(x)\n    dt.draw_point(x, y)\n    x = x + x_spacing\n\ndt.display()\n\n\n\n\n\n\n0.6.22 Exercise\n\n\n\nDownload drawtool.py into your module6 folder. Then type up the above in my_functionplot.py and execute. Change N to 100. This should produce a smoother curve. Next, change the statement\nfor k in range(0, N):\nto\nfor k in range(1, N+1):\nUse comments (text followed by ‘#’ symbol) to explain why this does not change the results in the python-file.\n\n\nLet’s point out: \n\n\n\n\n\n\nNote\n\n\n\n\nMuch of the complication in this program comes from how we use another program in our program:\n\nTo perform plotting or drawing, we will use the drawtool.py program.\nTo use this program involves many types of statements, such as:\ndt = DrawTool()\ndt.set_XY_range(0,10, -2,2)\namong others.\nThere are aspects we’re not going to be able to understand now, but we can at least use the program.\n\nNotice that when N=20, the spacing is 10/20 (which is equal to 0.5).\nIf a higher value of N were used, we’d have smaller spacing and therefore a smoother curve.\n\n\n\nAbout mathematical functions:\n\nThe term function means different things in programming and math.\nFor us in programming, a function is a chunk of code that can be referenced by a name and used multiple times just by using that name.\nIn math, a function is a calculation mechanism, which we can think of as “something that takes in a number and outputs a number via a calculation”:\n\nFor example: \nIn this particular case, suppose we feed in 8, we get 64 \nThe rule that turns the input number into the output number is: multiply the input number by itself.\nThus: 82 = 64\nTo describe this in a simpler way, we use symbols like x \nAnd instead of drawing boxes, we use mathematical notation like this: f(x) = x2.\nRead this as: the function takes in a number x and produces x2.\n\nThere are a gazillion functions, some of which are well-known and have stood the test of time.\nAmongst these well-known functions are the trigonometric functions like sin.\nThus, sin(x) takes in a number x and produces a number as a result.\nIn the early 1600’s Rene Descartes made a startling discovery that dramatically changed the world of math:\n\nYou can make axes.\nFor every possible x you can compute f(x)\nThen draw each pair x, f(x) as a point.\nThis produces a curve that allows one to visualize a function.\n\nThis is what we did when we plotting the sin function.\n\nAbout the sin function:\n\nYou may vaguely recall trigonometry from high-school, or have happily forgotten it.\nPerhaps you recall triangles and ratios of sides.\nThe sin function arose from those ideas.\nWhile silly little triangles may seem a mere high-school math exercise, it turns out that functions like sin have proven extraordinarily useful both in real-world applications and in pure mathematics.\nWe’re not going to require much math knowledge in this course but will make observations from time to time."
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#plotting-a-curve-with-data",
    "href": "units/unit0/modules/module0.6.html#plotting-a-curve-with-data",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.6 Plotting a curve with data",
    "text": "0.6.6 Plotting a curve with data\nNext, let’s work with some real data\nConsider the following data:\n\n\n\n\n\nx\n\n\nf(x)\n\n\n\n\n8.33\n\n\n1666.67\n\n\n\n\n22.22\n\n\n3666.67\n\n\n\n\n23.61\n\n\n4833.33\n\n\n\n\n30.55\n\n\n5000\n\n\n\n\n36.81\n\n\n5166.67\n\n\n\n\n47.22\n\n\n8000\n\n\n\n\n69.44\n\n\n11333.33\n\n\n\n\n105.56\n\n\n19666.67\n\n\n\n\n\nLet’s write code to display this data:\nfrom drawtool import DrawTool \nimport math\n\ndt = DrawTool()\n\ndt.set_XY_range(0,120, 0,20000)\n\nx = 8.33\nf = 1666.67\ndt.draw_point (x, f)\n\nx = 22.22\nf = 3666.67\ndt.draw_point (x, f)\n\nx = 23.61\nf = 4833.33\ndt.draw_point (x, f)\n\nx = 30.55\nf = 5000\ndt.draw_point (x, f)\n\nx = 36.81\nf = 5166.67\ndt.draw_point (x, f)\n\nx = 47.22\nf = 8000\ndt.draw_point (x, f)\n\nx = 69.44\nf = 11333.33\ndt.draw_point (x, f)\n\nx = 105.56\nf = 19666.67\ndt.draw_point (x, f)\n\ndt.display()\n\n\n\n\n\n\n0.6.23 Exercise\n\n\n\nYou already have drawtool.py in your module6 folder. Type up the above in my_dataplot.py and run. Do you see the points “sort of” along a jagged line? This is actual scientific data from observations made in 1929. It utterly shattered our perception of the world. Can you identify what this was about and explain the significance?"
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#when-things-go-wrong",
    "href": "units/unit0/modules/module0.6.html#when-things-go-wrong",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.7 When things go wrong",
    "text": "0.6.7 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n0.6.24 Exercise\n\n\n\nx = 2 *** 6\nprint(x)\nFix the error in my_error1.py.\n\n\n\n\n\n\n\n\n0.6.25 Exercise\n\n\n\nx = 100\ny = 0.1 * x\nprint('y=' + y)\nFix the error in my_error2.py.\n\n\n\n\n\n\n\n\n0.6.26 Exercise\n\n\n\nimport math\nx = input('Enter your height in inches: ')\ny = math.floor(x / 12)\nprint('You are at least ' + str(y) + ' feet tall')\nFix the error in my_error3.py.\n\n\n\n\n\n\n\n\n0.6.27 Exercise\n\n\n\nfor x in range(1.0, 2.0, 0.1):\n    print(x)\nFix the error in my_error4.py so that the numbers 1.0, 1.1, 1.2, …, 2.0 are printed out.\n\n\n\n\n\n\n\n\nTip\n\n\n\nUse integers in range but use separate variables to run through the real numbers."
  },
  {
    "objectID": "units/unit0/modules/module0.6.html#about-the-reals-and-math-in-general",
    "href": "units/unit0/modules/module0.6.html#about-the-reals-and-math-in-general",
    "title": "Module 0.6: Real Numbers",
    "section": "0.6.8 About the reals, and math in general",
    "text": "0.6.8 About the reals, and math in general\nWe’ve gone a bit beyond our comfort zone into real numbers and into some applications.\nWe’ll end this module by pointing out a few more things about numbers in a mathematical sense, and say something about math anxiety. None of this will be on any exam.\nLet’s start with numbers:\n\nThe easiest kind of number to understand are the natural numbers.\n\nThey are the numbers 1, 2, 3 … and so on.\nIt’s an infinite set, and many operations like + and * applied to naturals result in a natural.\nBut 3 - 5 is not a natural number, and neither is \\[ \\frac{3}{5} \\].\nSo, they’re limited in their use.\n\nIf we expand the naturals and add 0, and all the negative numbers, we get \\[\n          \\ldots -3, -2, -1, 0, 1, 2, 3 \\ldots\n  \\] (The triple-dot that indicates “going on forever” occurs now on both sides, the positive side and the negative side.)\n\nHowever, they too are limited because neither \\[ \\frac{3}{5} \\] nor \\[ \\frac{5}{3} \\] are integers.\n\nThe next kind of number to consider is rational number:\n\nA rational is a number that can be written as a fraction (or ratio) of integers.\nExamples: \\[ \\frac{5}{3}, \\frac{46}{7} \\]\nThey include all the integers.\n\nThen we get to the real numbers introduced in this module.\nWithin the real numbers there are interesting categories.\nSome real numbers are irrational and cannot be expressed as a ratio of integers.\n\nOne example is \\[ \\sqrt{2} \\], which bedeviled the Greeks a long time ago.\nInterestingly, one can prove that there are many more irrational real numbers than rational real numbers.\n\nAnother kind of real number is an algebraic number, meaning they are the solution to an equation like \\[ 3x^2 + 5 = 11 \\]\nThose that aren’t algebraic go by the lovely name of transcendental number, such as \\[ pi \\]\nSo, is every number a real number?        ⇒ No, there are numbers like \\[ \\sqrt-1 \\] that are imaginary.\nYou might think that an imaginary number couldn’t possibly have any use. It turns out that they are extraordinarily useful in many kinds of practical applications.\n\nExample: processing any kind of “wave” data, such as brain waves or seismic waves.\nExample: quantum computing.\n\n\nSome ideas to reflect on:\n\nWhich of the following most resonates with you?\n\n“I’ve always found math very hard and prefer to avoid it.”\n“I can tolerate math but would rather avoid it if possible.”\n“Math and I just don’t get along.”\n“Math is OK - I can do most of it but I don’t find it interesting or valuable.”\n“I can do math but am more interested in just applying it.”\n“I find math really interesting, even if I choose not to pursue math for math’s sake.”\n“I love math and will do as much of it as I can.”\n\nWhat ever your category, you should keep in mind:\n\nMath is a skill and takes practice, just like programming.\nYes, it’s true that a lot of high-school is boring. Much of what’s interesting in math comes after calculus.\nThe notion of not being suited to math is just a mindset. It can be changed.\nEven a little math is quite useful.\nYou can learn quite a bit of math via programming, as we’ll show you.\n\nWe’ll have more to say about the interesting and exciting connections between computer science, math, and other fields, including art."
  },
  {
    "objectID": "units/unit0/guides/anaconda-windows.html",
    "href": "units/unit0/guides/anaconda-windows.html",
    "title": "Anaconda and Spyder Installation Guide for Windows",
    "section": "",
    "text": "This guide will guide you through the installation process of Anaconda, a popular Python distribution, on your Windows computer. Anaconda facilitates the management of Python packages and environments, and it includes Spyder, a powerful IDE for scientific computing."
  },
  {
    "objectID": "units/unit0/guides/anaconda-windows.html#introduction",
    "href": "units/unit0/guides/anaconda-windows.html#introduction",
    "title": "Anaconda and Spyder Installation Guide for Windows",
    "section": "",
    "text": "This guide will guide you through the installation process of Anaconda, a popular Python distribution, on your Windows computer. Anaconda facilitates the management of Python packages and environments, and it includes Spyder, a powerful IDE for scientific computing."
  },
  {
    "objectID": "units/unit0/guides/anaconda-windows.html#prerequisites",
    "href": "units/unit0/guides/anaconda-windows.html#prerequisites",
    "title": "Anaconda and Spyder Installation Guide for Windows",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you begin, ensure you have the following:\n\nA Windows computer.\nAn active internet connection.\nAdequate disk space for the installation."
  },
  {
    "objectID": "units/unit0/guides/anaconda-windows.html#installation-steps",
    "href": "units/unit0/guides/anaconda-windows.html#installation-steps",
    "title": "Anaconda and Spyder Installation Guide for Windows",
    "section": "Installation Steps",
    "text": "Installation Steps\n\n1. Download Anaconda\nVisit the Anaconda download page at https://www.anaconda.com/download.\n\n\n2. Choose the Windows Installer\nClick on the “Download” button under the Windows section to download the Anaconda installer for Windows.\n\n\n\nDownload Anaconda\n\n\n\n\n3. Run the Installer\n\nLocate the downloaded file, typically in your “Downloads” folder.\nDouble-click the installer executable (.exe) file to run it.\n\n\n\n\nRun Installer\n\n\n\n\n4. Follow the Installer Wizard\n\nFollow the on-screen instructions to initiate the installation.\nRead and accept the license agreement when prompted.\n\n\n\n\nRead Me\n\n\n\n\n\nLicense Agreement\n\n\n\nChoose the installation type. It’s recommended to select “Just me” unless you have specific reasons for a different choice.\n\n\n\n\nInstallation Type\n\n\n\nSelect the installation location (the default is usually fine).\n\n\n\n\nInstallation Location\n\n\n\n\n5. Install Anaconda\nClick the “Install” button to begin the installation process. This may take a few minutes.\n\n\n\nInstall\n\n\n\n\n6. Complete the Installation\nOnce the installation is complete, you’ll see a confirmation message. Click “Next” and proceed to finish.\n\n\n\nInstallation Complete\n\n\n\n\n\nClose Installation Wizard\n\n\n\n\n7. If prompted to update the navigator, select “No, don’t show again”\n\n\n\nDon’t Update\n\n\n\n\n8. You’re NOT REQUIRED to Log in/Sign up for Anaconda Cloud; close the prompt by clicking the “X” button\n\n\n\nDon’t Log in/Sign up\n\n\n\n\n9. Access Spyder through Anaconda Navigator\n\nOpen Anaconda Navigator, now installed on your system.\nLocate Spyder and click “Launch” to open the Spyder IDE.\n\n\n\n\nLaunch Spyder\n\n\n\n\n\nSpyder"
  },
  {
    "objectID": "units/unit0/guides/anaconda-windows.html#conclusion",
    "href": "units/unit0/guides/anaconda-windows.html#conclusion",
    "title": "Anaconda and Spyder Installation Guide for Windows",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! Anaconda and Spyder are now successfully installed on your Windows computer. Utilize Spyder for scientific computing and Python development.\nFor further guidance on using Anaconda, refer to the official documentation at https://docs.anaconda.com/.\nIf you encounter any issues or have questions, seek assistance from the Anaconda community or consult the documentation for troubleshooting tips."
  },
  {
    "objectID": "units/unit0/guides/thonny-windows.html",
    "href": "units/unit0/guides/thonny-windows.html",
    "title": "Thonny Installation Guide for Windows",
    "section": "",
    "text": "This guide provides a step-by-step walkthrough for installing Thonny, a user-friendly Python IDE, on your Windows computer. Thonny simplifies Python programming and is suitable for learners and developers."
  },
  {
    "objectID": "units/unit0/guides/thonny-windows.html#introduction",
    "href": "units/unit0/guides/thonny-windows.html#introduction",
    "title": "Thonny Installation Guide for Windows",
    "section": "",
    "text": "This guide provides a step-by-step walkthrough for installing Thonny, a user-friendly Python IDE, on your Windows computer. Thonny simplifies Python programming and is suitable for learners and developers."
  },
  {
    "objectID": "units/unit0/guides/thonny-windows.html#prerequisites",
    "href": "units/unit0/guides/thonny-windows.html#prerequisites",
    "title": "Thonny Installation Guide for Windows",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you begin, ensure you have the following:\n\nA Windows computer.\nAn active internet connection.\nAdequate disk space for the installation."
  },
  {
    "objectID": "units/unit0/guides/thonny-windows.html#installation-steps",
    "href": "units/unit0/guides/thonny-windows.html#installation-steps",
    "title": "Thonny Installation Guide for Windows",
    "section": "Installation Steps",
    "text": "Installation Steps\n\n1. Visit Thonny’s Official Website\nGo to https://www.thonny.org/ to access Thonny’s official download page.\n\n\n\nVisit Official Website\n\n\n\n\n2. Select the Windows Download Option\nHover your mouse over the “Windows” option in the “Download version…” box and click to initiate the download.\n\n\n\nDownload Thonny\n\n\n\n\n3. Execute the Installer\nLocate the downloaded file, typically in your “Downloads” folder. Double-click the Thonny installer to run it.\n\n\n\nDownload Thonny\n\n\n\n\n4. Confirm Installation\nClick “Next” to proceed with the installation.\n\n\n\nConfirm Installation\n\n\n\n\n5. Agree to License Agreements\nAccept the license agreements by clicking “Agree.”\n\n\n\nLicense Agreement\n\n\n\n\n6. Choose Installation Location\nSelect a location for installation; the default option is acceptable.\n\n\n\nInstallation Location\n\n\n\n\n7. Select Start Menu Folder\nChoose a start menu folder; the default option is acceptable.\n\n\n\nStart Menu Folder\n\n\n\n\n8. Create Desktop Icon\nOpt to create a desktop icon for easy access. Click “Create Desktop Icon”.\n\n\n\nDesktop Icon\n\n\n\n\n9. Initiate Installation\nClick “Install” to start the installation process.\n\n\n\nInstall Thonny\n\n\n\n\n10. Completion\nOnce the installation is complete, click “Finish.”\n\n\n\nInstallation Complete\n\n\n\n\n11. Optional Cleanup\nConsider moving the installer file to the Recycle bin if desired.\n\n\n\nMove to Recycle bin\n\n\n\n\n12. Launch Thonny\nThonny is now installed on your computer. Open the Thonny editor by clicking on the desktop icon. \n\n\n13. Verification\nConfirm the successful installation by viewing the Thonny screen window.\n\n\n\nVerification"
  },
  {
    "objectID": "units/unit0/guides/thonny-windows.html#conclusion",
    "href": "units/unit0/guides/thonny-windows.html#conclusion",
    "title": "Thonny Installation Guide for Windows",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! Thonny is successfully installed on your Windows computer.\nBegin your coding journey with Thonny, and for additional guidance, consult the official documentation at https://docs.thonny.org/.\nIf you encounter any issues or have questions, feel free to seek assistance from the Thonny community or refer to the documentation for troubleshooting tips."
  },
  {
    "objectID": "units/unit0/editor.html",
    "href": "units/unit0/editor.html",
    "title": "Installing an Editor",
    "section": "",
    "text": "Getting Started with Your Coding Journey"
  },
  {
    "objectID": "units/unit0/editor.html#understanding-the-basics",
    "href": "units/unit0/editor.html#understanding-the-basics",
    "title": "Installing an Editor",
    "section": "Understanding the Basics",
    "text": "Understanding the Basics\nIn the realm of programming, your choice of an editor is pivotal. It serves as your creative hub, where your code takes shape. Here’s a brief overview of key features editors bring to the table:\n\nText Editing: Core to any editor is the ability to write, edit, and organize code. Look for features like syntax highlighting, auto-indentation, and code completion for an enhanced coding experience.\nCode Execution: Some editors go beyond editing by enabling interactive code execution, which is handy for data analysis and experimentation.\nExtensions and Plugins: Editors are highly customizable. Enhance functionality by installing extensions or plugins tailored to your needs, adding Python-specific tools or themes.\nIDEs (Integrated Development Environments): Editors offer a complete development environment, including debugging and version control integration.\n\nFor your CS1012 course, we recommend Thonny as the primary choice, with Spyder as a valuable alternative:\n\nThonny: Thonny is a beginner-friendly Python IDE, designed to make it easy to get started with programming. It comes with a simple interface and integrated tools for package management.\nSpyder: Spyder is a powerful IDE for scientific computing and data analysis. It provides features like an interactive console, variable explorer, and integrated help, making it a solid alternative to Thonny.\n\nLet’s dive into the installation process:\n\nSelect an Option Appropriate for Your Operating System\n\n\nMacOS:\n\nStep 1: Install Thonny for Mac\nStep 2: Install Spyder for Mac\n\n\n\nWindows:\n\nStep 1: Install Thonny for Windows\nStep 2: Install Spyder for Windows\n\nChoose Thonny as your primary choice for its simplicity, especially if you’re new to coding. However, if you prefer a more feature-rich environment, Spyder is an excellent alternative.\nFollow the respective installation instructions and embark on your coding journey with confidence!\nOnce you have your preferred editor installed, you’re ready to start coding. Happy exploring!"
  },
  {
    "objectID": "units/unit0/assignments/assignment2.html",
    "href": "units/unit0/assignments/assignment2.html",
    "title": "Assignment 1",
    "section": "",
    "text": "Home » Unit 0 » Assignment 1"
  },
  {
    "objectID": "units/unit0/assignments/assignment2.html#objectives",
    "href": "units/unit0/assignments/assignment2.html#objectives",
    "title": "Assignment 1",
    "section": "Objectives",
    "text": "Objectives\nAs usual, in each such assignment set, we will help develop your problem-solving skills by showing you how to solve one problem, the first and often hardest problem. However, the solution will include some exercises for you that you will need to submit."
  },
  {
    "objectID": "units/unit0/assignments/assignment2.html#assignment-problems",
    "href": "units/unit0/assignments/assignment2.html#assignment-problems",
    "title": "Assignment 1",
    "section": "Assignment problems",
    "text": "Assignment problems\n\n1. Demo problem.\nConsider this coding puzzle. Suppose we’re asked to print out lines in a pattern like this:\nz\nzy\nzyx\nzyxw\nzyxwv\nzyxwvu\nzyxwvut\nzyxwvuts\nzyxwvutsr\nzyxwvutsrq\nAnd suppose we want to use for-loops to achieve this. How do we go about solving this problem?\nAt this point, do not read further and try to address the following:\n\nFirst understand what is being asked.\nDo see a for-loop or two at work where, as the loops are printing, you’ll get the output shown above?\nCan the problem be broken down into parts, where you can solve the parts and put the solution together afterwards?\nTry writing some code to get at least some of the output.\nWhat are the issues related to strings?\n\nNow examine the solution\nDon’t forget to submit your solutions to the exercises within.\n\n\n2. Write a program called my_odd_sum.py to compute the sum of all odd numbers in a given range. Here’s part of the code:\nm = 10\nn = 20\n\n# Write code to add up the odd numbers between m and n inclusive\n\n# WRITE YOUR CODE HERE\n\n# When m=10, and n=20, you should get 75\nThen test out your code by changing m to m=100 and n to n=150. What do you get?\n\n\n3. Review the example in Module 5 where we made a random sentence. After pulling out random nouns, a verb etc, we built a sentence like so:\n    sentence = (\n        'The ' + adj + ' ' + noun + ' ' + verb + 's' +\n        ' ' + prep + ' a ' + noun2)\nIn my_avg_sentence_length.py, use a loop to build many such sentences and compute the average sentence length at the end. Print each sentence and at the end, print the average sentence length.\n\n\n\n\n\n\nTip\n\n\n\nUse the sentence construction as above, which will include spaces.\n\n\n\n\n4. In my_geometric_art.py, write code to use drawtool so that the result is:\n\nHere’s some code to get started with:\nfrom drawtool import DrawTool \n\ndt = DrawTool()\ndt.set_XY_range(0,100, 0,100)\ndt.set_aspect('equal')\n\n# This is how you set the drawing color:\ndt.set_color('b')\n# Other colors: r for red, g for green, m for magenta\n# k for black, w for white, y for yellow, c for cyan\n\nm = 0\nfor k in range(0, 41, 10):\n    dt.draw_rectangle(k, m, 5, 5)\n    m = m + 10\n\n# WRITE YOUR CODE BETWEEN HERE ...\n\n# ... AND HERE.\ndt.display()\nStart by downloading drawtool.py into your assignment folder. Then, write the above code in my_geometric_art.py to see that a part of the drawing has been made for you. You can draw a circle with center at (10,20) with radius 5 using the line:\ndt.draw_circle(10, 20, 5)\n(Try it).\n\n\n5. Art project.\nIn my_geometric_art2.py, use the ability to draw rectangles and circles, changing colors where needed, to make a far more impressive work of art. You are also welcome to use other functions in drawtool such as:\ndt.draw_filled_circle(10, 20, 5)\ndt.draw_filled_rectangle(40, 50, 5, 5)\nWith a limited color and geometric palette, we’re confident you can make something Mark Rothko or Piet Mondrian would be proud of.\n\n\n6. The following program intends to print the integer value of a letter (character) along with the corresponding letter, separately for uppercase first, and then lowercase. The output (edited for length) is something like:\n65-A\n66-B\n67-C\n...\n90-Z\n97-a\n98-b\n99-c\n...\n122-z\nHere’s the program with errors:\nfor i in range(65,91):\n    print(i+ \"-\" + chr(i)\n\nfor j in range(ord('a'),ord('z')):\n    x = char(j)\n    print(str(i)+ \"-\" + x)\nFind and fix the errors in fixed_errors1.py."
  },
  {
    "objectID": "units/unit0/assignments/assignment2.html#how-to-submit",
    "href": "units/unit0/assignments/assignment2.html#how-to-submit",
    "title": "Assignment 1",
    "section": "How to submit:",
    "text": "How to submit:\n\n\nMake a zip of the directory and submit that."
  },
  {
    "objectID": "units/unit0/assignments/assignment1.html",
    "href": "units/unit0/assignments/assignment1.html",
    "title": "Assignment 0",
    "section": "",
    "text": "Home » Unit 0 » Assignment 0"
  },
  {
    "objectID": "units/unit0/assignments/assignment1.html#objectives-and-example",
    "href": "units/unit0/assignments/assignment1.html#objectives-and-example",
    "title": "Assignment 0",
    "section": "Objectives and example",
    "text": "Objectives and example\nAssignments are designed to strengthen your problem-solving skills and build independence. While the module exercises are small variations of explained module examples, a single assignment will have multiple problems, all of which are intended to be more challenging than the module exercises, and will feature less detailed guidance. This is a good thing because ultimately, you’ll have to solve problems on your own. Facing and overcoming challenging problems cheerfully is the key to building problem-solving skill.\nIn each such assignment set, we will help develop your problem-solving skills by showing you how to solve one problem, the first and often hardest problem. However, the solution will include some exercises for you that you will need to submit."
  },
  {
    "objectID": "units/unit0/assignments/assignment1.html#assignment-problems",
    "href": "units/unit0/assignments/assignment1.html#assignment-problems",
    "title": "Assignment 0",
    "section": "Assignment problems",
    "text": "Assignment problems\n\n1. Demo problem\nSuppose we want to use for-loops to produce this arrow-head like pattern:\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\nAt this point, do not read further and try to address the following:\n\nFirst understand what is being asked.\nDo you see a for-loop or two at work where, as the loops are printing, you’ll get the output shown above?\nCan the problem be broken down into parts, where you can solve the parts and put the solution together afterwards?\nTry writing some code to get at least some of the output.\n\nNow examine the solution\nDon’t forget to submit your solutions to the exercises within.\n\n\n2. In my_nested.py use nested loops in print the following pattern:\n1  1\n2  1\n3  1\n4  1\n1  2\n2  2\n3  2\n4  2\n1  3\n2  3\n3  3\n4  3\n1  4\n2  4\n3  4\n4  4\n\n\n3. In my_nested2.py, write a program that uses nested for-loops to print the following pattern:\n* * * * * * * * * * 10\n  * * * * * * * * * 9\n    * * * * * * * * 8\n      * * * * * * * 7\n        * * * * * * 6\n          * * * * * 5\n            * * * * 4\n              * * * 3\n                * * 2\n                  * 1\nNotice the spaces between asterisks, the spaces leading up to the first asterisk in each line, and the number at the end.\n\n\n4. In this exercise you will use a drawing tool and a for-loop to draw a series of rectangles. The goal is to draw this:\n\nThe code for drawing a single rectangle is:\nfrom drawtool import DrawTool \n\ndt = DrawTool()\ndt.set_XY_range(0,100, 0,100)\n\ndt.draw_rectangle(10, 20, 5, 10)\n\ndt.display()\nThis produces (we’ve added some markup to explain):\n\nAs a first step, download drawtool.py into your assignment1 folder and type up the above single-rectangle example in my_rectangle_example.py. This way, you know that the download worked and that drawing works. Now you can focus on the many-rectangle problem. Think about how the for-loop needs to range so that you can draw the rectangles in the loop. Write your program in my_rectangle_pattern.py.\n\n\n5. The following program intends to print\nhello\nhow're\nyou?\nThis is the alleged program:\nprint('hello\")\nprint('how're')\nprint('you?)\nThere are several errors above. Point them out in your assignment pdf. Then fix them in fixed_hello.py.\n\n\n6. The following program intends to print the following five times as in:\nxyz\nxyz\nxyz\nxyz\nxyz\nThis is the alleged program:\nDef print_one_line():\nfor i in range(1,5):\n    print(xyz)\n\nprint_one_line\nThere are several errors above. Point them out in your assignment pdf. Then fix them in fixed_xyz.py.\n\n\n7. The following program intends to print the numbers 5 through 0 as in:\n5\n4\n3\n2\n1\n0\nThis is the alleged program:\ndef function#2()\n    for i in range(5,-1, 0):\n        print(i)\n\nfunction#2()\nThere are several errors above. Point them out in your assignment pdf. Then fix them in fixed_downprint.py."
  },
  {
    "objectID": "units/unit0/assignments/assignment1.html#how-to-submit",
    "href": "units/unit0/assignments/assignment1.html#how-to-submit",
    "title": "Assignment 0",
    "section": "How to submit:",
    "text": "How to submit:\n\n\nMake a zip of the directory and submit that."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html",
    "href": "units/unit1/modules/module1.0.html",
    "title": "Module 1.0: A first look at lists",
    "section": "",
    "text": "Home » Unit 1 » Module 1.0"
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#objectives",
    "href": "units/unit1/modules/module1.0.html#objectives",
    "title": "Module 1.0: A first look at lists",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nUnderstand how a list is different from a variable\nExplore the syntax around using lists in programs\nUse lists in programs to solve problems\nPractice mental execution (tracing) and debugging related to lists"
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#an-example-of-a-list",
    "href": "units/unit1/modules/module1.0.html#an-example-of-a-list",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.0 An example of a list",
    "text": "1.0.0 An example of a list\nConsider this program:\n# List example:\nA = [1, 4, 9, 16, 25]\n\nfor i in range(5):\n    print(A[i])\n\n# In contrast, a plain variable:\nk = 100\nprint(k)\n\n\n\n\n\n\n1.0.1 Exercise\n\n\n\nIn my_list1.py, type up the above and examine the output. Then, inside the above for-loop, but before the first print statement, add an additional line of code to also print the value of i so that each value of i is printed on a line by itself. Report your output in module1.pdf and submit this modified version of my_list1.py.\n\n\nRemember how we think of a variable as a box that stores values?\n\nThis is indeed how we think of the variable k above. \nIn contrast, a list variable is a single name given to a collection of boxes: \nThe above collection has a current size, in this case 5.\nThe values in a list are called elements of the list.\nThere is an implied order going from the first to the last element.\nIt turns out, we can access individual elements in the list using indices: \n\n\n\n\n\n\n\nNote\n\n\n\n\nList indices start at 0\nAnd end at one less than the size.\nThus, in the above example, the size of the list is 5.\nThe indices (positions in the list) are: 0, 1, 2, 3, 4.\nThe last valid position (or index), which is 4 here, is one less than the size, 5.\n\n\n\nConsider this program:\nA = [1, 4, 9, 16, 25]\n\n# Use len to get the current size:\nn = len(A)\nprint('Size of A: ' + str(n))\n\n# Add an element to the list:\nA.append(36)\nn = len(A)\nprint('Size of A: ' + str(n))\n\n# Change a particular element:\nA[3] = 100\nprint('The list: ' + str(A))\n\n\n\n\n\n\n1.0.2 Exercise\n\n\n\nTry out the above in my_list2.py.\n\n\nLet’s point out:\n\nObserve how we obtain the current size and add an element: \nNext, observe square brackets being used for different purposes: \nWe could use a variable to access elements, as long as that variable has an integer value that has a valid index, for example:\nk = 3\nA[k] = 100\nRemember len?\n\nWe had used len earlier for the length of strings, as in\ns = 'hello'\nprint(len(s))    # Prints 5\nHere, len works to give us the length of a list, as in:\nA = [1, 4, 9, 16, 25]\nprint(len(A))\n\nFor example:\nA = [1, 4, 9, 16, 25]\n\ni = 3         # i's value 3 is valid for a size 5 list\nprint(A[i])\n\ni = 7         # 7 is not valid\nprint(A[i])\nIn the above example, there is no element A[7] in a list that only has 5 elements.\n\n\n\n\n\n\n\n1.0.3 Exercise\n\n\n\nType up the above in my_list3.py. Describe the error in your module pdf.\n\n\n\n\n\n\n\n\n1.0.4 Exercise\n\n\n\nIn my_list4.py, make a list with the values 1,2,3,4,5,6,7,8,9,10. Then, set up a for-loop so that only the odd numbers are printed as in:\n1\n3\n5\n7\n9\n\n\n\n1.0.5 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#more-list-examples",
    "href": "units/unit1/modules/module1.0.html#more-list-examples",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.1 More list examples",
    "text": "1.0.1 More list examples\nJust as we can add elements to list, so can we remove elements, as in:\nA = [64, 9, 25, 81, 49]\nprint(A)\n\nA.remove(9)\nprint(A)\n\n\n\n\n\n\n1.0.6 Exercise\n\n\n\nConfirm the output by typing up the above in my_list5.py. Then, explore what would go wrong if you try and remove something that’s not in the list. For example, change the line A.remove(9) to A.remove(10). Report what you see in your module pdf. Submit your my_list5.py with the former (A.remove(9)).\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe elements in a list do not need to be in sorted order, as the above example shows. They can be in any order, but once in that order, they stay in that order unless we make a change to the elements in the list.\nAlthough our examples so far have lists of integers like 64, we will later build lists with real numbers and strings.\n\n\n\nConsider this example:\n# List constructed by typing the elements in:\nA = [1, 4, 9, 16, 25]\nprint(A)\n\n# List built using code to construct elements:\nB = []                 # An empty list\nfor i in range(5):\n    k = (i+1) * (i+1) \n    B.append(k)\nprint(B)\n\n\n\n\n\n\n1.0.7 Exercise\n\n\n\nType up the above in my_list6.py. Then, in your module pdf, trace through the changing values of i, k and the list B in each iteration of the for-loop.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIt is possible to create an empty list and give it a variable name as in:\nB = []                 # An empty list\nWe could then add elements by appending.\nOne can shorten the lines inside the loop:\nB = []                 # An empty list\nfor i in range(5):\n    B.append( (i+1) * (i+1) )\nHere, we’ve fed the arithmetic expression (i+1) * (i+1) directly into append, without using a separate variable k to first calculate and then append.\n\n\n\n\n\n\n\n\n\n1.0.8 Exercise\n\n\n\nIn my_odd_list.py fill in the necessary code below to create a list with the first N odd numbers:\nN = 10\nodd_numbers = []\n# WRITE YOUR CODE HERE\nprint(odd_numbers)\nIn this case, the output should be:\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n(These are the first 10 odd numbers).\n\n\nWe do not need to traverse in exactly the order of elements in the list:\n\nFor example:\nA = [15, 25, 35, 45, 55, 65, 75, 85, 95, 105]\n\nfor i in range(9, 0, -2):\n    print(A[i])\nHere, we’re starting at the last element, traversing the list from end to beginning in steps of 2.\n\n\n\n\n\n\n\n1.0.10 Exercise\n\n\n\nTrace through the above code showing the values of i and A[i] at each iteration. Confirm by typing your code in my_list7.py."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#a-strange-thing-with-lists",
    "href": "units/unit1/modules/module1.0.html#a-strange-thing-with-lists",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.2 A strange thing with lists",
    "text": "1.0.2 A strange thing with lists\nLet’s first look at copying between regular variables, as in:\nx = 5\n\ny = x     # Copy the value in x into y\n\nx = 6     # Change the value in x\n\nprint(y)  # Does it affect what's in y?\n\n\n\n\n\n\n1.0.11 Exercise\n\n\n\nConsider the example above. In your module pdf, draw two boxes, one for x and one for y. Show the contents of the two boxes and if they change, show how they change.\n\n\nNext, consider this:\nA = [1, 4, 9, 16, 25]\n\nB = A\n\nA[0] = 49    # Change some value in list A\n\nprint(B)     # Does it affect what's in list B?\n\n\n\n\n\n\n1.0.12 Exercise\n\n\n\nType up the above in my_list_copy.py to find out whether any values have changed in list B.\n\n\nLet’s explain:\n\nClearly something strange is going on with lists.\nOne way to think of it is to go back to our picture of a list: \nWe’ll now sketch out an analogy:\n\nThink of the list as a building with rooms (the boxes): \nThen, the list variable A is really something that holds the building address (the building number).\nThe rooms in the building are numbered from 0, 1, etc.\nThe first room is A[0], the second is A[1] etc.\n\nNow, consider an assignment like:\nB = A\nThen, in the building analogy, what we get is: \nThis is why, when we change the A list as in\nA[0] = 49    # Change some value in list A\nThen, we are achieving \n\n\n\n\n\n\n\nNote\n\n\n\nNowhere in our code is the building number (4701) explicitly written. Building numbers (they are technically called pointers) are handled by Python, and made invisible to us because we don’t need them.  (Yes, we can print the building number if we wish, but that’s an advanced topic.)\n\n\n\nWe obviously want to know: is it possible to create a complete copy of A in B? As in: \nBecause then, if we change A, it does not affect B: \nThis is what it looks like in code:\nA = [1, 4, 9, 16, 25]\n\nB = A.copy()\n\nA[0] = 49    # Change some value in list A\n\nprint(B)     # Does it affect what's in list B?\n\n\n\n\n\n\n\n1.0.13 Exercise\n\n\n\nType up the above in my_list_copy2.py to find out if any values have changed in list B.\n\n\nSo, which (B = A or B = A.copy()) do we use?\n\nGenerally, you should use B.copy() unless you intentionally want the same “building number”.\nIn the former case, you have to be careful."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#different-ways-of-iterating-through-a-list",
    "href": "units/unit1/modules/module1.0.html#different-ways-of-iterating-through-a-list",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.3 Different ways of iterating through a list",
    "text": "1.0.3 Different ways of iterating through a list\nConsider this example:\nA = [1, 3, 5, 7, 9]\n\ntotal = 0\nfor i in range(5):\n    total = total + A[i]\n\nprint(total)\n\n\n\n\n\n\n1.0.14 Exercise\n\n\n\nType up the above in my_total_example1.py. In your module pdf, trace through the values of i and total through each iteration of the loop.\n\n\nNow let’s look at two different ways of writing the same loop (we’ll only show the loop part):\n\nThe first one:\nfor i in range(len(A)):\n    total = total + A[i]\n\n\n\n\n\n\n\nNote\n\n\n\n\nInstead of figuring out the length of a list by looking at the list, we can ask Python to compute the length and use that directly:\nfor i in range(len(A)):\n    total = total + A[i]\nThis way, we don’t need to track the length ourselves (if elements get added or removed).\n\n\n\n\nThe second way is even better:\nfor k in A:\n    total = total + k\nHere:\n\nHere the iteration is directly over the contents of the list.\nThe variable k is not an index but takes on the actual values in the list.\nWith a list like\nA = [1, 3, 5, 7, 9]\n\ntotal = 0\nfor k in A:\n    total = total + k\nIn the first iteration k is 1, in the second k is 3, in the third k is 5, and so on.\nSo, naturally, these get added directly into the variable total.\n\nYou can think of the first approach (using an index i and A[i]) as index iteration.\nThe second (using the value directly), as content iteration.\nWhich one should one use?\n\nPrefer to use content-iteration, whenever you can.\nIn some cases, however, you’ll find index iteration is useful, especially when you need the position where something occurs in the list.\n\n\n\n\n\n\n\n\n1.0.15 Exercise\n\n\n\nIn my_content_iteration.py, use content-iteration to print the contents of the list A below:\nA = [2020, 2016, 2012, 2008, 2004, 2000]\n\n# Write your code here:\nThe output should be one number per line in the order that the numbers appear in the list."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#working-with-multiple-lists",
    "href": "units/unit1/modules/module1.0.html#working-with-multiple-lists",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.4 Working with multiple lists",
    "text": "1.0.4 Working with multiple lists\nSuppose we have two lists of the same length like this:\nA = [1, 4, 9, 16, 25]\nB = [1, 3, 5, 7, 11]\nLet’s examine different ways of performing addition on the elements.\nFirst, let’s add up the total of all 10 numbers:\nA = [1, 4, 9, 16, 25]\nB = [1, 3, 5, 7, 11]\n\ntotal = 0\nfor k in A:\n    total = total + k\n\nfor k in B:\n    total = total + k\n\nprint(total)\n\n\n\n\n\n\n1.0.17 Exercise\n\n\n\nFirst, in your module pdf, trace the values of k and total in each iteration of each loop. Type the above in my_twolist1.py to confirm.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nIn the above case, we added all the numbers contained in both lists, to get a single number.\nNotice how natural it is to use content-iteration.\nWhat if we want a third list whose elements are the additions of corresponding elements from each list?\n    1    4    9    16    25\n    1    3    5     7    11\n    -----------------------\n    2    7   14    23    36\nHere, the last row is a new (third) list.\n\n\n\nLet’s write code to perform element-by-element addition:\nA = [1, 4, 9, 16, 25]\nB = [1, 3, 5, 7, 11]\n\nC = []\nfor i in range(5):\n    element_total = A[i] + B[i]\n    C.append(element_total)\n\nprint(C)\n\n\n\n\n\n\n1.0.18 Exercise\n\n\n\nFirst, in your module pdf, trace the values of i and element_total in each iteration of the loop, and also show how the list C changes across the iterations. Type the above in my_twolist2.py to confirm. Print the list inside the loop, by adding a print statement right after the append occurs. (Submit your program with the added print statement.) Explain why, in this case index-iteration is a better choice than content iteration.\n\n\n\n1.0.19 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#moving-elements-around-in-a-list",
    "href": "units/unit1/modules/module1.0.html#moving-elements-around-in-a-list",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.5 Moving elements around in a list",
    "text": "1.0.5 Moving elements around in a list\nConsider a list like:\nA = [1, 4, 9, 16, 25]\nNext, suppose we want to swap the elements in the 2nd and 4th positions within the same list (not creating a new list).\nThat is, we want to write code so that:\nA = [1, 4, 9, 16, 25]\n\n# ... code to swap 2nd and 4th elements ...\n\nprint(A)\n\n# Should print [1, 16, 9, 4, 25]\nTo achieve that:\nA = [1, 4, 9, 16, 25]\n\ntemp = A[1]\nA[1] = A[3]\nA[3] = temp\n\nprint(A)\n\n\n\n\n\n\n1.0.20 Exercise\n\n\n\nIn your module pdf, trace through the execution above showing the values in temp and the list after each line executes. Then, do the same if the middle three lines were replaced by:\nA[1] = A[3]\nA[3] = A[1]\n\n\n\n\n\n\n\n\n1.0.21 Exercise\n\n\n\nUse the “temp” variable idea to perform a left-rotate of a list in my_left_rotate.py. Thus, given \nA = [1, 4, 9, 16, 25]\n# ... your code here...\n\nprint(A)\n# Should print [4, 9, 16, 25, 1]\nThus everything but the first element moves leftwards and the first element gets to the last place. Use a for-loop to move most (but not all) elements."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#lists-of-strings-characters-or-real-numbers",
    "href": "units/unit1/modules/module1.0.html#lists-of-strings-characters-or-real-numbers",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.6 Lists of strings, characters, or real numbers",
    "text": "1.0.6 Lists of strings, characters, or real numbers\nWe have thus far seen lists of integers. One can make a list of other kinds of elements.\nFor example:\n# A list of strings:\nA = ['cats', 'and', 'dogs']\ns = ''\nfor w in A:\n    s += w\nprint(s)\n\n# A way to extract the characters in a string into a list:\ns = 'abcdef'\nB = list(s)\nprint(B)\n\n# Some real numbers:\nC = [1.1, 2.22, 3.333, 4.4444]\ntotal = 0\nfor x in C:\n    total = total + x\nprint('Average =', total/4)\n\n\n\n\n\n\n1.0.23 Exercise\n\n\n\nType the above in my_other_lists.py, while noticing the subtle change in how the last print statement is written. Insert spaces in the first loop so that the first thing printed is cats and dogs."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#a-different-version-of-print",
    "href": "units/unit1/modules/module1.0.html#a-different-version-of-print",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.7 A different version of print",
    "text": "1.0.7 A different version of print\nConsider these two variations of using print:\nx = 2\ns = 'eat'\ny = 3.141\n\nprint('I love ' + str(x) + ' ' + s + ' ' + str(y))\n\nprint('I love', x, s, y)\n\n\n\n\n\n\n1.0.24 Exercise\n\n\n\nType the above in my_print_example.py.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe first version above uses string concatenation to send one big string to print:\nprint( 'I love ' + str(x) + ' ' + s + ' ' + str(y) )\nIn the second version above, strings and variables given to print are separated by commas.\nHere, print treats the four things as separate entities:\nprint('I love', x, s, y)\nIn this case, print automatically inserts a space between the different things (that are separated by commas).\nIn the second type, there is no need to convert numbers to strings."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#random-selection-of-elements-from-a-list",
    "href": "units/unit1/modules/module1.0.html#random-selection-of-elements-from-a-list",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.8 Random selection of elements from a list",
    "text": "1.0.8 Random selection of elements from a list\nIt is often useful to be able to pick random elements from a list.\nLet’s use this feature first for a single roll of a die, and then two dice:\n\nSince a single die has 6 faces with the numbers 1 through 6, we’ll use a list of the numbers 1 through 6:\ndie = [1, 2, 3, 4, 5, 6]\nOur goal is to choose one of these numbers randomly.\nPython provides a way to randomly pick (without removing) an element from a list:\ndie = [1, 2, 3, 4, 5, 6]\nroll = random.choice(die)\nLet’s put this together into a program (remembering to import the random package):\nimport random\n\ndie = [1, 2, 3, 4, 5, 6]\nroll = random.choice(die)\nprint(roll)\n\n\n\n\n\n\n\n1.0.25 Exercise\n\n\n\nType the above in my_die_roll.py. Run the program several times to see that you are getting random selections from the list.\n\n\nNext, let’s use this to make a (ridiculously) simple game:\n\nTwo players each roll a die N times. The numbers on the rolls are averaged. The player with the higher average wins.\nOK, not the most entertaining game, but one for which we can easily write a program (from the point of view of one player):\nimport random\n\ndie = [1, 2, 3, 4, 5, 6]\n\nnum_trials = 10\ntotal = 0\nfor i in range(num_trials):\n    roll = random.choice(die)\n    print(roll)\n    total += roll\n\nprint('Average score:', total/num_trials)\n\n\n\n\n\n\n\n1.0.26 Exercise\n\n\n\nType the above in my_die_roll2.py to observe the result. Report in your module pdf the average when you use a large number of trials (say, 1000).\n\n\n\n\n\n\n\n\n1.0.27 Exercise\n\n\n\nIn my_die_roll3.py, change the game to the following: in each trial, each player rolls the die twice and adds the two numbers. The final score is the average across all trials. What is the average when you use a large number of trials (say, 1000)? In your module pdf, devise a more interesting 2-player game one could play solely using dice. (You don’t have to write a program for this last part.)"
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#some-math-via-programming",
    "href": "units/unit1/modules/module1.0.html#some-math-via-programming",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.9 Some math via programming",
    "text": "1.0.9 Some math via programming\nLet’s start with an example and then use that to delve into a few concepts:\nfrom drawtool import DrawTool\n\ndt = DrawTool()\ndt.set_XY_range(0,10, 0,100)\n\n# The blue collection of points:\ndt.set_color('b')\nx_coords = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ny_coords = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\ndt.draw_curve_as_points(x_coords, y_coords)\n\n# The red collection of points:\ndt.set_color('r')\nx_coords = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ny_coords = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\ndt.draw_curve_as_points(x_coords, y_coords)\n\ndt.display()\n\n\n\n\n\n\n1.0.29 Exercise\n\n\n\nType up the above in my_plot_example.py to see what you get. You will also need to download drawtool.py into the same folder.\n\n\nNow let’s ask some basic questions:\n\nWhat, really, is a graph and what does it mean to plot on a graph?\nWhat are x,y values and what do they have to with plotting?\nWhat’s a function and what’s the connection between (f(x)) and points on a graph?\nAnd what does this have to do with programming?\n\nWe’ll address these questions below.\nLet’s recall where we started:\n\nIn the beginning, there were integers (whole numbers) like 1, 2, 3, and 42.\nAlong with them came real needs like addition, subtraction, multiplication and division.  (Ancient applications: navigation, telling time, accounting/trade).\nThe integers were not enough because you can perform 3 - 8 and get … what? So came the negative integers like -5.\nThen, because 5/2 is not an integer, more numbers were needed, and hence the real numbers.\nNext came algebra:\n\nInstead of saying “I can take 12 times 4 and get 48, and then divide by 6, to get twice your original number 4”, we can write: \\[ \\frac{12x}{6} = 2x \\]\nIt’s much more compact and precise.\n\nNext came functions:\n\nInstead of saying “OK, take your number and multiply it by itself”, it’s much more compact to say: (f(x) = x^2).\nWe can think of a function as taking some input (like (x)and “doing something to it” to get an output: \n\nAll of this resulted in significant advances in mathematics.\nThen came Descartes who took this to a whole new level with coordinates.\n\nThe idea of coordinates:\n\nSuppose you had a way of linking or associating pairs of numbers:\n\nFor example, suppose 1 is associated with 5\n2 is associated with 7\n3 with 9\n\nSuppose we wrote these as: (1,5), (2,7), (3,9) and so on.\nNext, draw two perpendicular lines (one horizontal, one vertical) on a page: \n\nAnd call them the x and y axes respectively.\n\nNow given associations (1,5), (2,7) and (3,9):\n\nTreat the first number as the distance from the vertical axis.\nTreat the second number as the distance from the horizontal axis.\nThis will put us in a unique spot.\nCall that a point.\n\nFor example: \nThat’s all there’s to it. It’s hard to believe that such a simple idea became transformational.\n\nThe connection between functions and coordinates:\n\nSuppose you have a function like: (f(x) = 2x + 3)\nOne way to make sense of a function is to compute lots of examples like:\n\\[ f({\\bf 1}) = 2*{\\bf 1} + 3 = 5 \\] \\[ f({\\bf 2}) = 2*{\\bf 2} + 3 = 7 \\] \\[ f({\\bf 3}) = 2*{\\bf 3} + 3 = 9 \\]\n\nAnd even \\[ f({\\bf 3.16}) = 2*{\\bf 3.16} + 3 = 9.32 \\]\n\nA pair of axes makes it possible to visualize a function directly, initially by plotting some example points:\n\nTake some x.\nCalculate f(x)\nThen treat x as the first coordinate (distance from y-axis).\nTreat f(x) as the second coordinate (distance from x-axis), and plot.\nFor example, when x=2, then we saw that f(2) = 7. So, plot (2, 7).\n\nIn general, we want to plot x, f(x) for lots of different possible x values.\nHere, f(x) is what we use for the y-coordinate, which is why we sometimes write y = f(x).\nWhen we plot x, f(x) for different x values, we typically pick those x values for our convenience.\nFor above, we showed how to calculate f(x) = 2x + 3 when x=1, when x=2, when x=3, and so on, perhaps up to when x=10,  (Here, the intended range is close to zero.)\nBut if we need to, we could just as easily calculate f(x) = 2x + 3 when x=0.1, when x=0.2, when x=0.3, and so on up to when x=1.0,  (Here, the intended range is close to zero, between 0 and 1.0)\n\nLet’s put these ideas to use:\n\nSuppose we have two functions f and g\n\nf(x) = 2x + 3\ng(x) = x^2\n\nOur goal: compare the two functions.\nOne advantage of programming is that we can write code to perform the action of functions.\nFor example:\nx = 0\nfor i in range(11):\n    f = 2*x + 3\n    print('x =', x, ' f(x) =', f)\n    x = x + 1\n\nx = 0\nfor i in range(11):\n    g = x*x\n    print('x =', x, ' g(x) =', g)\n    x = x + 1\n\n\n\n\n\n\n\n1.0.30 Exercise\n\n\n\nType up the above in my_function_example.py.\n\n\nIt is far more valuable to visualize, so let’s set about plotting both together:\n\nTo plot, we’ll need to construct the list of x and y coordinates:\n\nfrom drawtool import DrawTool\n\ndt = DrawTool()\ndt.set_XY_range(1,10, 0,100)\n\nx = 0\nx_coords = []\ny_coords = []\nfor i in range(11):\n    x_coords.append(x)\n    f = 2*x + 3\n    y_coords.append(f)\n    x = x + 1\n\ndt.draw_curve_as_lines(x_coords, y_coords)\n\ndt.set_color('r')\n\n# WRITE CODE HERE for the second function\n\ndt.draw_curve_as_lines(x_coords, y_coords)\n\ndt.display()\nLet’s point out: \n\n\n\n\n\n\n1.0.31 Exercise\n\n\n\nType up the above in my_function_plot.py and add code for the second function (g(x)=x2) to get a plot like: \n\n\n\n1.0.32 Video\n\nScale and axes:\n\nYou may have noticed that the x-axis above had tick marks going from 0 to 10, while the y-axis went from 0 to 100.\nThis is an example of a plot that’s NOT drawn to scale.\nLet’s draw one to scale to see what it looks like by changing one line, from\ndt.set_XY_range(1,10, 0,100)\nto\ndt.set_XY_range(0,100, 0,100)\n\n\n\n\n\n\n\n1.0.33 Exercise\n\n\n\nIn my_function_plot2.py change your code from the earlier exercise to make the scale the same along x and y axes.\n\n\nWhen to use different scales along the axes:\n\nUsing the same scale, we see the dramatic difference between linear growth (the function (f(x)=2x+3)) and quadratic growth (the function (g(x) = x^2)).\nBut at the same time, some features like the point of intersection of the two curves is hard to see.\nWe can use different scales when we want to emphasize different aspects.\n\n\n\n\n\n\n\n1.0.34 Exercise\n\n\n\nIn my_function_plot3.py, add a third function (h(x) = 2x). Plot and take a screenshot once with the x and y range both as [0, 1200], and once with the x-range as [0,12] and the y-range as [0,1200]. This should show you how puny quadratic growth is compared to exponential growth. Submit your my_function_plot3.py with the former case when both ranges are the same."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#mathematical-art",
    "href": "units/unit1/modules/module1.0.html#mathematical-art",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.10 Mathematical art",
    "text": "1.0.10 Mathematical art\nSince we’re on the topic of functions, we cannot resist developing an art project based on it.\nLet’s first plot a function from high-school: the sine function\nfrom drawtool import DrawTool\nimport math\n\ndt = DrawTool()\ndt.set_XY_range(0,6.28, -1,1)\n\nn = 100\nx_spacing = 6.28/n\n\nx = 0\nfor i in range(n):\n    f = math.sin(x)\n    dt.draw_point(x, f)\n    x = x + x_spacing\n\ndt.display()\nLet’s point out:\n\nFirst, some code features: \nNext, observe that we plotted points directly inside the loop instead of first building a list of coordinates.\nDoing so is an alternative way of plotting (“plot as you go”), and will let us change the point color.\n\nSo, for our art project:\n\nWe’ll draw a background with randomly strewn yellow dots.\nThen, along a sine-curve, we’ll draw small ellipses of different sizes.\n\n\n\n\n\n\n\n1.0.35 Exercise\n\n\n\nDownload functional_art.py and run to see. Then in my_functional_art.py, improve on the above by including your own functions and additional decoration by drawing."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#when-things-go-wrong",
    "href": "units/unit1/modules/module1.0.html#when-things-go-wrong",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.11 When things go wrong",
    "text": "1.0.11 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n1.0.36 Exercise\n\n\n\nA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in range(1, 10):\n    print(A[i])\nIdentify and fix the error in my_error1.py.\n\n\n\n\n\n\n\n\n1.0.37 Exercise\n\n\n\nThe following program intends to build the decreasing-order list [10, 9, 8, 7, 6, 5, 4, 3, 2, 1].\nA = []\nn = 10\nfor i in range(n):\n    n = n - 1\n    A.append(n)\n\nprint(A)\nIdentify and fix the error in my_error2.py.\n\n\n\n\n\n\n\n\n1.0.38 Exercise\n\n\n\nThe following program intends to add to N all the elements of the list A.\nN = 100\nA = [1, 4, 9, 16, 25]\n\nfor k in A:\n    N = N + A[k]\n\nprint(N)\nIdentify and ix the error in my_error3.py."
  },
  {
    "objectID": "units/unit1/modules/module1.0.html#meta",
    "href": "units/unit1/modules/module1.0.html#meta",
    "title": "Module 1.0: A first look at lists",
    "section": "1.0.12 Meta",
    "text": "1.0.12 Meta\nThis is the next installment in our series of stepping back from it all and reflecting, with the hope of helping you progress as a learner.\nThis time our topic is math and math anxiety.\nLet’s start by acknowledging a few things:\n\nStudents do in fact have bad experiences learning math.\n\nFor example, if you were unlucky to be ill during the critical period in 4th grade when fractions are covered, that could become a gap that precludes other concepts.\nOr if algebra did not go well, everything that follows in math can lead to cascading difficulties in learning.\n\nStudents learn math differently and their “window of opportunity” may not be aligned with where their school is.\n\nThus, for many students, a certain age is not optimal for academic intensity, or issues at home prevent full engagement.\n\nThere are hidden cultural dispositions that can get in the way.\n\nThe most pernicious by far is the notion that some people just aren’t cut out for it. Or you have to have the “math gene”.\n\nMuch of K-12 math is, admittedly, a bit dull.\n\nAt the same time, there’s good news:\n\nMath (and programming) is like any other skill: everyone can acquire it with sufficient practice, but not everyone can reach the level of “world expert”.\nThis is true of just about any mental skill: facility with language, playing a musical instrument,\nAnd, most importantly, anyone can acquire it at any age.\n\nCan you tell someone it’s too late to learn, say, French?\n\n\nIt all depends on shedding the “I’m not cut out for it” disposition and committing to practice.\nThere is world of elegance and beauty in math after crossing a threshold of skill level, just as with a musical instrument.\n\nLet’s say a bit more about practice:\n\nYou surely know a musical instrument cannot be learned merely by watching videos or reading about it.\nProficiency requires regular and intense practice.\nThe best part of practice is that, even though progress is not instantaneous, you can see results after a while.\nAnother advantage: the nature of practice is that many people give up. So, if you don’t, you are ahead of those that do.\n\nFinally, the connection between programming and math:\n\nIt is true that most people who program do not use math at all. Just ask a web developer.\nBut if you add a bit of math, you can do many interesting things in programming, as anyone who deals with data will tell you.\nSome aspects of computer science that have a strong mathematical underpinning are just … a lot of fun!\n\n Next Module: Module 1.1"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html",
    "href": "units/unit1/modules/module1.3.html",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "",
    "text": "Home » Unit 1 » Module 1.3"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#objectives",
    "href": "units/unit1/modules/module1.3.html#objectives",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nPractice working with Boolean expressions and variables.\nPractice examples with strings\nStart to use built-in functions\nDelve into the notion of type"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#boolean-variables-two-examples",
    "href": "units/unit1/modules/module1.3.html#boolean-variables-two-examples",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.0 Boolean variables: two examples",
    "text": "1.3.0 Boolean variables: two examples\nRecall:\n\nAn integer variable takes on values like 5 and -33:\nx = 5\ny = -33\nA floating-point variable stores real numbers like:\nx = 5.0014\ny = -33.3333334\nA string variable stores strings or chars, as in:\ns = 'hello'\nc = 'z'\nA boolean variable stores one of two values: True or False\n\nFor example:\na = True\nprint(a)\n\nb = False\nprint(b)\n\nc = not a\nprint(c)\n\nd = a or b\nprint(d)\n\ne = a and b\nprint(e)\n\n\n\n\n\n\n1.3.1 Exercise\n\n\n\nType up the above in my_boolean_example.py. Report the output in your module pdf.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe reserved words True and False are used in their usual sense.\nA boolean variable can store only one of these values:\na = True\nb = False\n\nTrue and False start with capitals.\nThese aren’t the same as the quote-delimited strings 'True' and 'False'\n\nJust as we could perform arithmetic on integer variables, so can we perform boolean operations on boolean variables.\nThe simplest one is not:\na = True\nc = not a\nExplanation:\n\nSince a has the value True then not a will have the value False\nThus, c will have the value False.\n\nLikewise\na = False\nc = not a\nprint(c)\nwill print True.\nNext, consider or:\nd = a or b\nHow or works:\n\na or b will be True when any one of them (a or b) is True.\nAnother way to state it: a or b will be False only when a and b are both False.\nThis table shows all the combinations:\n\n\n\n\na\n\n\nb\n\n\nd = a or b\n\n\n\n\nFalse\n\n\nFalse\n\n\nFalse\n\n\n\n\nFalse\n\n\nTrue\n\n\nTrue\n\n\n\n\nTrue\n\n\nTrue\n\n\nTrue\n\n\n\n\nTrue\n\n\nFalse\n\n\nTrue\n\n\n\n\n\nNext, consider and:\ne = a and b\nHow and works:\n\na and b will be True only when both are True.\nThis table shows all the combinations:\n\n\n\n\na\n\n\nb\n\n\nc = a and b\n\n\n\n\nFalse\n\n\nFalse\n\n\nFalse\n\n\n\n\nFalse\n\n\nTrue\n\n\nFalse\n\n\n\n\nTrue\n\n\nTrue\n\n\nTrue\n\n\n\n\nTrue\n\n\nFalse\n\n\nFalse\n\n\n\n\n\n\n\n\nLet’s look at another example:\na = True\nb = True\n\na = not a       \nx = a and b\ny = a or b\nprint(x, y)\n\n\n\n\n\n\n1.3.2 Exercise\n\n\n\nType up the above in my_boolean_example2.py. Report the output in your module pdf.\n\n\nLet’s explain:\n\nFirst, look at:\na = True\nb = True\n\nHere, there are two boolean variables, each of which is assigned a (boolean) value.\nThink of the variables as “boxes” in the usual way but as boxes that can hold only boolean values (True or False).\n\nNext, look at\na = not a\n\nHere, the value in a before this executes is True\nSo, not a is False.\nThis gets stored in a\nSo, after the statement executes a will have the value False.\n\nNext, look at\nx = a and b\n\nWe know that a has the value False in it, while b has the value True.\nThus, the and operator is applied to the values False and True.\nYou can picture this as: False and True.\nWhat is the result?\nSimilar to applying the “rules of multiplication” to two numbers, we apply the rules of and to False and True. \nThe result is: False.\nThus, the value False is assigned to the variable x.\n\nThe next statement is:\ny = a or b\nBecause a is now False and b is True, the result in y will be: \n\n\n1.3.3 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#combining-boolean-operators",
    "href": "units/unit1/modules/module1.3.html#combining-boolean-operators",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.1 Combining Boolean operators",
    "text": "1.3.1 Combining Boolean operators\nConsider\na = True\nb = False\nc = True\nu = (a and b) or (a or b)\nv = (not u) or (not (b and c))\nprint(u, v)\nLet’s draw an expression diagram to help us understand what happens with the first expression: \n\n\n\n\n\n\n1.3.4 Exercise\n\n\n\nDraw an expression diagram to work out the result for the second expression (the value of v) above. Then type up the above in my_boolean_example3.py to confirm.\n\n\n\n1.3.5 Video\n\nBoolean expressions can be constructed with numeric variables and their comparison operators:\nk = 5\nm = 3\nn = 8\na = True\nb = False\n\nfirst = (m &lt; k) and (n &gt; k)\nsecond = ( (k+m == n) or (k-m &lt; 10) )\nthird = first and (not second)\nfourth = first or a\nprint(first, second, third, fourth)\n\n\n\n\n\n\nNote\n\n\n\n\nSince m is 3, k is 5, the expression (m &lt; k) in\nfirst = (m &lt; k) and (n &gt; k)\nevaluates to True.\nSimilarly, the expression (n &gt; k) also evaluates to True since n = 8 in\nfirst = (m &lt; k) and (n &gt; k)\nThus, the resulting expression on the right side becomes\nfirst = True and True\nWhich evaluates to True from the rules (the table) for and.\n\n\n\n\n\n\n\n\n\n1.3.6 Exercise\n\n\n\nDraw an expression diagram to work out the result for the remaining three expressions above. Then type up the above program in my_boolean_example4.py to confirm."
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#using-a-boolean-variable",
    "href": "units/unit1/modules/module1.3.html#using-a-boolean-variable",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.2 Using a Boolean variable",
    "text": "1.3.2 Using a Boolean variable\nTo see how a Boolean variable is used in practice, we will work through a somewhat elaborate example that will teach us other useful things.\nLet’s start with this program:\ndef print_search_result(A, search_term):\n    if search_term in A:\n        print('Found ', search_term)\n\nB = [15, 3, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nHere, the goal is to create a function that takes a list, and a search value (or search term) and looks inside the list to see if it exists.\nDoes the program work?\n\n\n\n\n\n\n1.3.8 Exercise\n\n\n\nType up the above program in my_search_example.py to confirm.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe have exploited the in operator in Python to examine whether or an element exists in a list:\nif search_term in A:\nThis will return either True or False.\nAnd Python does the work of traversing the list and peeking inside to see if value (4 in this case) is in the list.\n\n\n\nNow consider the problem of also printing the position where it’s found:\ndef print_search_result(A, search_term):\n    for k in range(len(A)):\n        if A[k] == search_term:\n            print('Found', search_term, 'at position', k)\n\nB = [15, 3, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nDoes this work?\n\n\n\n\n\n\n1.3.9 Exercise\n\n\n\nType up the above program in my_search_example2.py to confirm.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe are now traversing the list ourselves:\nfor k in range(len(A)):\nHere, k will start at 0 and go up to the last index (one less than the length of the list).\nAt each iteration, we check to see if the search term is equal to the list element at the current position (determined by k):\nif A[k] == search_term:\nIf so, we’ve found it.\n\n\n\n\n\n\n\n\n\n1.3.10 Exercise\n\n\n\nUse the list\nB = [15, 4, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nand trace through the above program in your module pdf. Also trace through what happens when we instead have\nB = [15, 4, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 5)\n\n\nWhat we’d like to do is print something when a search term is not found in the list.\nConsider this program:\ndef print_search_result(A, search_term):\n    for k in range(len(A)):\n        if A[k] == search_term:\n            print('Found', search_term, 'at position', k)\n    print('Not found:', search_term)\n\nB = [15, 3, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nprint_search_result(B, 5)\n\n\n\n\n\n\n1.3.11 Exercise\n\n\n\nStart by thinking through the execution to see if this worked. Then, type it up in my_search_example3.py to see. Explain what went wrong in your module pdf.\n\n\nLet’s try another variation:\ndef print_search_result(A, search_term):\n    for k in range(len(A)):\n        if A[k] == search_term:\n            print('Found', search_term, 'at position', k)\n        else:\n            print('Not found:', search_term)\n\nB = [15, 3, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nprint_search_result(B, 5)\n\n\n\n\n\n\n1.3.12 Exercise\n\n\n\nStart by thinking through the execution to see if this worked. Then, type it up in my_search_example4.py to see. Explain what went wrong in your module pdf.\n\n\nWe’ll now see how a simple Boolean variable is commonly used in these types of problems:\ndef print_search_result(A, search_term):\n    found = False\n    pos = -1\n    for k in range(len(A)):\n        if A[k] == search_term:\n            found = True\n            pos = k\n\n    if found:\n        print('Found', search_term, 'at position', pos)\n    else:\n        print('Not found:', search_term)\n\nB = [15, 3, 23, 9, 14, 4, 6, 2]\nprint_search_result(B, 4)\nprint_search_result(B, 5)\n\n\n\n\n\n\n1.3.13 Exercise\n\n\n\nFirst, trace through the above in your module pdf. Then, type it up in my_search_example5.py and confirm."
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#returning-a-truefalse-value",
    "href": "units/unit1/modules/module1.3.html#returning-a-truefalse-value",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.3 Returning a True/False value",
    "text": "1.3.3 Returning a True/False value\nPossible the most commonly use of Booleans is to write a function that returns True or False.\nSuppose we want to determine whether or not (Hint: whether or not ⇒ true or false) a list has a negative number:\ndef has_negative(A):\n    for k in A:\n        if k &lt; 0:\n            return True\n    return False\n\nB = [2, 4, 8, -10]\nprint(has_negative(B))\nC = [1, 3, 5]\nprint(has_negative(C))\n\n\n\n\n\n\n1.3.15 Exercise\n\n\n\nFirst, trace through the above in your module pdf. Then, type it up in my_search_negative.py and confirm.\n\n\n\n\n\n\n\n\n1.3.16 Exercise\n\n\n\nIn my_search_negative2.py complete the function below to identify whether or not a list has exactly two negative numbers:\ndef has_two_negatives(A):\n    # Write your code here\n\nB = [2, 4, 8, -10]\nprint(has_two_negatives(B))  # Should print False\nC = [1, -3, -5]\nprint(has_two_negatives(C))  # Should print True\nD = [1, -3, -5, -7]\nprint(has_two_negatives(D))  # Should print False"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#new-topic-strings-and-slicing",
    "href": "units/unit1/modules/module1.3.html#new-topic-strings-and-slicing",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.4 New topic: strings and slicing",
    "text": "1.3.4 New topic: strings and slicing\nIt is common to want to pull out parts of strings.\nFor example, if the user in some application types ‘DC 20052’, we may want just the zip code:\ns = 'DC 20052'\nstate = s[0:2]\nzip = s[3:8]\nprint(state, zip)\nLet’s explain: \n\nThe slicing expression 0:2 refers to all the chars of the string from the first (the 0-th) up to just before the one at position 2 (which would mean 1).\nThus, 0:2 refers to characters at positions 0 through 1.\nSimilarly, 3:8 refers to all the chars from position 3 upto 7 (inclusive).\nRecall:\n\nFor any range of numbers like 3,4,5,6,7, exclusive would mean the numbers 4, 5, 6 (excluding 3, excluding 7).\nInclusive would include the ends: 3,4,5,6,7.\n\nSlicing ranges are specified so that the left end is inclusive and the right end is exclusive:\nThus, 3:8 means “including 3” and “excluding 8”.\n\n\n\n\n\n\n\n1.3.18 Exercise\n\n\n\nIn my_slicing.py write code to extract the actual phone number (202-994-4000) from\ns = 'phone: 202-994-4000'\n# Write your code here\n\n\nSlicing expressions work for lists too:\nA = ['may','the','force','be','with','you']\nprint(A[2:5])\n\n\n\n\n\n\n1.3.19 Exercise\n\n\n\nBefore typing it up in my_slicing2.py try and guess what the above will print.\n\n\nLet’s look at slicing when we don’t know the size:\n\nConsider the zipcode example where the 5-digit zip code may preceded by all kinds of text, as in:\n'DC 20052'\n'District of Columbia, 20052'\n'20052'\n'My zip code is 20052'\nSo, all we know is that the last 5 chars in the string need to be extracted.\nThen, we need to get the length of the string at the moment we have the string.\nLet’s put this in a function:\ndef extract_zip(s):\n    start = len(s) - 5\n    end = len(s)\n    return s[start:end]\n\nexample1 = 'DC 20052'\nexample2 = 'District of Columbia, 20052'\nexample3 = '20052'\nprint(extract_zip(example1))\nprint(extract_zip(example2))\nprint(extract_zip(example3))\nNote that\nend = len(s)\ngives us the index just past the last index.\nAnd\nstart = len(s) - 5\ngives the index 5 position before the end.\nSo, the slice becomes:\nreturn s[start:end]\n\n\n\n\n\n\n\n1.3.20 Exercise\n\n\n\nIn my_slicing3.py, write a function to extract the phone number in the same way, when the first part could be anything like “phone: 202-994-4000” or “my number is 202-994-4000”.\n\n\nLastly, note that slicing has more to it than two numbers. We’ll have more to say about this in Unit-2."
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#using-slicing-to-solve-a-problem",
    "href": "units/unit1/modules/module1.3.html#using-slicing-to-solve-a-problem",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.5 Using slicing to solve a problem",
    "text": "1.3.5 Using slicing to solve a problem\nSuppose we want to determine the longest prefix that two strings have in common, as in:\nprint(find_common_prefix('river', 'rivet'))\nThis should print ‘rive’ but\nprint(find_common_prefix('river', 'stream'))\nshould find no common prefix.\nWe will use the following ideas:\n\nLet an index variable start at 0 and increase in a loop.\nFor each value of the index, we’ll compare the corresponding char in each string.\nAs long as the chars are equal, we keep going (because these will be part of the common prefix).\nThe moment they are NOT equal, we will have gone past the end of the common prefix.\n\nLet’s try this:\ndef find_common_prefix(w1, w2):\n    for k in range(len(w1)):\n        if w1[k] != w2[k]:\n            break\n    return w1[0:k]\n\nprint(find_common_prefix('river', 'rivet'))\nLet’s point out:\n\nThe Python reserved word break is used to, well, break out of a loop:\nfor k in range(len(w1)):\n    if w1[k] != w2[k]:\n        break\nThus, the moment it executes, execution exits the loop to the statement that follows the loop.\nNotice how we use slicing once we’ve found the char that’s past the common prefix:\nreturn w1[0:k]  # All the chars from 0 to k-1 inclusive\n\n\n\n\n\n\n\n1.3.21 Exercise\n\n\n\nDoes it work? Trace the execution of the above in your module pdf before typing it up in my_prefix.py to see.\n\n\n\n\n\n\n\n\n1.3.22 Exercise\n\n\n\nNext, trace the executing when the strings are ‘riveting’ and ‘rivet’. What goes wrong? Fix the problem in my_prefix2.py.\n\n\n\n1.3.23 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#built-in-string-functions-in-python",
    "href": "units/unit1/modules/module1.3.html#built-in-string-functions-in-python",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.6 Built-in string functions in Python",
    "text": "1.3.6 Built-in string functions in Python\nPython comes with many useful functions for strings.\nHere’s a sample:\nA = ['to','infinity','and','beyond','and', 'even','further']\ns = 'infinity'\n\n# Convert to uppercase:\nprint(s.upper())       \n\n# Count occurrences of the char 'i' in s:\nprint(s.count('i'))    \n\n# Locate which index 'f' first occurs in s:\nprint(s.find('f'))     \n\n# Occurrences of 'and' in list A:\nprint(A.count('and'))  \n\n# Occurrences of 'i' in 2nd string in list A:\nprint(A[1].count('i')) \n\nif A[3].startswith('be'):\n    print('starts with be')\n\ndata = '42'\nprint(data.isnumeric())\n\n\n\n\n\n\n1.3.24 Exercise\n\n\n\nType up the above in my_string_functions.py and pore over the output to try and make sense of how the functions worked.\n\n\nLet’s explain:\n\nThere’s a key difference, for example, between the functions len() and upper():\ns = 'hello'\nk = len(s)\nt = s.upper()\n\nThe function len() is like the ones we’ve been writing ourselves.\nIn this case, the string s is given to it as a parameter:\n\nk = len(s)\n\nBut the function upper() is quite different:\n\nt = s.upper()\n\nThis is, in some sense, attached to the string variable s.\n\nThe use of the period right after the variable followed by a function is a somewhat advanced topic:  We’ll just use the feature.\nThe advanced topic is called: objects.  (Yes. An ordinary name, but quite an involved topic, it turns out.)\n\nLet’s emphasize one more feature with this snippet of code:\ns = 'hello'\nt = s.upper()\nprint(s)\nprint(t)\n\n\n\n\n\n\n1.3.25 Exercise\n\n\n\nType up the above in my_string_functions2.py and observe the output.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe string s itself did not change but its uppercase version was returned by the call\nt = s.upper()\nThis returns a new string that gets placed into t.\n\n\n\nContinuing with the earlier example:\n\nSimilar “dot” functions are available for lists too, as in:\nk = A.count('and')\n\nThis asks the list A to count how many times the string ‘and’ occurs in the list.\nThe number that is returned gets stored in k.\n\nNotice how we can call a “dot” like function in a string when the string itself is an element of a list:\nk = A[1].count('i')\n\nHere, A[1] is the second string in the list A.\nThis happens to be ‘infinity’.\nWe’re calling its count()function.\nAnd giving that function the letter ‘i’ to count.\nIt returns a number, which gets stored above in k.\n\n\nConsider the following partially completed code:\ndef get_zipcode(A):\n    # Insert your code here\n\nB = ['my','zip', 'is', '20052']\nz = get_zipcode(B)\nprint(z+1)\n\n\n\n\n\n\n1.3.26 Exercise\n\n\n\nIn my_string_functions3.py, complete the function above, assuming the fourth string in the list has the zipcode. Return a number not a string, so that the print statement outputs 20053."
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#the-concept-of-type",
    "href": "units/unit1/modules/module1.3.html#the-concept-of-type",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.7 The concept of type",
    "text": "1.3.7 The concept of type\nSo far, we’ve seen different kinds of variables:\n\nInteger variables like:\na = 100\nb = 435\nFloating-point variables for real numbers like:\nc = 3.14159\nd = 2.718\nString variables like:\ne = 'hello'    # String with multiple chars\nf = 'h'        # Single-char string\nBoolean variables like\ng = False\nh = True\nWe’ve also seen other kinds of features or “things” in Python such as:\n\nReserved words.\nExpressions, whether arithmetic, comparison, or Boolean.\nLists.\nFunctions that we write using def.\nBuilt-in functions like len(). and print().\nControl structures like for and if that direct the flow of execution.\nWays to use existing other code via import’s.\n\n\nThere happen to other kinds of “things” in Python:\n\nOne of these is another kind of variable called a complex variable, for advanced math.\nAnother kind of “thing” or feature is an object which is a kind of structure that can contain related variables and functions.\nSimilarly, there are “things” called generators and iterators (an advanced topic)\n\nWhat we want to do here is focus your attention on a concept called type:\n\nAt any given moment, a variable is said to have a type.\nWhat this means: what kind of value does it have at the moment? An integer? A string?\nConsider this:\nx = 42      # The type of x is integer\ny = 4.2     # The type of y is floating point\nz = 'whoa'  # The type of z is string\nb = False   # The type of b is Boolean\nOne can print the type of a variable as follows:\nx = 42    \ny = 4.2   \nz = 'whoa'\nv = False \nprint(type(x), type(y), type(z), type(v))\nThe type information is often itself represention in a special Python feature called a class (intuitively, as in this “class of item”).\n\n\n\n\n\n\n\n1.3.27 Exercise\n\n\n\nIn my_type.py, find out what gets printed.\n\n\nThus, we see that:\n\nA variable that holds 42 is rightfully an integer variable.\nA number like 4.2 is a floating-point number (what we’ve also called a real number), and so a variable that holds such a number is a floating-point variable.\nA string variable that holds ‘whoa’ is just that, a string variable.\nAnd a variable that holds True or False is called a Boolean variable.\n\nConverting from one type to another:\n\nIt is often useful to go from one type to another.\nWe’ve seen an example of going from single-char string to integer, and converting from int to string (and vice-versa).\nTo review, let’s look at a few more examples:\na = int(4.2)\nb = float(42)\nc = str(b)\nd = int('256')\ne = ord('z')\nf = chr(97)\nprint(a, b, c, d, e, f)\n\n\n\n\n\n\n\n1.3.28 Exercise\n\n\n\nType the above in my_type2.py, to see how it works.\n\n\nTypes and operators:\n\nBecause our keyboards are limited in the number of symbol keys, we need to use some symbols for multiple purposes.\nThe way we see this is when one operator, like +, has different meanings when used with different types:\na = 3\nb = 4\nc = a + b         # + for arithmetic\n\nd = 'hello'\ne = 'world'\nf = d + ' ' + e   # + for string concatenation\nRather than list all possible uses of all operator symbols, we will introduce additional uses beyond the common case wherever appropriate.\nGenerally, you should be intentional about using operators: you should know what the purpose is.\nFor example, consider:\na = 4\nb = a * 3\nprint(b)          # prints 12\n\nd = 'hello'\ne = d * 3         # * for string concatenation\nprint(e)          # Prints hellohellohello\n(The latter is not a frequently used operator with strings.)"
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#a-text-application",
    "href": "units/unit1/modules/module1.3.html#a-text-application",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.8 A text application",
    "text": "1.3.8 A text application\nSometimes we need to go beyond what Python has to offer.\nOne way to do this is to find a popular library and use that:\n\nWhat’s a library?\nA library is a collection of programs all related for a purpose.\nFor example, there’s a library called NLTK (go look it up) that’s aimed at processing English text:\n\nIt can figure out parts of speech from sentences.\nIt can pick out topics (somewhat approximately) in paragraphs.\nIt can group so-called stem-related words like “fry”, “fries”, “frying” and separate those from “friar”.\n\nHowever, installing and learning to use these sophisticated packages requires some work.\nWhat we will do instead in this course is to provide you with simple programs that you can download and use directly without any installation.\nThis is the purpose in providing programs like wordtool and drawtool.\n\nLet’s use wordtool to find the longest sentence in a book:\n\nWordtool has a feature to break down text and give you one sentence at a time.\nFor example:\nimport wordtool as wt\n\nsentences = wt.get_sentences_from_textfile('jabberwocky.txt')\n\ncount = 0\n\nfor s in sentences:\n    count += 1\n    print('Sentence #', count, ':\\n', s, '\\n', sep='')\n\n\n\n\n\n\n\n1.3.29 Exercise\n\n\n\nType the above in my_sentence_app.py, to see how it works. You will need to download wordtool.py, wordsWithPOS.txt, and the sample text file jabberwocky.txt all into your module folder. You are likely to be familiar with the author’s other famous works.\n\n\nLet’s point out:\n\nWhen using functions in another program, one has to import that program:\nimport wordtool as wt\nIt is convenient to use a shorthand for an imported program:\nimport wordtool as wt\n(We could have called it something other than wt).\nFor example:\nsentences = wt.get_sentences_from_textfile('jabberwocky.txt')\nWordtool asks you to name the file, expecting it to be a plain text file (not a Word file), and to initiate the process with:\nsentences = wt.get_sentences_from_textfile('jabberwocky.txt')\n\n\n\n\n\n\n\n1.3.30 Exercise\n\n\n\nWhat is the purpose of and what does sep=’’ do? You can look this up and try removing those in my_sentence_app2.py.\n\n\nLet’s now do something interesting with wordtool: find the longest sentence (by length) in two texts to compare who wrote really long sentences.\nimport wordtool as wt\n\ndef get_longest_sentence(filename):\n    sentences = wt.get_sentences_from_textfile(filename)\n    maxL = 0\n    \n    for s in sentences:\n        if len(s) &gt; maxL:\n            maxL = len(s)\n            maxS = s\n\n    return maxS\n\n\nbook = 'federalist_papers.txt'\ns = get_longest_sentence(book)\nprint('Longest sentence in', book, 'with', len(s), 'chars:\\n', s)\n\nprint()\n\nbook = 'darwin.txt'\ns = get_longest_sentence(book)\nprint('Longest sentence in', book, 'with', len(s), 'chars:\\n', s)\n\n\n\n\n\n\n1.3.31 Exercise\n\n\n\nType the above in my_sentence_app3.py. Then download darwin.txt (Darwin’s On the Origin of Species) and federalist_papers.txt (the Federalist Papers by Hamilton and others). Which one has the longest? Who wrote the longest sentence in the Federalist Papers? Go to Project Gutenberg and find a text with a longer sentence. Report all of this in your module pdf."
  },
  {
    "objectID": "units/unit1/modules/module1.3.html#when-things-go-wrong",
    "href": "units/unit1/modules/module1.3.html#when-things-go-wrong",
    "title": "Module 1.3: Booleans, strings, built-in functions, types",
    "section": "1.3.9 When things go wrong",
    "text": "1.3.9 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n1.3.33 Exercise\n\n\n\ndef is_odd(k):\n    if k % 2 == 1:\n        return true\n    else:\n        return false\nIdentify and fix the error in my_error1.py.\n\n\n\n\n\n\n\n\n1.3.34 Exercise\n\n\n\nx = 4\nif x &gt;= 0 and &lt;= 5:\n    print('x is between 0 and 5 inclusive')\nIdentify and fix the error in my_error2.py."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html",
    "href": "units/unit1/modules/module1.5.html",
    "title": "Module 1.5: Review",
    "section": "",
    "text": "Home » Unit 1 » Module 1.2"
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#objectives",
    "href": "units/unit1/modules/module1.5.html#objectives",
    "title": "Module 1.5: Review",
    "section": "Objectives",
    "text": "Objectives\nThe main goal of this module is to step back and review core concepts in programming: loops, conditionals, lists, functions"
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#variables",
    "href": "units/unit1/modules/module1.5.html#variables",
    "title": "Module 1.5: Review",
    "section": "1.5.0 Variables",
    "text": "1.5.0 Variables\nConsider:\na = 3                \nx = 3.14\ns = 'hello'\nthis_is_fun = False\nodds = [1, 3, 5, 7]\n\nx = 2.718\nodds[2] = 9\nVariables have four aspects to them:\n\nA name, like x or this_is_fun above.      ⇒ Variable names don’t change during execution, they are given by the programmer\nA current value.      ⇒ At any moment during execution, a variable has a value.  This value can change (often does) during execution.\nA scope. More about this in Unit-2.\nA type, such as integer, float, string, Boolean, list (and there are a few more, an advanced topic).\n\nLet’s examine what happens when each line in the above program executes:\n\nWhen the first line executes: \nAfter the second line executes: \nAfter the third line: \nAfter the fourth: \nAfter the fifth: \nThen, one of the variables does have its value replaced: \nFinally, one of the elements in the list gets replaced: \nNow, there is a somewhat highly technical point to be made:\n\nThe “box” is what we’re using to conceptualize what a variable is, and how it behaves when we change it.\nGenerally, this is how you should think of it.\nHowever, some books will present certain kinds of variables differently, with more detail.\nUnderneath the hood, in fact, string and list variables are a bit different.\n\nSo, for the sake of completeness, we’ll just point out this more detailed version:  Here:\n\nString and list variables are themselves small boxes.\nThese variables contain a reference (conceptualized by the black arrow above) to the actual data.\nThe actual data for a string (the letters in it) are stored side by side, which is why we can “get at” letters via code like s[2] (3rd char in string).\nThis more detailed version will make sense when you eventually get to see objects (a feature of Python) in the future."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#how-to-read-and-mentally-execute-programs",
    "href": "units/unit1/modules/module1.5.html#how-to-read-and-mentally-execute-programs",
    "title": "Module 1.5: Review",
    "section": "1.5.1 How to read and mentally execute programs",
    "text": "1.5.1 How to read and mentally execute programs\nLet’s start with a simple example:\nx = 2\ny = 3\nx = x + y\n\nfor i in range(6):\n    x = x + i\n\nprint('x =', x)\nLet’s look at this in steps:\n\nFirst, start by noticing the chunks of code: \nNext, walk through the execution of the first chunk, and notice that the value of x is what’s used later: \n\n\n\n\n\n\n\nNote\n\n\n\n\nIf it helps to picture the boxes for x and y, then do so.\nLook at the statement\nx = x + y\nand say to yourself: “First, let’s look at the right side, and the values of x and y now”.\nGo backwards in the code to see the values of x and y.\nThen perform the operation to get the new value of x (5 in this case) that replaces what was there (which was 2).\n\n\n\n\nNext, notice key aspects of the loop without yet executing iteration by iteration: \nThen you get down to the iterative level and execute iteration by iteration:\n\n                           i      x\n  Before loop starts:             5\n  After first iteration    0      5\n  After i is 1             1      6\n  After i is 2             2      8\n  After i is 3             3      11\n  After i is 4             4      15\n  After i is 5             5      20\n\nFinally, there’s the print: \n\n\n\n\n\n\n\n1.5.1 Exercise\n\n\n\nExamine and mentally execute the following:\ni = 1\nj = 4\nA = [2, 4, 6, 8, 10, 12]\n\ntotal = 0\nfor k in range(i, j+1):\n    total = total + A[k]\n\nprint('total =', total)\nThen confirm by writing in my_execution_practice.py.\n\n\nNext, let’s look at reading a complex conditional:\nx = 7\ny = 6\nz = 5\nc = 'b'\n\nif x &lt; 5:\n    x = x + 10\nelif x &gt; y:\n    if (x &gt; 0) and (x+y &gt; z):\n        if c == 'a':\n            print('yes, a')\n        else:\n            if c == 'b':\n                print('no, b')\n    else:\n        print('boo')\nelse:\n    print('ok, that is enough')\nWe’ll do this in steps, working from the “outside going in”:\n\nWe’ll start by noticing some variables and values being assigned, followed by a large nested conditional: \n\n\n\n\n\n\n\nNote\n\n\n\n\nThe conditional has both an elif and an else-part.\nThe conditions depend on the variables above.\n\n\n\n\nNext, we identify which part of the outer conditional executes: \nThen, working inwards, we examine and see that the elif’s code block is itself a big conditional: \nThe combined Boolean expression\nif (x &gt; 0) and (x+y &gt; z):\ndoes turn out to be true, and so we enter the if-block: \nThe if-condition fails:\nif c == 'a':\nand so execution proceeds into the else-block: \n\n\n\n\n\n\n\nNote\n\n\n\nThere’s no else-part (which is allowed).\n\n\n\nClearly, in this case, the condition succeeds and we get to the print: \nObserve that if the condition was\nif c == 'z':\nthen we would jump right out of the whole: \n\n\n\n\n\n\n\nTip\n\n\n\nThis example illustrates how critical it is to make sure the indentation is correct.\n\n\n\nFor example, consider these three variations:\n\nIndent-case #1:\n\nif c == 'a':\n    print('yes, a')\nelse:\n    if c == 'b':\n        print('no, b')\n        print('hello')\n\nIndent case #2:\n\nif c == 'a':\n    print('yes, a')\nelse:\n    if c == 'b':\n        print('no, b')\n    print('hello')\n\nIndent case #3:\n\n    if c == 'a':\n        print('yes, a')\n    else:\n        if c == 'b':\n            print('no, b')\n    print('hello')\nCan you see why they're all different?\n\n\n\n\n\n\n\n1.5.2 Exercise\n\n\n\nType up the above in my_execution_practice2.py. Then, try different assignments to c. That is, try c = ‘a’, then c = ‘b’. Show and then explain in your module pdf why the above are different. (Submit your program with c = ‘a’).\n\n\nConsider this variation (we’ve added a few print’s):\nx = 7\ny = 6\nz = 5\nc = 'b'\n\nif x &lt; 5:\n    x = x + 10\nelif x &gt; y:\n    print('one')\n    if (x &gt; 0) and (x+y &gt; z):\n        print('two')\n        if c == 'a':\n            print('yes, a')\n        else:\n            if c == 'b':\n                print('no, b')\n            print('three')\n        print('four')\n    else:\n        print('boo')\n    print('five')\nelse:\n    print('ok, that is enough')\n    print('six')\n\nprint('seven')\n\n\n\n\n\n\n1.5.3 Exercise\n\n\n\nWhich of the above added print’s execute? See if you can identify them just by reading. Then confirm in my_execution_practice3.py.\n\n\n\n\n\n\n\n\n1.5.4 Exercise\n\n\n\nExamine and mentally execute the following:\nA = [-1, 2, 3, -5, 6, 7]\n\ntotal = 0\nfor i in range(len(A)):\n    if A[i] &gt; 0:\n        if A[i] % 2 == 0:\n            total = total + A[i]\n        else:\n            print('rejected:', A[i])\n    else:\n        print('illegal:', A[i])\n\nprint(total)\nThen confirm by writing in my_execution_practice4.py.\n\n\n\n\n\n\n\n\n1.5.6 Exercise\n\n\n\nConsider the following program:\ndef printword(n):\n    if n == 1:\n        print('one')\n    elif n == 2:\n        print('two')\n    elif n == 3:\n        print('three')\n    elif n == 4:\n        print('four')\n    else:\n        print('cannot handle n &gt; 4')\n\nprintword(1)\nprintword(2)\nprintword(3)\nprintword(4)\nprintword(5)\nIn my_conditional.py. rewrite the function so that it does the same thing but without using any elif’s.\n\n\n\n1.5.2 Functions without parameters\nConsider this example:\ndef print_two_xs():\n    print('xx')\n\nprint('start')\nprint_two_xs()\nprint_two_xs()\nprint('end')\nLet’s look at the execution step by step:\n\nFirst, Python reads through and stores the function definition: \nThen execution starts with the first print, followed by the first function call (or function invocation, if you like big words).\nAt this point, execution enters the function:\n\nAfter the function executes, execution proceeds to just after the function call: \nIn this particular case, the very next line is a call to the same function: \nAfter which: \n\nConsider this program:\ndef print_two_xs():\n    print('xx')\n\ndef print_three_ys():\n    print('yyy')\n\ndef print_more():\n    print_two_xs()\n    print_three_ys()\n    print('z')\n\nprint('start')\nfor i in range(8):\n    if i % 3 == 0:\n        print_two_xs()\n    elif i % 3 == 1:\n        print_three_ys()\n    else:\n        print_two_xs()\n        print_three_ys()\n    print_more()\nprint('end')\n\n\n\n\n\n\n1.5.8 Exercise\n\n\n\nExamine and mentally execute the above program. Then confirm by writing it up in my_execution_practice5.py."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#functions-with-parameters",
    "href": "units/unit1/modules/module1.5.html#functions-with-parameters",
    "title": "Module 1.5: Review",
    "section": "1.5.3 Functions with parameters",
    "text": "1.5.3 Functions with parameters\nHere’s an example:\ndef print_stuff(n):\n    print('n =', n)\n    n = 2*n\n    print('twice n =', n)\n    n = n // 4\n    print('half n =', n)\n\nm = 4\nprint(m)\nprint_stuff(m)\nprint(m)\nLet’s point out:\n\nThe parameter variable n gets its value from the argument variable: \nRecall: // is the integer-division operator.\nLater in the function, the parameter variable gets its value changed: \nIt’s important to realize that we could have named the argument variable n as well: \n\nAny code inside the function that uses or modifies n affects only the parameter variable n (the n inside the function and not the n outside the function).\nLet’s emphasize one more thing by looking at:\ndef print_stuff(n):\n    print('n =', n)\n    n = 2*n\n    print('twice n =', n)\n    n = n // 4\n    print('half n =', n)\n    print('m =', m)   # Trying to access m\n\nm = 4\nprint(m)\nprint_stuff(m)\nprint(m)\nprint('n =', n)       # Trying to access n\n\n\n\n\n\n\n1.5.10 Exercise\n\n\n\nType up the above in my_variable_access.py. Also, in your module pdf, explain why half of the original n is calculated as n // 4.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou will notice that m is accessible in the function whereas the parameter variable n is not accessible outside.\nThis is a topic (called scope) that we’ll address in Unit-2."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#functions-that-return-values",
    "href": "units/unit1/modules/module1.5.html#functions-that-return-values",
    "title": "Module 1.5: Review",
    "section": "1.5.4 Functions that return values",
    "text": "1.5.4 Functions that return values\nLet’s look at an example:\ndef incr(n):\n    m = n + 1\n    return m\n\ni = 5\nj = incr(i)\nk = incr( incr( incr(j) ) )\nprint(k)\nConsider the moment the first call to the incr() function occurs:\nj = incr(i)\n\nHere, the value in argument variable i is copied into parameter variable n: \nThen, the value m becomes 6, which is returned when the return statement executes: \nMoments later (in a tiny fraction of a second), you can think of the function call itself as replaced by the return value: \nAfter the return occurs, remember that the parameter and other function-defined variables disappear.  (Fresh versions will be created whenever another function call occurs.)\nNow let’s examine\nk = incr( incr( incr(j) ) )\nAt this moment j has the value 6.\nThe innermost call happens first:\nk = incr( incr( incr(j) ) )\nwhich goes to incr(), which returns 7, which results in\nk = incr( incr( 7 ) )\nThen, for the next call to incr(), the value 7 is copied into the parameter variable, resulting in:\nk = incr( incr( 7 ) )\nwhich goes to incr(), which returns 8, which results in\nk = incr( 8 )\nAnd finally,\nk = incr( 8 )\nresults in\nk = 9\nLastly, remember that a return statement can have expressions. Which means we can shorten incr() to:\ndef incr(n):\n    return n+1\nWe could also place another function call in the return statement itself:\ndef incr(n):\n    return n+1\n\ndef double_incr(n):\n    return incr(incr(n))\nThis is a shorter way of writing\ndef incr(n):\n    return n+1\n\ndef double_incr(n):\n    k = incr(incr(n))\n    return k\n\nNow consider a function with multiple returns:\ndef strange(n):\n    print('start-of-strange')\n    if n &lt; 0:\n        return 0\n    elif n == 0:\n        return 1\n    else:\n        s = 1\n        for k in range(n+1):\n            s = s + k\n        return s\n    print('end-of-strange')\n\nprint(strange(-3))\nprint(strange(0))\nprint(strange(3))\nIn the first call to the function strange(), the parameter n will have the value -3.\n\nIn this case, we see ‘start-of-strange’ printed.\nThe if-condition is true, which means the first return executes:\ndef strange(n):\n    print('start-of-strange')\n    if n &lt; 0:\n        return 0  \n    &lt;font color=\"#888888\"&gt;elif n == 0:\n        return 1\n    else:\n        s = 1\n        for k in range(n+1):\n            s = s + k\n        return s\n    print('end-of-strange')\nExecution leaves the function immediately, which means nothing else in the function executes.\n\n\n\n\n\n\n\n1.5.11 Exercise\n\n\n\nFor each of the three calls to the function strange(), can you tell whether ‘end-of-strange’ gets printed? Then confirm by typing it up in my_strange_example.py."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#lists-are-different",
    "href": "units/unit1/modules/module1.5.html#lists-are-different",
    "title": "Module 1.5: Review",
    "section": "1.5.5 Lists are different",
    "text": "1.5.5 Lists are different\nConsider\ndef add_one(n):\n    n = n + 1\n    print('incr: n=', n)\n\ndef list_add_one(A):\n    for k in range(0, len(A)):\n        A[k] = A[k] + 1\n    print('list_incr: A=', A)\n\np = 3\nadd_one(p)\nprint(p)\n\nB = [1, 2, 3]\nlist_add_one(B)\nprint(B)\n\n\n\n\n\n\n1.5.12 Exercise\n\n\n\nType up the above in my_list_example.py.\n\n\nObserve:\n\nThe add_one() function has no effect on the variable p, since the value in p gets copied into n.\nThe parameter variable n does get 1 added (as the print in add_one()) confirms.\nOne the other hand, print(B) shows that the elements of B have 1 added to each of them.\nWhy is this? Why are lists different as parameters?\n\nList variables are actually references, sometimes called pointers.\nThink of a reference or pointer as a special token that provides access to the list elements.\nWhoever has the token can access the list elements.\nWhen the variable B’s contents are copied into parameter variable A, then the variable A has the special token.\nWhich means variable A access the list elements and can change those.\n\nWhy was the Python language designed this way?\n\nIt turns out that copying over big lists into parameter variables can greatly slow down execution.\nThus, lists (and other such complex objects) don’t have their elements copied.\nInstead, it’s only the reference (which is really a single number, under the hood) gets copied.\n\n\nFor practice, let’s look at a list example with Boolean values (True, False):\ndef list_or(A):\n    x = True\n    for k in range(0, len(A)):\n        x = x or (not A[k])\n    return x\n\nB = [True, True, False, False]\nprint(list_or(B))\n\n\n\n\n\n\n1.5.13 Exercise\n\n\n\nTrace through each iteration of the loop in the function list_or(), showing x, k, and each A[k]. Then confirm in my_list_example2.py.\n\n\nAnd another example for practice:\ndef within1(x, y):\n    # Write your code here to return True or False\n    # Return True if the difference between x and y is 1 or less\n\ndef first_diff(A, B):\n    k = 0\n    while (k &lt; len(A)) and (within1(A[k], B[k])):\n        k = k + 1\n    if k == len(A):\n        return -1\n    else:\n        return k\n\nX = [1, 2, 3, 4]\nY = [2, 2, 3, 3]\nZ = [1, 1, 1, 4]\nprint(first_diff(X,Y))    # Should print -1\nprint(first_diff(X,Z))    # Should print 2\n\n\n\n\n\n\n1.5.14 Exercise\n\n\n\nThe function first_diff() is intended to take two lists, compare elements in the same positions, and identify the first position where the two lists differ by more than 1. Ifno such difference exists, the function should return -1. In my_list_example3.py, complete the code in the within1() function so that it returns True only when the difference between x and y is 1 or less. Thus, True when x=1, y=2, or when x=4, y=3, or when x=5, y=5. After that trace through the iteration in the while-loop."
  },
  {
    "objectID": "units/unit1/modules/module1.5.html#why-are-functions-useful",
    "href": "units/unit1/modules/module1.5.html#why-are-functions-useful",
    "title": "Module 1.5: Review",
    "section": "1.5.6 Why are functions useful?",
    "text": "1.5.6 Why are functions useful?\nFunctions are very useful for four different reasons:\n\nCode written in a function can be re-used.\nFor example, compare\nX = [1, 3, 5, 7]\ntotal = 0\nfor k in X:\n    total += k\navg = total / len(X)\nprint(avg)\n\nY = [2, 4, 6, 8, 10]\ntotal = 0\nfor k in Y:\n    total += k\navg = total / len(Y)\nprint(avg)\nwith\ndef mean(A):\n    total = 0\n    for k in A:\n        total += k\n    return total / len(A)\n\nX = [1, 3, 5, 7]\nprint(mean(X))\nY = [2, 4, 6, 8, 10]\nprint(mean(Y))\nThe second big reason is composability, as this example shows:\nz = incr( diff(x, y) )\n(You can imagine what the functions incr() and diff() do.)\nAnother example showing compactness with functions:\ns = '  hello  '\nprint(len(s.strip()))\nA long program broken up into functions will make the program more readable and therefore more easily understood.\nThe biggest reason, perhaps, is that it has become one of two important ways by which multiple programmers use each others’ code.\nExample: you have used functions in drawtool and Python functions like math.random().\n\nHow do you know when to create functions vs. writing long code?\n\nThere are no rules. The judgement comes with practice.\nGenerally, tiny computations like increment don’t need functions.\nAny significant computation that is likely to be re-used should probably be in a functions.\nUse functions when breaking things into functions greatly improves readability."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CS 1012: Introduction to Programming with Python",
    "section": "",
    "text": "Welcome to CSCI 1012 - Spring 2024:\n\n\n\n\n\n\nCource Content\n\n\n\n\n\nThe course material is sourced from Prof. Simha’s webpage: https://www2.seas.gwu.edu/~simhaweb/onlinecs1012/\n\n\n\n\nGeneral information: The course we will meet during lecture and laboratory times each week.\n\nMost of our communication to you will be by Blackboard messaging and announcements.\nStart by reading the About section.\nReview the Course policies and get familiar with the Instruction Team.\n\nStudent’s main method of communication during the semester: Our main method of communication is Ed, an online discussion board for questions and answers related to the course, whether technical or logistical in nature.\n\nJoin Ed here\nDo not post your source code to Ed.\nThink through your questions. Post a general of the programming concept.\nYour questions on Ed will be addressed within 24 hours.\n\nCourse schedule: The Schedule page outlines the weekly-schedule and what your deliverables are. It is YOUR job to keep to the schedule and submit work accordingly.\n\nThe first meeting of the course will be during the labs on Wednesday (01/17/2024) and Friday (01/19/2024) [See Schedule]\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThere is deliverable due on January 22, 2024 by 11:59 PM.\n\n\n\nGetting Started: You will need to install a Python IDE or Integrated development environment.\n\nFollow the instructions on Installing an Editor.\nChoose Thonny (for Mac or Windows) as your primary choice of IDE for its simplicity, especially if you are new to coding. However, you can choose, Spyder (for Mac or Windows) which is a more versatile alternative.\nThe course is organized into Units and each Unit (0, 1 and 2), have modules in them.\n\nSubmitting your work: When you submit work, please follow the specific instructions outlined on how to submit your work.\nCommunication during extenuating circumstances: When you need to communicate with us directly regarding extenuating circumstances, please use Blackboard or follow the specific instructions outlined in Blackboard.\n\nThe instructor will check emails on Mondays and may respond directly or have one of the GTAs respond.\nAny direct email communication with the instruction team may not result in a response.\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nOur staff is limiting the use of Linux OS-based laptops and cannot support them this semester.\nWe prefer that your computer has a standard US keyboard layout i.e, a QWERTY keyboard.\n\nThe QWERTY (pronounced KWEHR-tee) keyboard is the standard typewriter and computer keyboard in countries that use a Latin-based alphabet."
  },
  {
    "objectID": "course-policies.html",
    "href": "course-policies.html",
    "title": "**CSCI1012**",
    "section": "",
    "text": "Home » Course Policies"
  },
  {
    "objectID": "course-policies.html#assessments-and-grading",
    "href": "course-policies.html#assessments-and-grading",
    "title": "**CSCI1012**",
    "section": "Assessments and Grading",
    "text": "Assessments and Grading\n\nAssessments\n\n15 Modules\n5 Assignments\nup to 13 Quizzes (given in lab)\n1 Examination\n\n\n\nGrading\n\nExamination: 30%\nAssignments: 25%\nModules: 15%\nQuizzes: 20%\nProfessionalism: 10%\n\n\n\n\n\n\n\nNote\n\n\n\nYou must pass the examination with a score greater than 60% to pass the course. - The lowest four modules are dropped. - The lowest problem set is dropped. - The lowest four quizzes are dropped. (Low grades associated associated with academic integrity violations will not be dropped.)\n\n\nWhile we use blackboard.com for assignment submissions, do not rely on blackboard.com to calculate your grades. Use the grading criteria outlined in this syllabus.\n\n\nGrading Scale\nThe following grading scale will be applied at the end of the semester to calculate letter grades, grades are “rounded up” to the nearest integer:\n\n90-100: A\n85-89: A-\n80-84: B+\n75-79: B\n70-74: B-\n65-69: C+\n60-64: C\n55-59: C-\n50-54: D\n0-49: F\n\n\n\nTime Commitement\nThere is one 75-minute class meeting per week and one 75-minute lab per week. Students are expected to spend at least 5 hours per week independently learning outside of class meetings for this course."
  },
  {
    "objectID": "course-policies.html#additional-important-information-about-grading-policy",
    "href": "course-policies.html#additional-important-information-about-grading-policy",
    "title": "**CSCI1012**",
    "section": "Additional important information about grading policy:",
    "text": "Additional important information about grading policy:\n\nLate submissions on Homework and projects will not be acceptable.\nAny questions or follow up about the assignments will be done only within 2 weeks of submission deadline.\n\nFollowing the week after the submission deadline no further discussion on the assignment will be done."
  },
  {
    "objectID": "course-policies.html#classroom-policies-and-student-responsibilities",
    "href": "course-policies.html#classroom-policies-and-student-responsibilities",
    "title": "**CSCI1012**",
    "section": "Classroom Policies and Student responsibilities",
    "text": "Classroom Policies and Student responsibilities\n\n\n\nThis course requires a combination of individual and group work entailing hands-on activities and frequent interactions with the instructional team. The lectures, labs, and office hours are available for interacting with your group and the instruction team. We ask that all students adhere to the course policies throughout the duration of the semester.\n\n\n\n\n\n\n\n\n\n\nclassroom by Chattapat from Noun Project\n\n\n\n\n\n\n\n\n\nBe respectful: Listen to the instructors. Keep an open mind to the course material presented. Limit the use of personal devices. Be aware that you are working in a group. Be mindful of your colleagues.\nBe responsible: Arrive on time. Attendance is the first pathway toward success. Submit the course deliverables on time. Help your team members.\nBe a communicator: Observe, Ask questions and Try out the materials presented during the course. Communicate with your team effectively and politely.\nBe a problem solver: Explore options to complete hands-on tasks. Make your own notes. Stay positive about the course outcomes."
  },
  {
    "objectID": "course-policies.html#justice-equity-diversity-inclusion-jedi-statement",
    "href": "course-policies.html#justice-equity-diversity-inclusion-jedi-statement",
    "title": "**CSCI1012**",
    "section": "Justice, Equity, Diversity, Inclusion (JEDI) statement",
    "text": "Justice, Equity, Diversity, Inclusion (JEDI) statement\n\n\n\nThe instruction team intends to students from all diverse backgrounds and perspectives by this course, The diversity that the students bring to this class be viewed as a resource, strength, and benefit. The course materials and activities presented in this course are intended to be respectful of: age, race, ethnicity, country of origin, language, religion, spiritual practice, sexual orientation, gender identity or expression, introversion/extroversion personality dimensions, and socioeconomic and mental/physical status.\n\n\n\n\n\n\n\n\n\n\nemployee diversity by Bold Yellow from Noun Project\n\n\n\n\n\n\n\n\nPlease let the main instructor know ways to improve the effectiveness of the course. See JEDI resources for student resources."
  },
  {
    "objectID": "course-policies.html#use-of-chatgpt-or-any-other-ai-based-models-for-in-class-work-and-deliverables",
    "href": "course-policies.html#use-of-chatgpt-or-any-other-ai-based-models-for-in-class-work-and-deliverables",
    "title": "**CSCI1012**",
    "section": "Use of chatGPT or any other AI-based models for in-class work and deliverables",
    "text": "Use of chatGPT or any other AI-based models for in-class work and deliverables\nThe use chatGPT or any other genreative AI-based tool is NOT PERMITTED. Furthermore, the ethical issues regarding the use of chatGPT or any other AI-based models will be discussed in-class and course policy will be ammended according to the findings. The findings of any such discussions will be summarized and placed in-context of the Academic Integrity Code\nResources that will guide the course policy changes during the course:\n\nchatGPT Course policy formulation\nchatGPT chatbot\nHow ChatGPT Could Transform Higher Education"
  },
  {
    "objectID": "course-policies.html#university-policies",
    "href": "course-policies.html#university-policies",
    "title": "**CSCI1012**",
    "section": "University Policies",
    "text": "University Policies\n\nUse of Electronic Course Materials and Class Recordings\nStudents are encouraged to use electronic course materials, including recorded class sessions (if any), for private personal use in connection with their academic program of study. Electronic course materials and recorded class sessions should not be shared or used for non-course related purposes unless express permission has been granted by the instructor. Students who impermissibly share any electronic course materials are subject to discipline under the Student Code of Conduct. Please contact the instructor if you have questions regarding what constitutes permissible or impermissible use of electronic course materials and/or recorded class sessions. Please contact Disability Support Services if you have questions or need assistance in accessing electronic course materials.\n\n\nUniversity Policy on Religious Holidays\n\nStudents should notify faculty during the first week of the semester of their intention to be absent from class on their day(s) of religious observance.\nFaculty should extend to these students the courtesy of absence without penalty on such occasions, including permission to make up examinations.\nFaculty who intend to observe a religious holiday should arrange at the beginning of the semester to reschedule missed classes or to make other provisions for their course‐related activities. For details and policy, see “Religious Holidays” at https://provost.gwu.edu/policies-procedures-and-guidelines"
  },
  {
    "objectID": "course-policies.html#support-for-students-outside-the-classroom",
    "href": "course-policies.html#support-for-students-outside-the-classroom",
    "title": "**CSCI1012**",
    "section": "Support for Students Outside the Classroom",
    "text": "Support for Students Outside the Classroom\n\nDisability Support Services (DSS):\nTelephone: 202-994-8250\nAny student who may need an accommodation based on the potential impact of a disability should contact the Disability Support Services office in the Rome Hall, Suite 102, to establish eligibility and to coordinate reasonable accommodations. For additional information please refer to: https://disabilitysupport.gwu.edu/\n\n\nCounseling & Psychological Services:\nTelephone: 202-994-5300\nThe University’s Mental Health Services offers 24/7 assistance and referral to address students’ personal, social, career, and study skills problems. Services for students include: crisis and emergency mental health consultations confidential assessment, counseling services (individual and small group), and referrals. https://healthcenter.gwu.edu/counseling-and-psychological-services\n\n\nCampus safety and security:\nThe following links can be accessed to learn more about the Safety and Security at the George Washington University\n\nFor help in an emergency, call 911 or GW Police 202-994-6111 (GWPD)\nAdditional resources for student safety and security can be found at this link: https://studentlife.gwu.edu/safety-and-security"
  },
  {
    "objectID": "course-policies.html#academic-integrity-code",
    "href": "course-policies.html#academic-integrity-code",
    "title": "**CSCI1012**",
    "section": "Academic Integrity Code",
    "text": "Academic Integrity Code\nContact information: rights@gwu.edu or 202-994-6757.\nAcademic dishonesty is defined as cheating of any kind, including misrepresenting one’s own work, taking credit for the work of others without crediting them and without appropriate authorization, and the fabrication of information. You are not allowed to collaborate on the home works and lab assignments; for programming projects and hardware lab assignments, you can work in teams only if they are designated as team projects (labs). Unless otherwise specified, you cannot search for solutions or code on the web – but you can use any code that is included in the textbook or lecture notes (but please cite them). I will be using a SW tool that checks for program code similarities – any pair of programs or written reports with greater than 10% similarity will be closely examined.\nThe Office of Academic Integrity maintains a permanent record of the violation. More information is available from the Office of Academic Integrity at https://studentconduct.gwu.edu/academic-integrity. The University’s “Guide of Academic Integrity in Online Learning Environments” is available at https://studentconduct.gwu.edu/guide-academic-integrity-online-learning-environments."
  },
  {
    "objectID": "instructors.html",
    "href": "instructors.html",
    "title": "Instruction Team",
    "section": "",
    "text": "Home » Instruction Team"
  },
  {
    "objectID": "instructors.html#dr.-kartik-bulusu-instructor",
    "href": "instructors.html#dr.-kartik-bulusu-instructor",
    "title": "Instruction Team",
    "section": "Dr. Kartik Bulusu (Instructor)",
    "text": "Dr. Kartik Bulusu (Instructor)\nDr. Kartik V. Bulusu is an Associate Professor of Practice in the Department of Computer Science (CS) and Associate Research Professor in the Department of Mechanical and Aerospace Engineering (MAE).\nHis research work entails human health and sustainable energy with a focus on biofluid mechanics, polymer rheology, low-cost energy technologies, and applications of wavelet transforms.\nHe is also working on AI-on-the-edge applications using low-power devices. In his free time, he loves to tinker with electronics and design low-cost experiments for research and education.\nDr. Bulusu has been developing low-cost ejector technologies refrigeration in disaster-prone regions and humanitarian needs.\nOffice Hours: On-Demand (Please reach out via email)\nLocation: Blackboard Collaborate Course Room\nCampus Address: SEH 3640\nEmail: bulusu@gwu.edu"
  },
  {
    "objectID": "instructors.html#gtas",
    "href": "instructors.html#gtas",
    "title": "Instruction Team",
    "section": "GTAs",
    "text": "GTAs\n\nEthan Leider\n\n\nBoomika Karupaiah\n\n\nAmal Alqahtani\n\n\nLexi Sun"
  },
  {
    "objectID": "instructors.html#las",
    "href": "instructors.html#las",
    "title": "Instruction Team",
    "section": "LAs",
    "text": "LAs\n\nSteven Yoon\n\n\nGustavo Londono\n\n\nJonathan Nguyen\n\n\nEvelina Naumovich"
  },
  {
    "objectID": "instructors.html#uta",
    "href": "instructors.html#uta",
    "title": "Instruction Team",
    "section": "UTA",
    "text": "UTA\n\nMarlee Alvino"
  },
  {
    "objectID": "units/useful.html",
    "href": "units/useful.html",
    "title": "Useful tools",
    "section": "",
    "text": "If and when needed.\n\n\n1. drawtool.py\n\n\n2. wordtool.py and wordsWithPOS.txt\n\n\n3. datatool.py"
  },
  {
    "objectID": "units/unit1/modules/module1.4.html",
    "href": "units/unit1/modules/module1.4.html",
    "title": "Module 1.4: while loops, I/O",
    "section": "",
    "text": "Home » Unit 1 » Module 1.2"
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#objectives",
    "href": "units/unit1/modules/module1.4.html#objectives",
    "title": "Module 1.4: while loops, I/O",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nWork through examples of indefinite loops.\nWrite while-loop versions of for-loops.\nWork through examples of using the break statement.\nWrite code to read and write to text files."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#while-loops-an-example",
    "href": "units/unit1/modules/module1.4.html#while-loops-an-example",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.0 while loops: An example",
    "text": "1.4.0 while loops: An example\nThe numbers 1, 4, 9, 16, 25, and so on are squares, with the next one being 36 (which is 62).\nSuppose we want to identify the largest square that’s less than 1000.\nWe’ll first show how this can be solved with a new kind of loop: the while-loop, and then try the same problem with a for-loop.\nThe program:\nk = 1\nwhile k*k &lt; 1000:\n    k = k + 1\n\n# Reduce by 1 because now k*k &gt; 1000\nk = k - 1\n\nprint('largest square &lt; 1000:', k*k, '= square of', k)\n\n\n\n\n\n\n1.4.1 Exercise\n\n\n\nType up the above in my_while_example.py.\n\n\nHow does a while-loop work?\n\nThe essential idea is: a while-loop keeps iterating until its condition evaluates to False.\nLet’s examine the structure: \nIn our example, the condition was:\nwhile k*k &lt; 1000:\nThus, as long as the value of k is such that k*k is less than 1000, execution enters and stays inside the loop.\nNotice that k is incremented (or changed) inside the loop:\nwhile k*k &lt; 1000:\nk = k + 1\nThus, eventually kwill get large enough so that k*k will be larger than 1000.\nWhen k is 32, in fact, 32*32 = 1024, which will cause the condition k*k &lt; 1000to evaluate to False.\nAt this moment, execution exits the loop to the whatever code follows: \n\nLet’s examine a simpler while-loop:\nk = 1\nwhile k &lt; 6:\n  print(k)\n  k = k + 1\n\n\n\n\n\n\n1.4.2 Exercise\n\n\n\nTrace the execution of each iteration in your module pdf. Then confirm by typing up the above in my_while_example2.py.\n\n\n\n\n\n\n\n\n1.4.3 Exercise\n\n\n\nConsider this variation:\nk = 7\nwhile k &lt; 6:\n  print(k)\n  k = k + 1\nTrace the execution of the above program in your module pdf. Then confirm by typing up the above in my_while_example3.py.\n\n\n\n\n\n\n\n\n1.4.4 Exercise\n\n\n\nConsider this variation:\nk = 1\nwhile k &lt; 6:\n  print(k)\nTrace the execution of a few iterations of the above program in your module pdf. Then confirm by typing up the above in my_while_example4.py. After a minute, you may need to terminate the execution of the program by hand (by getting rid of the window itself).\n\n\nKeep in mind:\n\nA while-loop typically must feature some kind of initialization before the loop as in:\nk = 1\nwhile k &lt; 6:\n  print(k)\n  k = k + 1\nThe variable that’s involved in the condition should be changed inside the loop so that the condition eventually evaluates to False:\nk = 1\nwhile k &lt; 6:\n  print(k)\n  k = k + 1\nAnother important thing to remember: if you forget to change a variable like k inside the loop, the condition will never becomes False, which means the loop will iterate forever:\nk = 1\nwhile k &lt; 6:\n  print(k)\n  i = k + 1   # Error!\nHere\n\nThe incremented value k+1 does not get stored in k.\nWhich means k never gets large enough.\nTherefore k &lt; 6 will always be True.\nThus, we get an infinite loop (that iterates forever).\n\nIt’s alright, but probably not useful, if the condition never evaluates to True even once:\nk = 6\nwhile k &lt; 6:\n  print(k)\n  k = k + 1\nThe code still runs but the while-loop is not executed at all."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#while-loops-an-example-with-floating-point-variables",
    "href": "units/unit1/modules/module1.4.html#while-loops-an-example-with-floating-point-variables",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.1 while loops: an example with floating point variables",
    "text": "1.4.1 while loops: an example with floating point variables\nConsider this example:\nx = 0.5\ns = 0\nwhile s &lt;= 2:\n  s = s + x\n\nprint('s =', s)\n\n\n\n\n\n\n1.4.6 Exercise\n\n\n\nTry to guess the output before confirming in my_while_example5.py.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe value of x (which is 0.5) keeps getting added to s, as long as s is less or equal to 2.\nThus, the last value of s to keep going in the loop is when s = 2.\nAt this time, we stay for one more iteration, after which s becomes 2.5.\n\n\n\nLet’s look at a more illustrative version now:\nx = 0.5\ns = 0\nk = 0\nwhile s &lt;= 2:\n  s = s + x\n  k = k + 1\n\nprint('s =', s, 'k =', k)\nHere, we’ve added a counter variable to track each loop iteration.\n\n\n\n\n\n\n1.4.7 Exercise\n\n\n\nTrace the values of the three variables in your module pdf. Then confirm in my_while_example6.py.\n\n\nSo far it’s been straightforward. Let’s now solve a problem:\n\nRemember Zeno’s paradox?\nTo summarize one version, Zeno said (with a wry smile, probably):\n\nTo walk a mile, you’d have to first walk half the remaining distance (0.5 miles).\nThen, to get to the rest, you’d have to walk at least half of the remaining (0.25).\nThen, half of the remainder (0.125)\n… and so on.\nSo, the total distance would be an infinite sum: 0.5 + 0.25 + 0.125 + …\nWhich is infinite [he said]\n\nLet’s count how many successive halvings add up to, say, 0.9.\nHere’s the code:\nx = 1\ns = 0\nk = 0\nwhile s &lt; 0.9:\n  x = x / 2   # Halve x each time\n  s = s + x\n  k = k +1\n\nprint(k)\n\nWe accumulate the sum in s.\nNote that we start with x = 1 because we perform the halving before adding to s.\nThis means the first value added into s is 0.5 (as intended).\nEach such addition into s get counted in k.\n\n\n\n\n\n\n\n\n1.4.8 Exercise\n\n\n\nTrace the values of the three variables in your module pdf. Then confirm in my_while_example7.py.\n\n\nA few comments that go beyond the scope of the course (just for curiosity):\n\nThe infinite sum, in fact, adds up to 1.\nIt took centuries for mathematics to develop to a point where one can prove that infinite sums are acceptable and can have finite results.\nHowever, a computer can only represent real numbers approximately, which means the sum is itself approximate.\nYou can see this by changing the while-condition from\nwhile s &lt; 0.9:\nto\nwhile s &lt; 1:\nTheoretical math would say that the while-loop would execute forever, but because there limits to what’s representable on a computer, the loop will indeed terminate."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#for-vs.-while",
    "href": "units/unit1/modules/module1.4.html#for-vs.-while",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.2 for vs. while",
    "text": "1.4.2 for vs. while\nLet’s contrast for-loops and while-loops by writing a for-loop as a while-loop, and vice-versa.\nAs an example, let’s print the numbers 0 through 10:\n# for-loop version\nfor k in range(11):\n  print(k)\n\n# while-loop version\nk = 0\nwhile k &lt; 11:\n  print(k)\n  k = k + 1\n\n\n\n\n\n\nNote\n\n\n\n\nThe for-loop is simpler to write.\nThe while-loop must make explicit three things:\n\nThe initialization:\nk = 0\nwhile k &lt; 11:\n  print(k)\n  k = k + 1\nThe termination condition:\nk = 0\nwhile k &lt; 11:\n  print(k)\n  k = k + 1\nAnd the variable change (that will ultimately cause the condition to become False):\nk = 0\nwhile k &lt; 11:\n  print(k)\n  k = k + 1\n\nAll of this is hidden in the for-loop.\nUnderneath the hood, it turns out, the for-loop also has these three elements.\nIt’s just that we don’t have to write them, Python does so behind the scenes.\nWhen you write while-loops, ask yourself: “Do I have the three elements (initialization, condition, variable-change)?”\nA really common mistake: forgetting the change, as in:\nk = 0\nwhile k &lt; 11:\n  print(k)\nThis loop runs forever!\n\n\n\n\n\n\n\n\n\n1.4.10 Exercise\n\n\n\nConsider this for-loop:\nfor k in range(5, 20, 2):\n  print(k)\nIn my_for_while.py, write the while-loop equivalent.\n\n\nNext, let’s go from while to for:\n\nConsider this while-loop that prints the letters in a string backwards:\ns = 'hello'\nk = len(s) - 1\nwhile k &gt;= 0:\n  print(s[k])\n  k = k - 1\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe initialization starts k at the last index of the string:\nk = len(s) - 1\nThe loop condition expects k to decrement until it hits 0.\nAfter this, k (when it’s -1) will have gone past the left end of the string.\nk decrements in the loop.\n\n\n\n\nThe equivalent for-loop is efficient to write, but less pretty:\nfor k in range(len(s)-1, -1, -1):\n  print(s[k])\nHere:\n\nThe range begins with\nfor k in range(len(s)-1, -1, -1):\nEnds with 0, but has the index just past (-1) as the limit:\nfor k in range(len(s)-1, -1, -1):\nAnd the increment is -1 (which makes it a decrement).\n\nLater, when we learn more advanced ways of using slicing, we will be able to do the same thing with shorter code.\n\n\n\n\n\n\n\n1.4.11 Exercise\n\n\n\nTrace through both loops in your module pdf before confirming both in my_for_while2.py.\n\n\n\n\n\n\n\n\n1.4.12 Exercise\n\n\n\nConsider the following program with a while-loop:\ndef func(A):\n  k = 0\n  while A[k].startswith('h') and (len(A[k]) &gt; 4) and (k &lt; len(A)):\n    print(A[k])\n    k += 1\n\ndef func2(A):\n  # Write your for-equivalent here:\n\nB = ['hello', 'hey there', 'howdy', 'huzzah', 'hi', 'greetings']\nfunc(B)\nfunc2(B)\nTrace through the first loop (in func) in your module pdf, to see that the loop keeps printing strings from a list as long as the strings start with ‘h’ and have length at least 5. Then, in my_for_while3.py, complete the code in func2 using a for-loop to achieve the same result.\n\n\n\n1.4.13 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#using-break-in-loops",
    "href": "units/unit1/modules/module1.4.html#using-break-in-loops",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.3 Using break in loops",
    "text": "1.4.3 Using break in loops\nLet’s return to our first example of finding the last square that’s less than 1000.\nRecall what we wrote:\nk = 1\nwhile k*k &lt; 1000:\n  k = k + 1\n\nk = k - 1\nprint('largest square &lt; 1000:', k*k, '= square of', k)\nOne can use a break statement as an alternative to writing the “loop exit” condition as the while condition.\nWe’ll first do this with a for-loop, and then see something unusual with the while-loop version.\nTo simplify tracing, let’s rephrase to “largest square less than 50”.\nFirst, the for-loop version:\nfor k in range(1, 50):\n  # print('Before-if: k =', k)\n  if k*k &gt; 50:\n      break\n  # print('After-if: k =', k)\n\nk = k - 1\nprint(k)\n\n\n\n\n\n\n1.4.14 Exercise\n\n\n\nType up the above in my_break.py, removing the # to un-comment the print’s, so that you can see exactly what happens when the if-condition triggers.\n\n\nLet’s point out:\n\nA break-statement is the reserved word break all by itself on a line, as seen above.\nWhen a break statement executes, Python looks for the loop that encloses the break and abruptly, right there and then, exits the loop.\nBreak-statements are useful to check for conditions that should result in leaving the loop immediately.\nOne could write code like this, but it would make no sense:\nfor k in range(10):\n  print(k)\n  break\nThis would cause the first value (0) to print, and a break right out of the loop.\nAs a mathematical aside, we know that we don’t really need the for-loop range to be as high as 50:\nfor k in range(1, 50):\n  if k*k &gt; 50:\n      break\nAfter all, as k gets close to 50, there is no way k*k would be less than 50. However, we’ll leave it as is, for the sake of simplicity.\nThere are options in writing the loop. Consider this one:\nfor k in range(1, 50):\n  if (k+1)*(k+1) &gt; 50:\n    print(k)\n    break\nIs this more elegant, if a bit harder to understand at first?\n\n\n\n\n\n\n\n1.4.15 Exercise\n\n\n\nTrace the execution of the above loop in you module pdf, The type it up in my_break2.py, to confirm.\n\n\nNext, let’s look at a while-loop version of the original\n\nHere’s the code:\nk = 1\nwhile True:\n  if k*k &gt; 50:\n    break\n  k = k + 1\n\nk = k - 1\nprint(k)\nObserve: \nWas it surprising that we deliberately set up a loop to appear to run forever?\nThis is entirely do-able and often desirable, provided we are real careful to set up a condition inside the loop to break out eventually.\nWe need to be sure we hit that condition eventually.\n\n\n\n\n\n\n\n1.4.16 Exercise\n\n\n\nIn your module pdf, describe what would go wrong if the statement k = k + 1 was mistakenly typed in as k = k - 1.\n\n\n\n\n\n\n\n\n1.4.17 Exercise\n\n\n\nIn my_break3.py, go back to the earlier exercise (4.12) where you wrote a while-loop to print strings of length at least 5, and starting with ‘h’. Rewrite the while-loop to use a break-statement instead."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#loops-within-loops",
    "href": "units/unit1/modules/module1.4.html#loops-within-loops",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.4 Loops within loops",
    "text": "1.4.4 Loops within loops\nJust as we’ve seen nested for-loops, so can we have nested while-loops or one kind inside another.\nConsider this example:\nm = 10\nwhile m &lt;= 10000:\n  for k in range(1, m):\n    if (k+1)*(k+1) &gt;= m:\n      print('largest square &lt;', m, ':',k*k)\n      break\n  m = m * 10\n\n\n\n\n\n\n1.4.19 Exercise\n\n\n\nType the above in my_nested_loop.py and try to make sense of it.\n\n\nLet’s explain:\n\nFirst, notice that we have a for-loop inside a while-loop: \nLet’s start with understanding what happens in the outer loop: \nThus, m is first 10, then 100, then 1000, then 10000.\nNow let’s see what happens within one iteration of the outerloop (for a particular value of m): \n\n\n\n\n\n\n\nTip\n\n\n\nThe break in the for-loop exits the for-loop (the enclosing loop), which means we’ll still be inside the while-loop (where m changes).\n\n\n\n\n\n\n\n\n1.4.20 Exercise\n\n\n\nIn my_nested_loop2.py, change the inner loop to a while loop so that we get the same output.\n\n\n\n\n\n\n\n\n1.4.21 Exercise\n\n\n\nIn my_nested_loop3.py, change the code so that both the outerloop and innerloop are for-loops. One way to solve this problem: use a variable called j to range through the outer for-loop and then ensure that the innerloop executes only when j happens to equal m. (Aren’t you glad we have while-loops?)"
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#more-stats-via-programming",
    "href": "units/unit1/modules/module1.4.html#more-stats-via-programming",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.5 More stats via programming",
    "text": "1.4.5 More stats via programming\nConsider the following problem:\n\nAn experiment consists of flipping three coins.\nThe experiment is repeated until all three are “heads”\nOn average, how many experiments are needed until all three turn up “heads”?\n\nOne way to think about this problem “statistically” is this:\n\nSuppose we hire a thousand people to each perform repeated three-coin flips.\nFor very few of these people, they’ll get “heads-heads-heads” the very first experiment.\nFor others, they might have to repeat 10 times before they see this.\nEach person counts how many experiments had to be tried before getting three-heads.\nThe result is the average number across the thousand people: the average number of 3-coin flips needed to see three heads.\n\nInstead of calculating by hand, we will write a program to estimate this number:\nimport random\n\nnum_trials = 1000\ntotal = 0\n\nfor k in range(num_trials):\n  got_three = False\n  num_three_flips = 0\n  while not got_three:\n    c1 = random.choice(['H','T'])\n    c2 = random.choice(['H','T'])\n    c3 = random.choice(['H','T'])\n    num_three_flips += 1\n    if (c1 == 'H') and (c2 == 'H') and (c3 == 'H'):\n      got_three = True\n  total += num_three_flips\n\nestimate = total / num_trials\nprint('estimate', estimate)\n\n\n\n\n\n\n1.4.23 Exercise\n\n\n\nType up the above in my_coin_flips.py to get an estimate. (Submit the program with 1000 trials.) Then, increase the number of trials to get a more accurate estimate, and report that in your module pdf. Can you explain the result intuitively?\n\n\nLet’s point out:\n\nFirst, let’s point out the process of estimation (the outer loop) that we’d use in any estimation problem:\nnum_trials = 1000\ntotal = 0\n\nfor k in range(num_trials):\n  # how many of these resulted in successes?\n\nestimate = total / num_trials\nNow let’s look inside to see how each trial is performed: \nA variable like got_three is sometimes called a flag variable: we use it to flag a condition that we’re looking for.\n\n\n\n\n\n\n\n1.4.24 Exercise\n\n\n\nIn my_coin_flips2.py, instead of using a flag variable, use a break statement to exit the loop. You might have to make a small adjustment to get the correct result.\n\n\n\n\n\n\n\n\n1.4.25 Exercise\n\n\n\nConsider an experiment where you roll a die twice to see if you get 6 and 6. In my_dierolls.py, estimate the average number of experiments needed to get two sixes."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#new-topic-reading-from-a-file",
    "href": "units/unit1/modules/module1.4.html#new-topic-reading-from-a-file",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.6 New topic: reading from a file",
    "text": "1.4.6 New topic: reading from a file\nVery often, data is collected and stored in files, and so it’s desirable to learn how write code that plucks data right out of such files.\nLet’s start with a simple test file of plain text.\nFirst, examine the file testfile.txt to see that it’s a file consisting of four lines of text. (From the poet Ogden Nash.)\nWe will look at a few different versions of reading from this file.\nHere’s the first:\nwith open('testfile.txt', 'r') as in_file:\n  lines = in_file.read()\n\nprint(type(lines))\nprint(lines)\n\n\n\n\n\n\n1.4.27 Exercise\n\n\n\nType up the above in my_file_read.py. What is the type of the variable lines?\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe’ve used two Python reserved words:\nwith open('testfile.txt', 'r') as in_file:\nAlthough file input/output (I/O) does not strictly require the with structure, it is useful because:\n\nFiles that are being accessed by one program are said to be in an “opened” state.\nFor another program to be able access the file, the first one has to “close” it (that is, signal that it’s done with the file).\nThe with structure automatically takes care of it.\n\nThe function call to opentakes the name of the file and the kind of access, for example:\nwith open('testfile.txt', 'r') as in_file:\n\n‘r’ for read-only access (we’re not changing the file here)\n‘w’ for write, if we should choose to.\n\nThe result of opening a file is to get a special kind of variable, what we’ve called in_file in this case:\nwith open('testfile.txt', 'r') as in_file:\nIt is this variable that’s going to perform the reading and, in this case, get us all the text in one shot:\nwith open('testfile.txt', 'r') as in_file:\n  lines = in_file.read()\nNote that all the lines are returned as a single string.\nThis means, it will be difficult to analyze string-by-string, if that’s our goal.\nThere is a way to take the single string and break it into separate lines, but let’s instead find a way to read separate lines.\n\n\n\nAccordingly, let’s look at a way to read the file into a list of strings, where each line is one string in the list:\nlines = []\nwith open('testfile.txt', 'r') as in_file:\n  line = in_file.readline()\n  while line != '':\n    lines.append(line.strip())\n    line = in_file.readline()\n\nprint(type(lines))\nprint(lines)\n\n\n\n\n\n\n1.4.28 Exercise\n\n\n\nType up the above in my_file_read2.py. What is the type of the variable lines?\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nHere, we’re reading one line at a time and appending to a running list, which is the lines variable.\nThe problem is, for any general file, we won’t know in advance how many lines of text are in the file.\nA while-loop to the rescue!\nThus, we keep reading from the file as long as a read operation produces a line: \n\n\n\nWriting to a file:\n\nSuppose we’ve read a text file into a list of strings.\nLet’s now write these to a new file:\nwith open('testcopy.txt', 'w') as out_file:\n  for line in lines:\n    out_file.write(line + '\\n')\nThis time, we’re opening a file called testcopy.txt for the purpose of writing to it:\nwith open('testcopy.txt', 'w') as out_file:\n  for line in lines:\n    out_file.write(line + '\\n')\nWe’ve named our file variable out_file.\nThat will let us use a function called write():\nwith open('testcopy.txt', 'w') as out_file:\n  for line in lines:\n    out_file.write(line + '\\n')\nHere, we’re looping through the list, writing each string as one line in the file.\nNotice that we need to insert the ‘’ at the end of each line.  Recall:\n\n‘\\n’ represents an instruction to both output and files to “go to the next line right now”.\nThus for example\nprint('hello' + 'world')           # Prints helloworld on one line\nprint('hello' + '\\n' + 'world')    # Prints hello, and then world on the next line\n\nSo, to write strings to different lines, we have to tell the function that writes to files to go to the next line with an explicit ‘’.\nIt’s similar with reading, if we read a whole file as one string, that string will contain the so-called linebreaks (the ‘’ characters).\n\n\n\n\n\n\n\n\n\n1.4.29 Exercise\n\n\n\nIn my_file_readwrite.py, combine the reading and writing so that the program as whole results in copying from testfile.txt to testcopy.txt.\n\n\nNext, let’s read from a file of numbers and perform some basic stats:\n\nFirst, examine the file data.txt and see that it’s a collection of numbers, one per line.\nWe’ll read line by line as a string, and then convert to a floating-point number:\ndata = []\nwith open('data.txt', 'r') as in_file:\n  line = in_file.readline()\n  while line != '':\n    s = line.strip()           # Remove leading/trailing whitespace\n    x = float(s)               # Convert string to float\n    data.append(x)             # Add to our list\n    line = in_file.readline()  # Get the next line\n\nprint(data)\n\n\n\n\n\n\n\n1.4.30 Exercise\n\n\n\nIn my_file_data.py, add code to compute the average of the numbers and print it. Compute the total as you iterate in the while-loop."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#extracting-multiple-data-from-each-line",
    "href": "units/unit1/modules/module1.4.html#extracting-multiple-data-from-each-line",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.7 Extracting multiple data from each line",
    "text": "1.4.7 Extracting multiple data from each line\nConsider a data file that looks like this, with three numbers on each line:\n6.0 6.0 9.0\n4 6 8  \n24 16 2  \n3 3.0 3\n0.1 0.5 0.3\nWhat we’d like to do is compute the average of the numbers in each line. So, the output should be something like:\nAverage of 6.0 6.0 9.0 is: 7.0\nAverage of 4.0 6.0 8.0 is: 6.0\nAverage of 24.0 16.0 2.0 is: 14.0\nAverage of 3.0 3.0 3.0 is: 3.0\nAverage of 0.1 0.5 0.3 is: 0.3\nTherefore, what need to do is not only read a line at a time, but be able to extract multiple items from within a line.\nWe can split a string as follows:\n\nConsider this example:\ns = '6.0 6.0 9.0'\ndata = s.split()    # data is a list\nprint(data)        \nHere, the split() function in strings, looks for whitespace within and separates out into a list those items separated by this whitespace.\nSo, in the above example, we’ll have the string ‘6.0 6.0 9.0’ split into a list of three strings [‘6.0’, ‘6.0’, ‘9.0’]\nHaving a list of strings is not enough to compute the average of the numbers in those strings.\nWe need to convert into numbers:\ns = '6.0 6.0 9.0'\ndata = s.split()    # data is a list\nprint(data)    \nx = float(data[0])\ny = float(data[1])\nz = float(data[2])  # x, y, z are numbers  \navg = (x + y + z) / 3.0\nprint(avg)\nWe can now read one line at a time from the data file, split each line, convert to numbers, and then calculate the average for each line.\n\n\n\n\n\n\n\n1.4.32 Exercise\n\n\n\nType up the above in my_split_example.py to see. Next, examine the file data2.txt in a text editor and try and identify all the (unnecessary) whitespace within.\n\n\nWe’ll now tackle one additional complication:\n\nIt is common for real data to be acquired or presented with mistakes, missing entries, or weird whitespacing.\nThe missing entry problem is somewhat harder to tackle, so we’ll postpone that for another time.\nBut we can easily eliminate whitespace using strip().\nFor example consider: \nThus, we need to worry about when a line is all whitespace but not empty.\nLet’s put these ideas into code:\nwith open('data2.txt','r') as in_file:\n  line = in_file.readline()\n  while line != None:\n    line = line.strip()\n    print('[', line, ']', sep='')\n    if len(line) == 0:\n      break\n    data = line.split()\n    print(data)\n    x = float(data[0])\n    y = float(data[1])\n    z = float(data[2])\n    avg = (x + y + z) / 3.0\n    print('Average of ', x, ' ', y, ' ', z, ' is: ', avg, sep='')\n    line = in_file.readline()\n\n\n\n\n\n\n\n1.4.33 Exercise\n\n\n\nType up the above in my_file_data2.py. You already have saved the file data2.txt in the same folder.\n\n\nWe’ll point out a few things: \n\nWe have two print’s in there to see what we get as a result of strip() and split():\nline = line.strip()\nprint('[', line, ']', sep='')\n\ndata = line.split()\nprint(data)\nRecall: the sep=’’ (empty separation) parameter tells print() not to add its own whitespace between different arguments.\nNotice also that we have deliberately added in our printing,a pair of brackets:\nprint('[', line, ']', sep='')\nThis is a common programming technique when you want to identify whitespace: put something around it that is actually visible.\nYou also noticed that split() produces a list, and that each string in the list has already had whitespace removed on either side."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#while-loops-when-files-are-large",
    "href": "units/unit1/modules/module1.4.html#while-loops-when-files-are-large",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.8 While-loops when files are large",
    "text": "1.4.8 While-loops when files are large\nLet’s return to a problem we’ve seen before: identifying the longest sentence in a text file.\nTake a moment to  review that section\nObserve:\n\nTo find the longest sentence, we read the whole file into one giant list of sentences.\nThen, we went through the list, recording the longest sentence.\nFor a really large text file, the list could be too long to fit into memory.\nLet’s use a different version that reads sentence-by-sentence:\nimport wordtool as wt\n\ndef get_longest_sentence(filename):\n  # Initiate the reading of the file\n  sentences = wt.open_file_bysentence(filename)\n  maxL = 0\n\n  # Get first sentence\n  s = wt.next_sentence()\n  while s != None:\n    if len(s) &gt; maxL:       # Possibly update maxS\n      maxL = len(s)\n      maxS = s\n    s = wt.next_sentence()  # next one\n\n  return maxS\n\n\nbook = 'federalist_papers.txt'\ns = get_longest_sentence(book)\nprint('Longest sentence in', book, 'with', len(s), 'chars:\\n', s)\n\n\n\n\n\n\n\n1.4.34 Exercise\n\n\n\nIn my_text_analysis.py, count the number of sentences that have length greater than 280 characters (more than a tweet) in federalist_papers.txt. You will need to download wordtool.py and wordsWithPOS.txt."
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#random-walks-and-art",
    "href": "units/unit1/modules/module1.4.html#random-walks-and-art",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.9 Random walks and art",
    "text": "1.4.9 Random walks and art\nBut of course. We’re somehow going to combine while-loops with our recurring themes (algorithmic art, randomness).\nThis time, we will use a well-known idea from science called a random walk:\n\nImagine standing at the origin: \nThen, we choose a random direction from among: North, South, East, West.\nOnce such a direction is randomly chosen: we take a fixed-size step in that direction, and mark the spot: \nHere’s what it might look like after 5 steps: \nHere’s the program:\nimport random\nfrom drawtool import DrawTool\n\ndt = DrawTool()\ndt.set_XY_range(-5,5, -5,5)\ndt.set_aspect('equal')\n\nstep = 1\n\ndef do_walk(max_steps):\n  x = 0\n  y = 0\n  num_steps = 0\n  dt.draw_point(x, y)\n  while num_steps &lt; max_steps:\n    direction = random.choice(['N','S','W','E'])\n    if direction == 'N':\n      y += step\n    elif direction == 'S':\n      y -= step\n    elif direction == 'E':\n      x += step\n    else:\n      x -= step\n    dt.draw_point(x, y)\n    print(direction, x, y)\n    num_steps += 1\n\ndo_walk(5)\n\ndt.display()\n\n\n\n\n\n\n\n1.4.35 Exercise\n\n\n\nType up the above in my_randomwalk.py and try out a larger number of steps. You will also need drawtool.py. Call do_walk() twice and change the draw color in between using dt.set_color('r').\n\n\nInstead of running the random walk for a fixed number of steps, we’ll now run the random walk until it “hits” one of the sides and stop.\n\nTo do this, we’ll use the approach of:\nwhile True:\n    # get a random direction and move\n    # if we hit one of the sides, then break\nWe’ll also enlarge the box to be bigger and make the step size smaller (so as to fill the space with dots).\n\n\n\n\n\n\n\n1.4.36 Exercise\n\n\n\nTry out random_walk_demo2.py several times. Then, change the code so that the function do_walk() takes in the starting point as a parameter. Call do_walk() several times with different starting points.\n\n\nWe’re now finally ready for the art project:\n\nWe’ll start different random walks at randomly selected starting points, and then draw each in a random color.\n\n\n\n\n\n\n\n1.4.37 Exercise\n\n\n\nTry out random_walk_art.py several times. Try to modify it to improve the (artistic) outcome. Describe what you did in your module pdf and submit a screenshot.\n\n\nAbout random walks (in science):\n\nAlthough a random walk might seem like a silly exercise, the idea has had significant scientific impact.\nFor example, a version of random walk is the basis for modeling diffusion and osmosis.\nThe same basic idea underlies Brownian motion and Einstein’s demonstration of the existence of molecules.\nA random walk on networks (as opposed to 2D space) is what launched Google.\nEvolution is often modeled as a random walk on an abstract representation of the space of DNA sequences.\nIs that enough to believe in the importance of random walks?"
  },
  {
    "objectID": "units/unit1/modules/module1.4.html#when-things-go-wrong",
    "href": "units/unit1/modules/module1.4.html#when-things-go-wrong",
    "title": "Module 1.4: while loops, I/O",
    "section": "1.4.10 When things go wrong",
    "text": "1.4.10 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n1.4.38 Exercise\n\n\n\nThe following code wants to print the numbers from 10 to 1 in descending order:\nk = 0\nwhile k &gt; 0:\n  print(k)\n  k = k - 1\nIdentify and fix the error in my_error1.py.\n\n\n\n\n\n\n\n\n1.4.39 Exercise\n\n\n\nThe following code wants to print the numbers from 1 through 10, along with each number’s “double” (twice the number).\nm = 1\nn = 2\nwhile (m &lt;= 10) or (n &lt;= 20):\n  print(m, 2*n)\n  m = m + 1\n  n = n + 1\nIdentify and fix the error in my_error2.py.\n\n\n\n\n\n\n\n\n1.4.40 Exercise\n\n\n\nThe following code wants to print the odd numbers from 1 through 9.\nx = 1\nwhile x &lt; 10:\n  if x % 2 == 1:     # Test whether odd\n    print(x)\n  else:\n    x = x + 1\nIdentify and fix the error in my_error3.py."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html",
    "href": "units/unit1/modules/module1.2.html",
    "title": "Module 1.2: Functions",
    "section": "",
    "text": "Home » Unit 1 » Module 1.2"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#objectives",
    "href": "units/unit1/modules/module1.2.html#objectives",
    "title": "Module 1.2: Functions",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to: - Enhance your understanding of how to use def to write functions, then invoke them. - Write code with function definitions and invocations. - Write and debug code with functions - Explore the different ways in which parameters work. - Identify new syntactic elements related to the above."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#wait-stop",
    "href": "units/unit1/modules/module1.2.html#wait-stop",
    "title": "Module 1.2: Functions",
    "section": "1.2.0 Wait, stop!",
    "text": "1.2.0 Wait, stop!\nBefore continuing it is essential to review functions as described in Module 0.2 of Unit-0\nWhat to review most carefully:\n\nThe notion of how execution starts outside a function, goes into a function, and comes back to where the function was invoked.\n\n\n\n\n\n\n\nTip\n\n\n\nWhen we come back to where the function was invoked, we continue execution just after the invocation.\n\n\n\n\n\n\n\n\n1.2.1 Exercise\n\n\n\nPlease review that module. Now."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#a-simple-example",
    "href": "units/unit1/modules/module1.2.html#a-simple-example",
    "title": "Module 1.2: Functions",
    "section": "1.2.1 A simple example",
    "text": "1.2.1 A simple example\nConsider this program:\ndef increment_and_print(a):\n    a = a + 1\n    print(a)\n\ni = 5\nincrement_and_print(i)\n\nj = 6\nincrement_and_print(j)\n\n\n\n\n\n\n1.2.2 Exercise\n\n\n\nType up the above in my_func_example.py Then, just before the j=6 statement, print the value of i.\n\n\nLet’s explain:\n\nLet’s start by distinguishing between a function definition (which merely tells Python what the function is about), and invocation (which asks Python to execute the function at that moment): \nNow let’s peer into what constitutes a definition: \nIn the above case, the function increment_and_print has only one parameter called a.\n\nIn the future, we’ll see that a function can have several parameters, separated by commas.\nFor example\ndef increment_and_print(a, b, c):\n\nNext, let’s examine how execution proceeds, starting with what happens when a function is invoked: \nOnce execution is inside the function: \nNext, execution moves further into the second invocation: \nThe code inside the function now executes (again): \n\n\n\n\n\n\n\nNote\n\n\n\nDid you notice that neither i nor j was affected by the incrementing of a?\n\nThis is because the value in i was copied into the freshly-created a at the moment the function was invoked.\nEven though a got incremented, that did not affect i.\n\n\n\n\nVariables like a that appear in the parentheses of a function definition are called parameters.\n\nWhat does a function do with its parameters?\n\nThink of the parameters as variables that can be used as regular variables for any purpose.\nFor example, consider this program:\n\ndef print_from_one_to(a):\n    print('Printing between 1 and ', a)\n    for i in range(1, a+1):\n        print(i)\n\nprint_from_one_to(5)\nprint_from_one_to(6)\n\nHere, we used the parameter a in setting the upper limit of a for-loop.\n\n\n\n\n\n\n\nNote\n\n\n\n\nWhen a function is defined with a parameter, the intent is that some code outside the function will set the value of the parameter.\n\nThus, it would be allowed but technically defeat the purpose to write:\ndef print_from_one_to(a):\n    a = 5\n    print('Printing between 1 and ', a)\n    for i in range(1, a+1):\n        print(i)\n\nprint_from_one_to(5)\nprint_from_one_to(6)\nYes, this runs, but the whole point is for some other code to tell the function, “hey, I’m going to set a, and then you do your printing with the value I set”.\nAnd so, when we write\ndef print_from_one_to(a):\n    print('Printing between 1 and ', a)\n    for i in range(1, a+1):\n        print(i)\nprint_from_one_to(5)   # We're telling the function that a = 5\nprint_from_one_to(6)   # We're now telling the function to use a = 6\n\n\n\n\n\n\n\n\n\n\n1.2.3 Exercise\n\n\n\nWhat do each of the above two programs print? Type them up in my_func_example2a.py and my_func_example2b.py to find out.\n\n\n\n1.2.4 Video\n\n\n\n\n\n\n\n1.2.5 Exercise\n\n\n\nIn my_func_example3.py, fill in the code in the function below so that the output of the program is:\n*****\n***\n*\nThe partially-written program:\ndef print_stars(n):\n    # Write your function code here\n\nprint_stars(5)\nprint_stars(3)\nprint_stars(1)\n\n\n\n\n1.2.6 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#multiple-parameters",
    "href": "units/unit1/modules/module1.2.html#multiple-parameters",
    "title": "Module 1.2: Functions",
    "section": "1.2.2 Multiple parameters",
    "text": "1.2.2 Multiple parameters\nRemember Pythagoras? We know his famous result:\n\nA Pythagorean triple is any group of three integers like 3,4,5 where the squares of the first two add up to the square of the third: 32 + 42 = 52.\nWe’ll now write code to check whether a trio of numbers is indeed a Pythagorean triple:\ndef check_pythagorean(a, b, c):\n    if a*a + b*b == c*c:\n        print('yes')\n    else:\n        print('no')\n\ncheck_pythagorean(3, 4, 5)\ncheck_pythagorean(5, 12, 13)\ncheck_pythagorean(6, 8, 20)\n\n\n\n\n\n\nNote\n\n\n\n\nThis time, we’ve defined a method that takes three parameters:\ndef check_pythagorean(a, b, c):\n    # Write your function code here\nNotice the commas separating the three variables.\nConsider the first invocation: \nThe invocation also uses commas to separate arguments.\n\n\n\n\n\n\n\n\n\n1.2.7 Exercise\n\n\n\nIn my_func_example4.py, fill in the code in the function below so that the output of the program is:\n5\n3\n2\n0\nThe partially written program is:\ndef print_profit_total(a,b):\n    # Write your function code here\n\nprint_profit_total(2, 3)\nprint_profit_total(-2, 3)\nprint_profit_total(2, -3)\nprint_profit_total(-2, -3)\nThe idea is to compute the sum but only of the positive parameters; if neither value is positive, print 0.\n\n\n\n1.2.8 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#return-values",
    "href": "units/unit1/modules/module1.2.html#return-values",
    "title": "Module 1.2: Functions",
    "section": "1.2.3 Return values",
    "text": "1.2.3 Return values\nSo far, we’ve written methods that take values, do things and print.\nWe get a whole new level of programming power, when methods can compute something and return something to the invoking code.\nHere’s an example:\ndef padd(a, b):\n    total = 0\n    if a &gt;= 0:\n        total += a\n    if b &gt;= 0:\n        total += b\n    return total\n\nx = padd(-5, 6)\nprint(x)\n\n\n\n\n\n\n1.2.9 Exercise\n\n\n\nType up the above in my_func_example5.py. Then try sending 5,-6 instead of -5,6. Then try 5,6. In your module pdf, trace through the execution in each case. What does the padd() function achieve?\n\n\nLet’s explain:\n\nFirst, execution begins after the function definition is “absorbed” by Python: \n\nRemember, in an assignment statement, the right side is executed first:\nx = padd(-5, 6)\nThe result of invoking this function somehow results in x getting a value stored inside it.  (We’ll see how, shortly.)\nNext, execution goes into the function: \nWhen the return statement executes, the value returned (the value of total gets copied into x) \nOne way to think about it:\n\nWhen we see\nx = padd(-5, 6)\nthen think of execution going to the function padd\nAfter it executes, it returns the value in one of its variables: in this case 6\nThat, behind the scenes, replaces the function invocation:\nx = 6\nAnd thus, the value 6 gets copied into x\n\n\n\n\n\n\n\n\n1.2.10 Exercise\n\n\n\nIn my_func_example6.py, complete the code in sum_up_to() so that it computes and then returns the sum of numbers from 1 to n (inclusive of 1 and n).\ndef sum_up_to(n):\n    # write your code here\n\nresult = sum_up_to(5)\nprint(result)            # should print 15\nresult = sum_up_to(10)\nprint(result)            # should print 55\n\n\n\n1.2.11 Video\n\nLet’s return to our earlier example and use the padd() function in different ways:\ndef padd(a, b):\n    print('Received values: ', a, b)\n    total = 0\n    if a &gt;= 0:\n        total += a\n    if b &gt;= 0:\n        total += b\n    return total\n\nprint(padd(-5, 6))                   \nx = padd(padd(-5,6), 7)              \nprint(x)                             \nprint(padd(padd(-5,6), padd(5,-6)))  \n\n\n\n\n\n\n1.2.12 Exercise\n\n\n\nType up the above in my_func_example7.py and report what it prints in your module pdf.\n\n\nLet’s examine each of the last three statements:\n\nThe first one:\nprint(padd(-5, 6))\nIn this case:\nThe invocation to padd() occurs first:\nprint(padd(-5, 6))\nThat function executes and returns 6.\nSo, we can think of the result of that as:\nprint( 6 )\nWhich sends 6 to the print() function.\nWhich prints 6.\nNext consider\nx = padd(padd(-5,6), 7)              \nIn this case:\n\nThe innermost padd() is first invoked:\nx = padd( padd(-5,6), 7 )\nThat takes execution into padd() with parameter values padd(-5, 6).\nThe function returns 6, and so, we could think of the result as\nx = padd( 6, 7 )\nThis now results in another invocation to padd() with parameter values padd(6, 7).\nThe function now executes again and returns 13.\nThe result is\nx = 13\n\nFinally, consider the third example:\nprint(padd(padd(-5,6), padd(5,-6)))  \nIn this case:\n\nThere are two innermost invocations:\nprint(padd( padd(-5,6), padd(5,-6) ))  \nThe left one is called first:\nprint(padd( padd(-5,6), padd(5,-6) ))  \nResulting in a return value of 6:\nprint(padd( 6, padd(5,-6) ))  \nThen, the other one is invoked, sending 5,-6 to the function:\nprint(padd( 6, padd(5,-6) ))  \nWhich will cause 5 to be returned:\nprint(padd( 6, 5 ))  \nNow, these results (6 and 5) are sent once again to the third invocation:\nprint( padd( 6, 5 ) )  \nThis returns 11.\nprint( 11 )  \nAnd so 11 gets sent to print, which prints it.\nWhew!"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#multiple-returns-in-a-function",
    "href": "units/unit1/modules/module1.2.html#multiple-returns-in-a-function",
    "title": "Module 1.2: Functions",
    "section": "1.2.4 Multiple returns in a function",
    "text": "1.2.4 Multiple returns in a function\nTake a moment to go back up and quickly glance through the Pythagorean example.\nNow consider this rewrite:\ndef check_pythagorean(a, b, c):\n    if a*a + b*b == c*c:\n        print('In the if-part')\n        return 'yes'\n    else:\n        print('In the else-part')\n        return 'no'\n\nresult = check_pythagorean(3, 4, 5)\nprint(result)\nresult = check_pythagorean(5, 12, 13)\nprint(result)\nresult = check_pythagorean(6, 8, 20)\nprint(result)\n\n\n\n\n\n\n1.2.13 Exercise\n\n\n\nType up the above in my_func_example8.py and report what it prints in your module pdf.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWhen a function executes a return statement, execution exits the function right then and there, even if there’s more code below.\nThus for example, in the first time check_pythagorean() is invoked: \n\n\n\n\n\n\n\n\n\n1.2.14 Exercise\n\n\n\nIn your module pdf, draw such a diagram for the other two function invocations.\n\n\n\n\n\n\n\n\n1.2.15 Exercise\n\n\n\nIn my_func_example9.py, complete the code below so that the function, when given three numbers, identifies the two larger ones and returns their sum.\ndef add_bigger_pair(a, b, c):\n    # Write your code here:\n\nprint(add_bigger_pair(2,3,4))  # Should print 7\nprint(add_bigger_pair(2,3,1))  # Should print 5\nprint(add_bigger_pair(2,1,4))  # Should print 6\n\n\n\n1.2.16 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#parameter-and-argument-names",
    "href": "units/unit1/modules/module1.2.html#parameter-and-argument-names",
    "title": "Module 1.2: Functions",
    "section": "1.2.5 Parameter and argument names",
    "text": "1.2.5 Parameter and argument names\nConsider this example:\ndef subtract(a, b):\n   c = b - a\n   return c\n\nx = 5\ny = 6\nz = subtract(x, y)\n\n\n\n\n\n\nNote\n\n\n\n\nWe refer to a and b as parameters in the definition of the function:\ndef subtract(&lt;b&gt;a, b&lt;/b&gt;):\nWhen function is invoked,\nsubtract(&lt;b&gt;x, y&lt;/b&gt;):\nwe sometimes use the term function arguments for x and y.\n\n\n\nThe names given to parameters have no relation to the names used for arguments:\n\nIn the above case: \nConsider this variation:\ndef subtract(a, b):\nc = b - a\nreturn c\n\na = 5\nb = 6\nc = subtract(a, b)\nThe a,b,c that are the parameter variables are different from the a,b,c variables below: \n\n\n\n\n\n\n\nTip\n\n\n\nIf you aren’t sure, it’s safest to use different names."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#what-can-you-do-with-parameter-variables",
    "href": "units/unit1/modules/module1.2.html#what-can-you-do-with-parameter-variables",
    "title": "Module 1.2: Functions",
    "section": "1.2.6 What can you do with parameter variables?",
    "text": "1.2.6 What can you do with parameter variables?\nGenerally, the purpose of parameter variables is this:\n\nConsider this example:\ndef silly_func(a, b):\n    c = 2*a - b\n    print(c)\n\nsilly_func(3, 4)\nx = 6\nsilly_func(x, 8)\nFrom the point of view of the function, silly_func thinks “Someone is going to put values into my variables a and b, and then I’ll do stuff like calculate and print”.\nFrom the point of view of code that is using the function, as in\nsilly_func(3, 4)\nThis is saying “we’ll set the function’s a parameter to 3, and b parameter to 4, and then let the function do its thing”.\nNow, functions can use its parameter variables just like any other variable and change its value, as in:\ndef crazy_func(p, q):\n    print(p)\n    p = p + 3*q       # We're changing p here\n    print(p)\n    r = p + q\n    print(r)\n\nx = 6\ny = 7\ncrazy_func(x, y)\nBecause the value in x gets copied into the variable p, the value in x does not get changed even though the function changes the value in p.\n\n\n\n\n\n\n\n1.2.17 Exercise\n\n\n\nJust by reading, can you tell what the above program prints? Then, implement in my_func_example10.py and confirm."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#functions-and-lists",
    "href": "units/unit1/modules/module1.2.html#functions-and-lists",
    "title": "Module 1.2: Functions",
    "section": "1.2.7 Functions and lists",
    "text": "1.2.7 Functions and lists\nCan a function receive a list as parameter? Can it return one? Is this useful? Yes, yes, yes.\nLet’s start with a list as parameter:\ndef compute_total(B):\n    total = 0\n    for k in B:\n        total += k\n    return total\n\nA = [1, 3, 5, 7]\nt = compute_total(A)\nprint(t)\n\n\n\n\n\n\n1.2.18 Exercise\n\n\n\nIn your module pdf, trace the execution of the above program, including loop iterations. Type up the above in my_func_example11.py, including a print(k) in the loop to confirm your trace.\n\n\n\n\n\n\n\n\n1.2.19 Exercise\n\n\n\nIn my_even_numbers.py, complete the code in the function below so that the even numbers in a list are printed out:\ndef print_even(A):\n    # Insert your code here\n\nA = [1, 3, 5, 6, 7, 8]\nprint_even(A)\nWrite the function so that the output is:\nFound even:  6\nFound even:  8\nRecall how to use the remainder operator from the previous module (conditionals and loops).\n\n\nNext, let’s look at an example where a list is returned:\ndef build_odd_list(n):\n    L = []\n    for i in range(0, n):\n        k = 2*i + 1\n        L.append(k)\n    return L\n\nprint(build_odd_list(5))\n\n\n\n\n\n\n1.2.21 Exercise\n\n\n\nTrace through the above in your module pdf, then type up in my_odd_list.py to confirm. Include a print(k) in the loop after the append.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nExecution begins with\nprint(build_odd_list(5))\nThis results in: \nOnce the return occurs, we could think of this as:\nprint( [1, 3, 5, 7, 9] )\nThis gets sent to print, which prints.\nOne could make this more explicit: \n\n\n\nNext, let’s look at a list example with multiple returns:\ndef find_first_negative(A):\n    for k in A:\n        if k &lt; 0:\n            # First try print(k) here\n            return k\n            # Then try print(k) here\n    return 0\n\nB = [1, 2, -3, 4, -5, 6]\nC = [1, 2, 3, 4]\n\nprint(find_first_negative(B))\nprint(find_first_negative(C))\n\n\n\n\n\n\n1.2.22 Exercise\n\n\n\nBefore typing this up in my_first_negative.py to confirm, try to trace through the program in your module pdf. That is, use the tracing approach we’ve used before: write out the values of variables and how they change from one iteration to the next. Then, replace the first comment so that you print(k) inside the loop. Explain what you see as a result in your module pdf. Then, move the print statement (still inside the loop) to after the return k statement. What do you observe? Explain in your module pdf.\n\n\n\n\n\n\n\n\n1.2.23 Exercise\n\n\n\nIn my_last_negative.py, modify the above program to find the last negative number (if one exists) in a list. So, after completing the code below\ndef find_last_negative(A):\n    # Insert your code here\n\nB = [1, 2, -3, 4, -5, 6]\nC = [1, 2, 3, 4]\nit should print\n-5\n0"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#returns-that-dont-return-anything",
    "href": "units/unit1/modules/module1.2.html#returns-that-dont-return-anything",
    "title": "Module 1.2: Functions",
    "section": "1.2.8 returns that don’t return anything",
    "text": "1.2.8 returns that don’t return anything\nConsider this program:\ndef print_first_negative(A):\n    for k in A:\n        if k &lt; 0:\n            print('Found: ',k)\n            return \n    print('No negatives found')\n\nB = [1, 2, -3, 4, -5, 6]\nprint_first_negative(B)\nC = [1, 2, 3, 4]\nprint_first_negative(C)\n\n\n\n\n\n\n1.2.25 Exercise\n\n\n\nType up the above in my_first_negative2.py, execute and observe the output. Then, trace through the execution in your module pdf.\n\n\nLet’s point out:\n\nWhenever a return statement is executed in a function, execution exits the function right away.\nWhen a return statement does not return a variable’s value, execution leaves the function but does not give a value back to the invoking code.\nThus the return here:\ndef print_first_negative(A):\n    for k in A:\n        if k &lt; 0:\n            print('Found: ',k)\n            return\n    print('No negatives found')\ndoes not return a value but merely causes execution to leave the function and to back to just after where the function was invoked.\nAlthough it’s not needed, one could return at the end of a non-value-returning function:\ndef print_first_negative(A):\n    for k in A:\n        if k &lt; 0:\n            print('Found: ',k)\n            return\n    print('No negatives found')\n    return\nWhy do we have multiple return’s in a function? Why not always wait until execution reaches the end of a function?\n\nIt is very useful to be able to return from anywhere in a function’s code.\nThe reason is: as soon as the function’s “job” is done (example: finding the first negative), we want to leave the function."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#a-fundamental-difference-between-list-and-basic-parameters",
    "href": "units/unit1/modules/module1.2.html#a-fundamental-difference-between-list-and-basic-parameters",
    "title": "Module 1.2: Functions",
    "section": "1.2.9 A fundamental difference between list and basic parameters",
    "text": "1.2.9 A fundamental difference between list and basic parameters\nConsider this program:\ndef swapint(a, b):\n    temp = a\n    a = b\n    b = temp\n    print(a, b)\n\nx = 5\ny = 6\nswapint(x, y)\nprint(x, y)     # Will this print 5 and 6, or 6 and 5?\n\n\n\n\n\n\n1.2.26 Exercise\n\n\n\nBefore typing up the above in my_swap_int.py, can you guess what the output will be?\n\n\nLet’s explain:\n\nExecution of the program begins with the line\nx = 5\nWhen the function is called soon after: python     swapint(x, y) then execution enters the function with the values in x and y copied into a and b: \nThen, by the time we reach the print statement: \nThus, the values in a and b do indeed get swapped.\nBut this does not affect x and y because they are actually different variables.\n\n\n\n\n\n\n\n1.2.27 Exercise\n\n\n\nIn your module pdf, draw the three boxes for a, b, and temp, at each step in the function’s execution.\n\n\nNow, consider a similar program with lists:\ndef swap_list_first(A, B):\n    temp = A[0]\n    A[0] = B[0]\n    B[0] = temp\n\nX = [1, 3, 5, 7]\nY = [2, 4, 6]\nswap_list_first(X, Y)\nprint(X, Y)\n\n\n\n\n\n\n1.2.28 Exercise\n\n\n\nIn your module pdf, draw the three boxes for a, b, and temp, at each step in the function’s execution.\n\n\nLet’s see what’s going on:\n\nList variables are fundamentally different from numeric variables.\nThink of a list variable has having a reference ID to the actual list contents:\n\nThis is like an “address” in memory.\nIf you have this “address” you can go to the list and do things with it.\nList variables actual store these addresses (which, interestingly, turn out to be numbers).\n\nWe will draw a conceptual diagram to highlight this point: \nThus, when the function starts execution, the “references” in X and Y are copied into A and B.\nThis means A and B refer to the same list contents.\nSo, A[0] is the same as X[0], for example.\nNext, after executing the three lines inside the function but before returning: \nNotice that temp is a regular integer.\n\n\n\n\n\n\n\n1.2.29 Exercise\n\n\n\nIn your module pdf, draw the above diagram after each line in the function, showing how the list contents and temp change with each line of execution.\n\n\nThe key takeaways:\n\nWhen you send number variables to a function, they get copied, and so the function can’t “do” anything to the variables you present as arguments.\nBut if you send a list, a function can change the contents.\nThis means you need to be careful about intent when writing functions that involve larger entities like lists.  (There are other such “grouped data” entities, called objects.)\nIf the intent is to change contents, that’s fine, we should know that.\n\n\n\n\n\n\n\n1.2.31 Exercise\n\n\n\nConsider the following program:\ndef change_int(a):\n    a = a + 1\n\ndef change_list(A):\n    A[0] = A[0] + 1\n\nx = 5\nchange_int(x)\nprint(x)\n\nB = [1, 2, 3]\nchange_list(B)\nprint(B)\nIn your module pdf, trace through the above program, showing boxes for the different variables changing as each line executes. Show these diagrams at the start of each function’s execution and just before each function returns."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#calling-functions-from-functions",
    "href": "units/unit1/modules/module1.2.html#calling-functions-from-functions",
    "title": "Module 1.2: Functions",
    "section": "1.2.10 Calling functions from functions",
    "text": "1.2.10 Calling functions from functions\nThe code inside functions can be like regular code that’s outside functions.\nIn particular, code inside functions can call (invoke) other functions.\nFor example:\ndef increment(a):\n    b = a + 1\n    return b\n\ndef increment_twice(c):\n    d = increment(c)\n    e = increment(d)\n    return e\n\nx = 5\ny = increment_twice(x)\nprint(y)\n\n\n\n\n\n\nNote\n\n\n\n\nThe program starts execution at the line\nx = 5\nThen, when increment_twice(x) is called, we enter the function increment_twice() with the variable c set to 5 (copied from x).\nThe next line in there\nd = increment(c)\nresults in a call to increment() with the value 5 copied into parameter a.\nThen, the code in increment() executes, resulting in 6 being returned.\nThe returned value 6 is stored in d.\nThen increment() is called again with the value in d. (now 6) copied into a.\nThe code in increment() executes resulting in 7 returned.\nExecution continues in the increment_twice() function and the value 7 is stored in e.\nFinally increment_twice()completes execution and returns the value in e, which is 7.\nThis value is stored in y,\nExecution continues from there to the print.\n\n\n\nIn addition, observe the following:\n\nWe can shorten the above code by writing:\ndef increment(a):\n    return a + 1\n\ndef increment_twice(c):\n    return increment(increment(c))\n\nx = 5\ny = increment_twice(x)\nprint(y)\nNotice that one can return the result of an expression:\nreturn a + 1\nIn this case, the calculation is an arithmetic expression.\nOne can also have the result of a function call itself be returned:\ndef increment_twice(c):\n    return increment(increment(c))\nAfter, it’s possible to do this:\nprint( increment(increment(c)) )\nHere, the result of the inner increment()call\nprint( increment(increment(c)) )\nis sent again to increment():\nprint( increment( ... ) )\nIn the same vein, we can, instead of printing, execute a return:\nreturn increment(increment(c))\n\n\n\n\n\n\n\nTip\n\n\n\nyou do NOT have to use such shortcuts. Some shortcuts are an advanced topic and may in fact make your code harder to read, and harder to fix mistakes in.\n\n\n\n\n\n\n\n\n1.2.33 Exercise\n\n\n\nConsider the following program:\ndef decrement(a):\n    return a - 1\n\ndef subtract(a, b):\n    for i in range(0, a):\n        b = decrement(b)\n    return b\n\nprint(subtract(5, 9))\nprint(subtract(3, 13))\nType this up in my_subtraction.py. Then in your module pdf, trace the execution step by step. Draw diagrams showing the changing contents of variables a and b. (This exercise is a bit long, but worth doing because it will help your understanding.)\n\n\n\n1.2.34 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#more-stats-via-programming",
    "href": "units/unit1/modules/module1.2.html#more-stats-via-programming",
    "title": "Module 1.2: Functions",
    "section": "1.2.11 More stats via programming",
    "text": "1.2.11 More stats via programming\nArmed with our new ability to work with functions and lists, we will see how easy it is to compute basic statistics with data.\nBefore we get to that, here’s a small exercise.\n\n\n\n\n\n\n1.2.35 Exercise\n\n\n\nConsider the following program:\ndef find_smallest(A):\n    smallest = A[0]\n    for k in A:\n        if k &lt; smallest:\n            smallest = k\n    return smallest\n\ndata = [-2.3, -1.22, 1.6, -10.5, 1.4, 2.5, -3.32, 11.03, 2, 2, -1.4]\nprint(find_smallest(data))\nType this up in my_find_smallest.py. Then trace through the execution in your module pdf. It’s critical to understand how the variable smallest is changing through the loop, and why the function find_smallest() does in fact identify the smallest value in a list. (Remember: the more negative a number, the smaller. Thus, -10 is less than or “smaller” than -4.)\n\n\nWith that, consider this partially complete program:\ndef find_smallest(A):\n    smallest = A[0]\n    for k in A:\n        if k &lt; smallest:\n            smallest = k\n    return smallest\n\ndef find_largest(A):\n    # Insert your code here:\n\ndef find_span(A):\n    smallest = find_smallest(A)\n    largest = find_largest(A)\n    span = largest - smallest\n    return span\n\ndata = [-2.3, -1.22, 1.6, -10.5, 1.4, 2.5, -3.32, 11.03, 2, 2, -1.4]\nprint('span: ', find_span(data))\n\n\n\n\n\n\n1.2.36 Exercise\n\n\n\nIn my_stats.py complete the above so that the span of the data is computed and printed. This is the difference between the largest and smallest values. Then, use a table (as you have before) to trace through the execution in your module pdf.\n\n\n\n1.2.37 Video\n\nNext, let’s write some (partially complete) code for standard statistics:\nimport math\n\ndef compute_mean(A):\n    # Insert your code here:\n\ndef compute_std(A):\n    mean = compute_mean(A)\n    total = 0\n    for k in A:\n        total += (k-mean)**2\n    std = math.sqrt( total / len(A) )\n    return std\n\ndata = [-2.3, -1.22, 1.6, -10.5, 1.4, 2.5, -3.32, 11.03, 2, 2, -1.4]\nprint('mean =', compute_mean(data))\nprint('standard deviation =', compute_std(data))\n\n\n\n\n\n\nNote\n\n\n\n\nThe mean of a list of numbers is the total (add the numbers up) divided by “how many numbers there are” in the list.\nThe standard deviation is more involved:\n\nConsider data like:\n10, 20, 30, 40, 50\nThis is centered around 30 (mean in this case).\nHere, a different set of data that’s also centered around 30:\n28, 29, 30, 31, 32\nClearly, the second set of data is very bunched up around 30 while the first is more spread out.\nThe standard deviation is a measure (a single number) that rates the “spreadout-ness” of data.\nThe more spread out, the higher the standard deviation.\nTo calculate it, we take the difference of each data from the mean, square it (to make it always positive), then add all of these up.\nThis gives something called the variance, which itself is a fine measure of spreadout-ness.\nHowever, because we’re adding up squared numbers, the variance can become a big number.\nTo bring the measure closer to the “level” of the actual data, we take the square root of the variance: this is the standard deviation.\n\nIf you’ve never seen this before, it’s worth computing by hand with the data above, just so you understand how it looks on paper. Then compare with the results from the program.\n\n\n\n\n\n\n\n\n\n1.2.38 Exercise\n\n\n\nIn my_stats2.py complete the code above. You should get as output, approximately\nmean = 0.1627272727272727\nstandard deviation = 4.955716792313685\n(Real numbers, what can you do?)\n\n\nNext, let’s tackle the more challenging problem of identifying outliers:\n\nTake a closer look at the data:\ndata = [-2.3, -1.22, 1.6, &lt;b&gt;-10.5&lt;/b&gt;, 1.4, 2.5, -3.32, &lt;b&gt;11.03&lt;/b&gt;, 2, 2, -1.4]\nWe see that two data values seem to be far outside the range of the other data.\nSuppose we use the following approach to identifying outliers:\n\nCompute the mean and standard deviation.\nIdentify those data that lie further than two standard deviations away from the mean.\nCall these outliers.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe traditional definition uses three standard deviations, but we’ll stick with two because it makes our example easy to work with.\n\n\nLet’s write a function to do this:\ndef find_outliers(A):\n    mean = compute_mean(A)\n    std = compute_std(A)\n    for k in A:\n        if k &lt; (mean - 2*std):\n            print('Found outlier: ', k)\n        elif k &gt; (mean + 2*std):\n            print('Found outlier: ', k)\n\n\n\n\n\n\n1.2.39 Exercise\n\n\n\nIn my_stats3.py, add the above to your code from the earlier exercise so that the output is:\nmean = 0.1627272727272727\nstandard deviation = 4.955716792313685\nFound outlier:  -10.5\nFound outlier:  11.03"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#a-function-that-calls-itself",
    "href": "units/unit1/modules/module1.2.html#a-function-that-calls-itself",
    "title": "Module 1.2: Functions",
    "section": "1.2.12 A function that calls itself",
    "text": "1.2.12 A function that calls itself\nThis is a somewhat advanced topic (not on any exam or assignment!). We will only present a simple example only so that you see what it’s like.\nConsider this example:\ndef factorial(n):\n    # print(n)\n    if n == 1:\n        return 1\n    else:\n        m = factorial(n-1)\n        return n * m\n\nprint(factorial(5))\nprint(factorial(10))\n\n\n\n\n\n\n1.2.40 Exercise\n\n\n\nType up the above in my_factorial.py. Then, in your module pdf trace through what happens when factorial(5) is called. Remove the # symbol so that the print prints.\n\n\nLet’s point out:\n\nYes, it’s allowed for a function to call itself.\nSuch a function is called a recursive function, and the resulting behavior is called recursion.\nThe above example computes numbers like       1 × 2 × 3 × 4 × 5 × = 120  (This ascending multiplication is called factorial.)\nFor recursion to work, the successive calls to itself have to end so that we don’t get the infinity of barbershop mirrors.\nIn the above case, n eventually becomes 1. In this case, there’s no further call to itself.\nRecursion is hard to understand, and will be featured in later courses after you’ve got more programming under your belt.\nSurprisingly, many problems are solvable elegantly and efficiently using recursion.\nIt is possible to do recursion improperly, in which case a program is set up to recurse forever. In this case, Python will give up after too many recursions.\n\n\n1.2.41 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#incribed-geometric-figures-as-art",
    "href": "units/unit1/modules/module1.2.html#incribed-geometric-figures-as-art",
    "title": "Module 1.2: Functions",
    "section": "2.13 Incribed geometric figures as art",
    "text": "2.13 Incribed geometric figures as art\nOf course we’re going to try and use functions and drawing.\nConsider this program:\nimport math\nfrom drawtool import DrawTool\n\ndt = DrawTool()\ndt.set_XY_range(-1,1, -1,1)\ndt.set_aspect('equal')\n\ndef draw_circle_in_square(side):\n    radius = side/2\n    dt.set_color('r')\n    dt.draw_circle(0,0, radius)\n    return radius\n\ndef draw_square_in_circle(radius):\n    side = math.sqrt(2) * radius\n    dt.set_color('b')\n    dt.draw_rectangle(-side/2, -side/2, side, side)\n    return side\n\nside = 1\ndt.draw_rectangle(-side/2, -side/2, side, side)\n\nn = 5\nfor i in range(n):\n    radius = draw_circle_in_square(side)\n    side = draw_square_in_circle(radius)\n\ndt.display()\n\n\n\n\n\n\n1.2.42 Exercise\n\n\n\nDownload drawtool.py and circle_square.py and run the latter to get \nThen, change n to n=10. Perhaps experiment with colors. Try to read the functions and figure out, not so much the calculation, as what they’re doing.\n\n\nAt first, this looks like a simple exercise in geometric art, or a depiction of the “evil eye” but there’s more to it:\n\nNotice the construction:\n\nWe start with a square.\nThen we inscribe the biggest possible circle that’ll fit inside that square.\nNow we find the biggest possible square that’ll fit inside the recently drawn circle.\nThen the square inscribed in that circle, and so on.\n\nInstead of just using circles and squares, one can use a square first, then a pentagon, then a hexagon, and so on.\nThe result is something that Kepler worked on a long time ago. See this article\nThe historical significance is this:\n\nEver since the Greeks, polygons and circles have held special significance.\nSo, something like this had an almost religious significance.\nKepler then used a similar idea for solids to expound (an entirely wrong) theory of planetary motion.\nTo his credit, he realized he was wrong when shown higher quality data (from Tycho Brahe), and used the data to fit ellipses.\nThis was the beginning of the modern understanding of planetary motion, later mathematically solved by Isaac Newton."
  },
  {
    "objectID": "units/unit1/modules/module1.2.html#when-things-go-wrong",
    "href": "units/unit1/modules/module1.2.html#when-things-go-wrong",
    "title": "Module 1.2: Functions",
    "section": "1.2.14 When things go wrong",
    "text": "1.2.14 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n1.2.43 Exercise\n\n\n\ndef square_it(x):\n    y = x * x\n\na = 5\nb = square_it(a)\nprint(b)\nIdentify and fix the error in my_error1.py.\n\n\n\n\n\n\n\n\n1.2.44 Exercise\n\n\n\ndef bigger(x,y)\n    if x &gt; y:\n        return x\n    else:\n        return y\n\nprint(bigger(4,5))\nIdentify and fix the error in my_error2.py.\n\n\n\n\n\n\n\n\n1.2.405Exercise\n\n\n\ndef find_smallest(A):\n    smallest = 1000\n    for k in A:\n        if k &lt; smallest:\n            smallest = k\n    return smallest\n\nB = [2, 1, 4, 3]\nprint(find_smallest(B))\nDoes the above program work? What is the reasoning behind the line smallest = 1000? What would go wrong if you removed it altogether? Can you create a list (change the data in B) which will cause the function to fail to find the smallest number. Fix the issue in my_error3.py.\n\n\n Previous Module: Module 1.1 Next Module: Module 1.3"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html",
    "href": "units/unit1/modules/module1.1.html",
    "title": "Module 1.1: Conditionals",
    "section": "",
    "text": "Home » Unit 1 » Module 1.1"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#objectives",
    "href": "units/unit1/modules/module1.1.html#objectives",
    "title": "Module 1.1: Conditionals",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nEvaluate Boolean (pronounced: BOO-lee-unn) expressions.\nConstruct Boolean expressions from English descriptions.\nMentally execute (trace) code with conditionals: that is: if, if-else, and if-multi-else statements.\nWrite and debug code with conditionals.\nWrite and debug code with conditionals inside loops.\nIdentify new syntactic elements related to the above."
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#a-simple-example",
    "href": "units/unit1/modules/module1.1.html#a-simple-example",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.0 A simple example",
    "text": "1.1.0 A simple example\nConsider this program:\nx = 5\ny = 4\n\nif x &gt; y:\n    print('Hey, x is bigger')\n\nprint(\"OK, we're done\")\n\n\n\n\n\n\n1.1.1 Exercise\n\n\n\nIn my_ifexample.py, type up the above and examine the output. Then, just below the print with ‘Hey’ (and indented 4 spaces) add another print to print anything. Then, change the value of y to 6 and report the output in module0.pdf. Submit the program with these modifications.\n\n\nLet’s explain:\n\nFirst, observe: \nNow, at the moment the if-statement executes, the condition is evaluated:  If the condition is true then the code that’s indented below the if-statement executes.\nConsider what happens when y is 6: \n\n\n\n\n\n\n\n1.1.2 Exercise\n\n\n\nConsider this program:\ns = 0\nfor i in range(6):\n    s = s + i\n\nif s &lt; 15:\n    print('Less than 15')\n\nprint('Done')\nTry to mentally execute (trace its execution in your mind) and predict the output before typing it up in my_ifexample2.py to confirm."
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#if-else",
    "href": "units/unit1/modules/module1.1.html#if-else",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.1 if-else",
    "text": "1.1.1 if-else\nThink of else as if’s occasional partner.\nConsider this example:\nx = 5\ny = 4\n\nif x &gt; y:\n    print('Hey, x is bigger')\nelse:\n    print('Who said x is bigger?')\n    print('In fact, y is bigger')\n\nprint(\"OK, we're done\")\n\n\n\n\n\n\n1.1.3 Exercise\n\n\n\nType up the above in my_ifexample3.py and examine the output. Then, change the value of y to 6. What is the output? Change y to 5. What is the output? Report these in your module pdf.\n\n\nLet’s point out:\n\nWhen x is indeed larger than y, the code in the if-body executes: \nWhen the if-condition evaluates to false: \nWhat happens when x is 5 and y is 5? \n\nBecause some of these arrows might be difficult to follow, let’s emphasize some blocks (lines) of code:\n\nFirst consider when x is larger than y: \nAnd when y is larger than x:"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#if-elif-else",
    "href": "units/unit1/modules/module1.1.html#if-elif-else",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.2 if-elif-else",
    "text": "1.1.2 if-elif-else\nConsider this variation:\nx = 5\ny = 5\n\nif x &gt; y:\n    print('Hey, x is bigger')\nelif y &gt; x:\n    print('Who said x is bigger?')\n    print('In fact, y is bigger')\nelse:\n    print('Actually, they are equal')\n\nprint(\"OK, we're done\")\n\n\n\n\n\n\n1.1.4 Exercise\n\n\n\nType up the above in my_ifexample4.py and examine the output. Then, try y=6 and y=4. Report results in your module pdf.\n\n\nLet’s explain:\n\nFirst, consider the case x=5, y=5: \nNow consider x=5, y=4: \nNext: x=5, y=6: \n\nOne can have as many elif sections as one would like, for example:\nx = 3\n\nif x == 1:\n    print('one')\nelif x == 2:\n    print('two')\nelif x == 3:\n    print('three')\nelif x == 4:\n    print('four')\nelse:\n    print('big')\nThink of the whole thing as a giant if-statement:  In the above case, when x is 3, the execution path through the giant if-statement is: \n\n\n\n\n\n\n1.1.5 Exercise\n\n\n\nType up the above in my_ifexample5.py. Then, try each of x=1, x=2, x=4, x=5. Draw the execution pathways (similar to the picture above) for each case in your module pdf.\n\n\nConsider this program:\nx = 5\ny = 4\nz = 3\n\nif x &gt; y:\n    print('Hey, x is bigger')\n\nif x &gt; z:\n    print('x is bigger than z')\n    print('So, x must be the largest')\n\n\n\n\n\n\n1.1.6 Exercise\n\n\n\nType up the above in my_ifexample6.py. Try y = 6. Explain why it does not work. Then try to alter the program without changing the print-statements so that it works in all cases for possible values of x,y, and z. That is, whichever of the above print-statements gets printed correctly reflects the values of x, y and z.\n\n\n\n1.1.7 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#nested-conditionals",
    "href": "units/unit1/modules/module1.1.html#nested-conditionals",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.3 Nested conditionals",
    "text": "1.1.3 Nested conditionals\nConsider this program:\na = 3\nb = 4\nc = 5\n\nif a &lt; b:\n    if a &lt; c:\n        print('a is the smallest')\n    else:\n        print('a is not the smallest')\n\nprint('Done')\nThis is an example of a nested conditional (nested if):\n\nFirst, examine the indented structure: \nThe flow of execution: \n\nConsider this variation:\na = 3\nb = 4\nc = 5\n\nif a &lt; b:\n    if a &lt; c:\n        print('a is the smallest')\n    else:\n        print('a is not the smallest')\n    print('We know a is less than b')\nelse:\n    print('We know a is not less than b')\n\nprint('Done')\n\n\n\n\n\n\n1.1.8 Exercise\n\n\n\nType up the above in my_nestedif.py. Draw the flow of execution for the following three cases: (1) when a=3, b=4, c=5; (2) when a=3, b=4, c=2; (3) when a=6, b=4, c=5.\n\n\n\n\n\n\n\n\n1.1.9 Exercise\n\n\n\nIn my_smallest_of_three.py, modify the above program so that it prints out, appropriately, one of “a is the smallest”, “b is the smallest” or “c is the smallest”, depending on the actual values of a, b, and c. Try different values of these variables to make sure your program is working correctly.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nA numeric variable can be: strictly less, less than or equal to, strictly greater, greater than or equal to, or equal to another variable.\nAccordingly, the different types of less/greater comparisons are:\na &lt; b      # Strictly less than, as when a=3, b=4\na &lt;= b     # Could be less (a=3, b=5), could be equal (a=3, b=3) \na &gt; b      # Strictly greater (a=3, b=2)\na &gt;= b     # Could be greater (a=3, b=1), could be equal (a=2, b=2)"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#combining-conditions",
    "href": "units/unit1/modules/module1.1.html#combining-conditions",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.4 Combining conditions",
    "text": "1.1.4 Combining conditions\nConsider this program:\nx = 5\ny = 5\nz = 5\n\nif x == y and y == z:\n    print('All three are equal')\n\n\n\n\n\n\nNote\n\n\n\n\nThe first thing to point out is the == operator:\n\nBecause we’ve been using the equals operator for assigning values to variables, we need something else to test for equality.\nThe equality operator in Python is == as in:\nif x == y and y == z:\nAlas, the problems with limited keyboard symbols!\n\nImportant: the difference between = and == is very important to remember. It’s easy to make a mistake one forget.\nThe if-statement combines two conditions:\nif x == y and y == z:\nThe combining occurs with the Boolean operator and:\nif x == y and y == z:\nWe can clarify the parts and combination thereof using parens:\nif (x == y) and (y == z):\nThe two parts are often called clauses:\n\nFirst clause (x == y):\nif (x == y) and (y == z):\nSecond clause (y == z):\nif (x == y) and (y == z):\nYou could have many more clauses.\n\nThe “and” operator works like this: \nBoolean is pronounced “BOO lee unn”.\nA Boolean operator takes expressions and computes to either true or false.\n\n\n\nLet’s go back to finding the smallest of three numbers using conditionals:\na = 3\nb = 4\nc = 5\n\n# Fill in code here ... \n\n\n\n\n\n\n1.1.11 Exercise\n\n\n\nIn my_smallest_of_three2.py, fill in code to identify which of the three variables has the smallest value, depending on the actual values of a, b, and c. Use if-statements with multiple clauses. Try different values of these variables to make sure your program is working correctly.\n\n\n\n1.1.12 Video\n\nAs the counterpart to the and operator, there is the or operator:\na = -2.718\n\nif (a &lt;= 0) or (a &gt;= 1):\n    print('a is not between 0 and 1')\n\n\n\n\n\n\n1.1.13 Exercise\n\n\n\nType up the above in my_boolean2.py. Then try a=0.5.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe have shown how to write “less than or equal to” using =\n\nSo, now we can add “equals” and “not equals” to the numeric comparisons:\n    a &lt; b      # Strictly less than, like a=3 &lt; b=4\n    a &lt;= b     # Could be less, could be equal (a=3, b=3)\n    a &gt; b      # Strictly greater (a=3, b=2)\n    a &gt;= b     # Could be greater, could be equal \n    a == b     # Exactly equal\n    a != b     # Not equal\nFor the or operator to evaluate to true, any one or both of the two expressions needs to be true.\nConsider:\na = 3\nb = 4\nif (a &lt; 10) or (b &lt; 10):\n    print('One or both of them is less than 10')\n\nIn this case both will evaluate to true, and so the print statement executes.\nSuppose we made a=3, b=11, the print statement will execute.\nSuppose we change a=11, b=3, the print statement will execute.\nBut if a=11, b=12, the or fails (both clauses are false), and the print won’t execute.\n\nIncidentally, let’s replace or with and in the above case, and see what we get:\na = 3\nb = 4\nif (a &lt; 10) and (b &lt; 10):\n    print('Both of them are less than 10')\nIn this case, both sub-conditions are satisfied, and so the whole if-condition is satisfied, which means the print will execute.\nBut if we had\na = 3\nb = 4\nif (a &lt; 10) and (&lt;b&gt;b &gt; 10&lt;/b&gt;):\n    print('Both of them are less than 10')\nIn this case, the second comparison fails, and the print won’t occur.\nWhereas if we had or:\na = 3\nb = 4\nif (a &lt; 10) &lt;b&gt;or&lt;/b&gt; (&lt;b&gt;b &gt; 10&lt;/b&gt;):\n    print('One or both of them is less than 10')\nHere, it’s enough that a is less than 3, and so the print executes even though “b greater than 10” fails.\n\n\n\nNext, let’s look at the NOT operator (written with !):\nx = 5\ny = 6\nz = 7\n\nif (x != y) and (x != z):\n    print('x is different from y and from z')\nHere, read != as “not equals”.\n\n\n\n\n\n\n1.1.14 Exercise\n\n\n\nType up the above in my_boolean3.py, then change z to be 6 (same as y). What do you observe?\n\n\nOne can combine any number of and’s, for example:\nx = 5\ny = 6\nz = 7\n\nif (x != y) and (x != z) and (y != z):\n    print('x, y, z are all different')\nThe difference between != and not\n\nWe should read != as “not equals” just as we read == as “equals”.\nThere is another operator called not, which applies to Boolean expressions, as we’ll see next.\n\nThe not operator\n\nOne can apply the not operator to groups of clauses using additional parens:\nx = 8\n\nif not ( (x == 5) or (x == 6) ):\n    print('x is neither 5 nor 6')\nHere, not is asking that whatever it applies to be false.\nThus, consider the expression\nif not ((x == 5) or (x == 6)):\nIn this case, x is 8. So, neither of (x == 5) nor (x == 6) is true.\nThus, the whole expression ( (x == 5) or (x ==6) ) is false.\nWhich means not ( (x == 5) or (x ==6) ) evaluates to true.\nTherefore, the print executes.\n\n\n\n\n\n\n\n1.1.15 Exercise\n\n\n\nSuppose integer variables a,b,c,d,e have values a=1, b=1, c=3, d=4, e=5. Consider the following three expressions:\n( (a &lt;= b) and (c+d &gt; e) and (d &gt; 1) )\n\n( (a &gt; c) or ( (c+1 &lt; e) and (c-b &gt; a) ) )\n\nnot ( (b == d-c) and (a &gt; b) or (c &lt; d) )\nTry to evaluate each expression by hand. Then, in my_boolean4.py, write up each of these in an if-statement to see if the result matches with your hand-evaluation.\n\n\n\n\n\n\n\n\n1.1.16 Exercise\n\n\n\nIn my_boolean5.py, write a program that begins with\na = -3\nb = -4\nand uses conditionals to print out the absolute difference between the two numbers. In the above case, the difference is 1. In the case of a=3, b=4, the difference is also 1. When a=-3, b=4, the difference is 7.\n\n\n\n\n1.1.17 Video"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#conditionals-and-loops",
    "href": "units/unit1/modules/module1.1.html#conditionals-and-loops",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.5 Conditionals and loops",
    "text": "1.1.5 Conditionals and loops\nLet’s write a program to loop through integers and print only the even numbers:\nn = 10\nfor i in range(1, n+1):\n    if i % 2 == 0:\n        print(i, 'is even')\n\n\n\n\n\n\n1.1.18 Exercise\n\n\n\nIn your module pdf, trace through the iterations in the above program. Then, in my_oddeven.py, modify the above program so that for every number between n and 1, going backwards, the program prints whether it’s even or odd, as in:\n10 is even\n9 is odd\n8 is even\n7 is odd\n6 is even\n5 is odd\n4 is even\n3 is odd\n2 is even\n1 is odd"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#conditionals-and-lists",
    "href": "units/unit1/modules/module1.1.html#conditionals-and-lists",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.6 Conditionals and lists",
    "text": "1.1.6 Conditionals and lists\nSuppose we have a list of numbers, representing daily profits (sometimes negative, sometimes positive) and we only want to add up the positive numbers:\nearnings = [-5, 2, 3, -9, 12, 4, -30]\ntotal = 0\nfor k in earnings:\n    if k &gt;= 0:\n        total += k\n\nprint('Total profit =', total)\n\n\n\n\n\n\n1.1.20 Exercise\n\n\n\nTrace through the values of total and k in your module pdf.\n\n\n\n\n\n\n\n\n1.1.21 Exercise\n\n\n\nGiven a list like\nA = [-5, 2, 4, -9, 12, 13, -30, -21, -20]\nwe see that 12,13 and -21,-20 are pairs of consecutive numbers. Write a program called my_consecutive.py, with loop and a conditional to identify such consecutive pairs and print them. For the above list, the output should be:\nConsecutive pair found: 12 13\nConsecutive pair found: -21 -20\n\n\nNext, let’s write a program that asks the user to enter a number that we then check is in a list of numbers:\n# The list of numbers:\nA = [-5, 2, 4, -9, 12, 13, -30]\n\n# Receive what the user types in (as a string):\nuser_str = input('Enter an integer: ')\n\n# Convert string to integer:\nk = int(user_str)\n\n# Check whether in the list:\nif k in A:\n    print(k,'is in the list')\nelse:\n    print(k,'is not in the list')\n\n\n\n\n\n\nNote\n\n\n\nThe in operator checks member in the list:\nif k in A:\n\n\n\n\n\n\n\n\n1.1.23 Exercise\n\n\n\nSuppose you are given two lists like\nA = [-5, 2, 4, -9, 12, 13, -30, -21, -20]\nB = [2, -9, 11, 16, 13]\nNotice that some elements of A (like 2) also exist in B.In my_twolist.py, use the list membership idea to print those elements of A that are also in B. For the above example, the output should be:\n2 in A also found in B\n-9 in A also found in B\n13 in A also found in B"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#more-examples-with-lists",
    "href": "units/unit1/modules/module1.1.html#more-examples-with-lists",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.7 More examples with lists",
    "text": "1.1.7 More examples with lists\nConsider the following program that aims to find duplicates in a list:\nA = [2, 9, 2, 6, 4, 3, 3, 2]\nfor k in A:\n    if k in A:\n        print('Duplicate found:', k)\nIn the list, we can see that 2 occurs thrice, and 3 occurs twice. Both should be listed as duplicates. Is this the case?\n\n\n\n\n\n\n1.1.25 Exercise\n\n\n\nTrace through the iterations in the above program and explain why it does not work.\n\n\nNow consider this variation:\nA = [2, 9, 2, 6, 4, 3, 3, 2]\nfor i in range(len(A)-1):\n    for j in range(i+1, len(A)):\n        if A[i] == A[j]:\n            print('Duplicate found:', A[i])\n\n\n\n\n\n\n1.1.26 Exercise\n\n\n\nTrace through the iterations in the above program and explain the output. Why does the inner loop start with i+1?"
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#some-stats-via-programming",
    "href": "units/unit1/modules/module1.1.html#some-stats-via-programming",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.8 Some stats via programming",
    "text": "1.1.8 Some stats via programming\nLet’s now apply our practice with conditionals to solve some problems in probability and statistics.\nFor example: Suppose I toss a coin 4 times and observe the face that’s up. What is the probability that I get all “tails” (not one toss shows “heads”).\nLet’s do this in steps.\nFirst, let’s write a program to toss a coin 4 times\nimport random\n\ncoin = ['heads', 'tails']\nfor i in range(4):\n    toss = random.choice(coin)\n    print(toss)\n\n\n\n\n\n\n1.1.28 Exercise\n\n\n\nType up the above in my_cointosses.py and run it a few times to see what you get.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe have made a list of strings:\ncoin = ['heads', 'tails']\nPython has a useful way to randomly select a member of a list:\ntoss = random.choice(coin)\nAlternatively, we could have written:\ntoss = random.choice(['heads','tails'])\nand avoided defining coin.\n\n\n\nNext, instead of printing the results, let’s count the number of heads observed:\nimport random\n\ncount = 0\nfor i in range(4):\n    toss = random.choice(['heads', 'tails'])\n    if toss == 'heads':\n        count = count + 1\n\nprint('Number of heads', count)\n\n\n\n\n\n\n1.1.29 Exercise\n\n\n\nType up the above in my_cointosses2.py and run it a few times to see what you get.\n\n\n\n\n\n\n\n\nNote\n\n\n\nObserve how the string that’s randomly selected from the list is compared against ‘heads’:\nif toss == 'heads':\n    count = count + 1\n\n\nNext, what we need to do is repeat the 4-coin toss many times:\n\nSuppose we call 4-coin tosses a single trial.\nClearly, if we ran a single trial and obtained 1 heads (count=1) then, could we conclude that the probability of getting all-4-tails is zero?\nWhat we need to do is run a large number of trials and record in how many trials we get a run of 4-tails.\nWe’ll use the term “success” to identify a trial in which we get all-4-tails.\nLet’s examine the code:\n\nimport random\n\ntrials = 10\nsuccesses = 0\nfor i in range(trials):\n    # Count number of heads in 4 tosses:\n    count = 0\n    for i in range(4):\n        toss = random.choice(['heads', 'tails'])\n        if toss == 'heads':\n            count = count + 1\n\n    # If the count is zero, that's a success\n    if count == 0:\n        successes += 1\n\n# Ratio of successes to trials:\nprobability = successes / trials\nprint('probability =', probability)\n\n\n\n\n\n\n1.1.30 Exercise\n\n\n\nType up the above in my_cointosses3.py and run it a few times to see what you get. Then increase the number of trials to 100000 and see. The theoretical answer is 0.0625 (approximately 6% chance there’s no heads in 4 tosses).\n\n\n\n\n\n\n\n\n1.1.31 Exercise\n\n\n\nIn my_cointosses4.py, write a program to run a large number of trials of the following experiment: toss a coin 10 times and record a success if you get an equal number of heads and tails.\n\n\nNow let’s solve a problem with that other favorite manner of generating chance: dice\nWe’ll roll two dice and add the numbers face up. We want to ask: what are the chances we get 7 (when added up)?\nHere’s the program:\nimport random\n\npossible_outcomes = [1,2,3,4,5,6]\ntrials = 100000\nsuccesses = 0\nfor i in range(trials):\n    roll1 = random.choice(possible_outcomes)\n    roll2 = random.choice(possible_outcomes)\n    if roll1 + roll2 == 7:\n        successes += 1\n\nprobability = successes / trials\nprint('probability =', probability)\n\n\n\n\n\n\n1.1.33 Exercise\n\n\n\nType up the above in my_dice.py and see what you get, reporting in your module pdf. Is there a number other than 7 for which the probability is higher?\n\n\nLet’s also look at how one can get Python to randomly generate real numbers, for example:\nimport random\n\ntrials = 100\ntotal = 0\n\nfor i in range(trials):\n    x = random.uniform(5, 10)\n    print(x)\n    total += x\n\nprint('mean =', total/trials)\n\n\n\n\n\n\nNote\n\n\n\n\nBy using\nx = random.uniform(5, 10)\nwe can generate a random real number between 5 and 10.\nIn the above program we are generating many such numbers and calculating their average.\n\n\n\n:::{.callout-caution appearance=“simple” icon=false title=“1.1.34 Exercise”} Type up the above in my_uniform.py, then increase the number of trials, and see what you get as the average, reporting in your module pdf. What is the average when you generate numbers between 25 and 30 and how does that compare with the average of the numbers 25 and 30? Explain why this should make sense. ::\nBefore you head off to Vegas with your Python programs, let’s point out:\n\nYou can use programming to explore ideas in probability and statistics, and solve real problems as well.\nIt is an exciting way to learn stats that we will have more to say about later."
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#algorithmic-art",
    "href": "units/unit1/modules/module1.1.html#algorithmic-art",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.9 Algorithmic art",
    "text": "1.1.9 Algorithmic art\nLet’s now use what we’ve learned to explore the notion of how computers can be programmed to generate abstract art.\nIn our first example, we’ll draw lines from one border of a square to another: \nLet’s describe the main idea via some pseudocode:\n\nIn a loop we’ll generate:\nSet up an initial x1,y1 and x2,y2\nfor i in ...\n    Pick a random color\n    Draw a line from x1,y1, y2,y2\n    Make the current endpoint the start of the next line:\n    x1 = x2\n    y1 = y2\n    Pick a random border\n    Now pick a new random point on the next border\nWhen we pick a border, we’ll need to figure out the coordinates.\n\n\n\n\n\n\n\n1.1.35 Exercise\n\n\n\nDownload conditional_art.py and drawtool.py. Try it out and then examine the code to confirm that it follows the pseudocode. Try different values of n. Can you change the choices of randomly chosen colors to improve the result? Does it look good with just two colors? Next, starting with Kandinsky, find an example of abstract art that you think might be considered an analogue in the history of art. Include a screenshot of your improved art, and the historical painting in your module pdf.\n\n\nNext, we’ll explore an interesting question:\n\nThink of random art at one end of a spectrum.\nAnd highly-structured geometry at the other end, generated by an algorithm.\nThe question: can we adjust a “knob” that let’s us generate a mix? And is that more aesthetic?\n\n\n\n\n\n\n\n1.1.36 Exercise\n\n\n\nDownload conditional_art2.py. Try out different values (between 0 and 1) of the structure parameter, for example 0.9 and 0.1. Is there a value that provides an aesthetic mix? Try different n. Make changes to the code and submit a screenshot of the result."
  },
  {
    "objectID": "units/unit1/modules/module1.1.html#when-things-go-wrong",
    "href": "units/unit1/modules/module1.1.html#when-things-go-wrong",
    "title": "Module 1.1: Conditionals",
    "section": "1.1.10 When things go wrong",
    "text": "1.1.10 When things go wrong\nIn each of the exercises below, first try to identify the error just by reading. Then type up the program to confirm, and after that, fix the error.\n\n\n\n\n\n\n1.1.37 Exercise\n\n\n\nx = 5\ny = 6\nif x &lt; y\n    print('x is less than y')\nIdentify and fix the error in my_error1.py.\n\n\n\n\n\n\n\n\n1.1.38 Exercise\n\n\n\nx = 5\ny = 6\nif x !&lt; y:\n    print('x is not less than y')\nIdentify and fix the error in my_error2.py.\n\n\n\n\n\n\n\n\n1.1.40 Exercise\n\n\n\na = 2.5\n\n# See whether a lies between 0 to 1, or 1 to 2, \n# or something else\nif (a &gt; 0) and (a &lt; 1):\n    print('between 0 and 1')\nelse if (a &gt; 1) and (a &lt; 2):\n    print('between 1 and 2')\nelse:\n    print('something else')\nIdentify and fix the error in my_error4.py.\n\n\n Previous Module: Module 1.0 Next Module: Module 1.2"
  },
  {
    "objectID": "units/unit0/assignments/assignment2-solution.html",
    "href": "units/unit0/assignments/assignment2-solution.html",
    "title": "Assignment 2: Problem Solving Example",
    "section": "",
    "text": "Home » Unit 0 » Assignment 2 » Problem Solving\n\nWith a challenging problem, what is often hardest is getting started. Where to begin?\nLet’s start by examining the output more closely: \nAt this point, it’s important NOT to think about coding details.\nThis is a critically useful strategy that deserves some explanation:\n\nThe type of thinking you do when solving a problem at the higher level is different from the kind of nitpicky-language-level detail during coding.\nExperience shows that it’s best to avoid doing both simultaneously.\nIf you like analogies:\n\nIt’s best to develop an outline of an essay before focusing on sentences.\nDo the prep (chopping, organizing) before the actual cooking.\n\n\nSo now, let’s just think high level but a little code-like:\n\nWe call this algorithmic thinking.\nSince there are 10 lines, we could say “we’re doing something 10 times” (each time slightly differently).\nIn code-like structure, called pseudcode:\nfor i going from 1 to 10\n    figure out and print the i-th line\nIt’s worth staring at the above for a few minutes. We’ll point out that:\n\nThis is NOT actual code but puts structure to the thought “we’re doing something 10 times”\nThe high level structure will later become an actual for-loop.\nPseudocode doesn’t get hung up on language minutiae like semi-colons. All it needs to do is outline the main idea, like a sketch.\n\n\nNext, if we could somehow figure out the last letter in each line, we’d be in good shape, because:\nfor i going from 1 to 10\n    figure out the last letter in line i\n    print from z down to that last letter\nWe need to figure out the last letter in the i-th line:\n\nOne problem: i is an integer.\nBut … recall the connection between integers and characters?\nTo go from letter to number:\nk = ord('a')       # k will turn out to have 97\nTo go from number to letter:\nletter = chr(97)   # letter will turn out to have 'a'\nSo, now let’s ask: how do we get the letter that’s i spots behind ‘z’ in the alphabet?\n\nLet’s first get the number (integer) corresponding to the letter ‘z’\nk = chr('z')\nSo, the number corresponding to the letter that’s i spots behind ‘z’ must be\nk = chr('z')\nj = k - i       # i spots behind (or less)\nThis might be easier to see in a picture: \nLet’s convert that to a letter:\nk = chr('z')\nj = k - i\nletter = chr(j) # the letter i spots behind\nThis can be printed.\n\n\nLet’s summarize what we have so far in pseudocode:\nfor i going from 1 to 10\n    k = chr('z')\n    # the number of the letter i spots behind\n    j = k - i\n    Now print all the letters corresponding to the numbers from k to j\n\nClearly, we want to print every letter corresponding to the numbers between k and j.\nThis means an inner for-loop because we’re iterating from k to j.\nObserve that j is smaller than k and so we have to decrement in this inner for-loop.\nThus, we can revise our pseudocode as:\nfor i going from 1 to 10\n    k = chr('z')\n    # the number of the letter i spots behind\n    j = k - i\n    for n starting at k and going down to j\n        get the letter corresponding to n and print it\nFinally, let’s try and fill in the missing pieces:\nfor i in range(1, 10):\n    k = chr('z')\n    j = k - i\n    for n in range(k, j, -1):\n        c = chr(n)\n        print(c)\n\n\nA2.1 Exercise: Write up the above in my_char_problem.py. What do you notice?\n\n\nA2.2 Exercise: We deliberately left in two unaddressed problems above. Fix the problems in my_char_problem2.py."
  },
  {
    "objectID": "units/unit0/assignments/assignment1-solution.html",
    "href": "units/unit0/assignments/assignment1-solution.html",
    "title": "Assignment 1: Problem Solving Example",
    "section": "",
    "text": "Home » Unit 0 » Assignment 1 » Problem Solving\n\nWith a challenging problem, what is often hardest is getting started. Where to begin?\nLet’s start by examining the output more closely: \nLet’s try to get the top half of the arrowhead first:\n\nAt first, let’s not worry about the details of the start/end of loops.\nAs a “sketch” (not real code) we could write:\nfor i in range(... to be determined ...):\n    # Print i *'\nNext, examine the problem of printing i asterisks on a single line.\nIf we just had print, say, 7 asterisks on a line, could we write a for-loop to do that?\nDoes this sketch work?\nfor j in range(... something to do with 7 ...):\n    print('*')\nNow let’s work out the range: we want to run from either 1 through 7 (inclusive) or from 0 through 6.\nSuppose we pick the 0 through 6 option and write:\nfor j in range(0,7):\n    print('*')\nAt this point we can try this and see what it does.\n\n\nA1.1 Exercise:\nWrite up the above in my_demo_problem1.py. What went wrong? Explain in your assignment1.pdf.\n\nNow let’s generalize to printing a single line of i asterisks:\nfor j in range(0,i):\n    print('*', end='')\nNext, we can use this as our inner loop in the overall top-half sketch:\nfor i in range(... to be determined ...):\n    # Print i *'s\n    for j in range(0,i):\n        print('*', end='')\nNow let’s determine the range of i (which we might get wrong the first try, but can fix easily).\nWe sense that the limit is 10. Could the following work?\nfor i in range(1, 10):\n    # Print i *'s\n    for j in range(0,i):\n        print('*', end='')\nA1.2 Exercise:\nWrite up the above in my_demo_problem2.py. What went wrong? Explain in your assignment1.pdf.\nLet’s fix the issue. We need to get to a new line every time the inner loop completes.\nDoes this work?\nfor i in range(1, 10):\n    # Print i *'s\n    for j in range(0,i):\n        print('*', end='')\n        print()\n\n\n\nA1.3 Exercise:\nWrite up the above in my_demo_problem3.py. What went wrong?\n\nNext, we’ll fix and write:\nfor i in range(1, 10):\n    # Print i *'s\n    for j in range(0,i):\n        print('*', end='')\n    print()\nDoes this work?\n\n\n\nA1.4 Exercise:\nWrite up the above in my_demo_problem4.py. What went wrong?\n\nWe now have the solution to the top half:\nfor i in range(1, 11):\n    # Print i *'s\n    for j in range(0,i):\n        print('*', end='')\n    print()\nNext, let’s tackle the bottom half:\nAgain, we see that each particular line prints a number of *’s.\nAs long as we can figure out how many are needed in each line, we can reduce each line by 1.\nThat suggests an outer loop that starts big and grows small.\nLet’s sketch this out as:\n# Code for top half here ...\n\n# Code for bottom half:\nfor i in range(... to be determined ...):\n    # Print i *'\nBut we already know how to print i *’s because we solved that in the top half:\n# Code for top half here ...\n\n# Code for bottom half:\nfor i in range(... to be determined ...):\n    # Print i *'\n    for j in range(0,i):\n        print('*', end='')\n    print()\nSo all that’s left is to determine the range of i so that it starts at 10 and goes down to 1.\nSince going down in a range requires a negative step, we could write something like\nfor i in range(10, 1, -1):\nClearly, we want to start at 10. But should the range end with 1 or 0? We’ll leave this unanswered for now.\nLet’s put it all together:\n# Code for top half:\nfor i in range(1, 11):\n    for j in range(0, i):\n        print('*', end='')\n    print()\n\n# Code for bottom half:\nfor i in range(10, 1, -1):\n    for j in range(0, i):\n        print('*', end='')\n    print()\n\n\n\nA1.5 Exercise:\nWrite up the above in my_demo_problem5.py. Did it work? Submit your final version in my_arrowhead.py."
  },
  {
    "objectID": "units/unit0/guides/anaconda-mac.html",
    "href": "units/unit0/guides/anaconda-mac.html",
    "title": "Anaconda and Spyder Installation Guide for macOS",
    "section": "",
    "text": "This guide will lead you through the process of installing Anaconda, a popular Python distribution, on your macOS computer. Anaconda provides a convenient way to manage Python packages and environments, and it includes Spyder, a powerful IDE for scientific computing."
  },
  {
    "objectID": "units/unit0/guides/anaconda-mac.html#introduction",
    "href": "units/unit0/guides/anaconda-mac.html#introduction",
    "title": "Anaconda and Spyder Installation Guide for macOS",
    "section": "",
    "text": "This guide will lead you through the process of installing Anaconda, a popular Python distribution, on your macOS computer. Anaconda provides a convenient way to manage Python packages and environments, and it includes Spyder, a powerful IDE for scientific computing."
  },
  {
    "objectID": "units/unit0/guides/anaconda-mac.html#prerequisites",
    "href": "units/unit0/guides/anaconda-mac.html#prerequisites",
    "title": "Anaconda and Spyder Installation Guide for macOS",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you begin, make sure you have the following:\n\nA macOS computer.\nAn internet connection.\nAdequate disk space for the installation."
  },
  {
    "objectID": "units/unit0/guides/anaconda-mac.html#installation-steps",
    "href": "units/unit0/guides/anaconda-mac.html#installation-steps",
    "title": "Anaconda and Spyder Installation Guide for macOS",
    "section": "Installation Steps",
    "text": "Installation Steps\n\n1. Download Anaconda\nVisit the Anaconda download page at https://www.anaconda.com/download.\n\n\n2. Choose the macOS Installer\nClick on the “Download” button under the macOS section depending on your System-on-chip (Intel/M1/M2) to download the Anaconda installer for macOS.\n\n\n\nDownload Anaconda\n\n\n\n\n3. Run the Installer\n\nLocate the downloaded file, usually in your “Downloads” folder.\nDouble-click the Anaconda disk image (.dmg) file to open it and click “Allow” when prompted.\n\n\n\n\nRun Installer\n\n\n\n\n\nAllow Installation\n\n\n\n\n4. Follow the Installer Wizard\n\nFollow on-screen instructions to begin the installation.\nRead and accept the license agreement when prompted.\n\n\n\n\nRead Me\n\n\n\n\n\nLicense Agreement\n\n\n\n\n5. Install Anaconda\nClick the “Install” button to start the installation process. This may take a few minutes.\n\n\n\nInstall\n\n\n\n\n6. Complete the Installation\nOnce installation is complete, you’ll see a confirmation message. Click “Continue” and close the installation wizard by clicking “Close”.\n\n\n\nInstallation Complete\n\n\n\n\n\nClose Installation Wizard\n\n\n\n\n7. Move the Installer File to Trash (Optional)\n\n\n\nMove the Installer to Trash\n\n\n\n\n8. If prompted to update the navigator, select “No, don’t show again”\n\n\n\nDon’t Update\n\n\n\n\n9. You’re NOT REQUIRED to Log in/Sign up for Anaconda Cloud; close the prompt by clicking the “x” button\n\n\n\nDon’t Log in/Sign up\n\n\n\n\n10. Access Spyder through Anaconda Navigator\n\nOpen Anaconda Navigator, which is now installed on your system.\n\n\n\n\nLaunch Anaconda Navigator\n\n\n\nLocate Spyder and click “Launch” to open the Spyder IDE.\n\n\n\n\nLaunch Spyder\n\n\n\n\n\nSpyder"
  },
  {
    "objectID": "units/unit0/guides/anaconda-mac.html#conclusion",
    "href": "units/unit0/guides/anaconda-mac.html#conclusion",
    "title": "Anaconda and Spyder Installation Guide for macOS",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! You’ve successfully installed Anaconda and Spyder on your macOS computer. Utilize Spyder for scientific computing and Python development.\nFor further guidance on using Anaconda, refer to the official documentation at https://docs.anaconda.com/.\nIf you encounter any issues or have questions, seek assistance from the Anaconda community or consult the documentation for troubleshooting tips."
  },
  {
    "objectID": "units/unit0/guides/stopping.html",
    "href": "units/unit0/guides/stopping.html",
    "title": "Instructions for stopping a running program",
    "section": "",
    "text": "As you will see, it is easy to write a program that runs forever or “gets stuck in an endless loop”.\nSome kinds of “endless” programs will crash on their own because they use up hidden resources on your laptop, which means the operating system (Mac, Windows) will intervene.\nBut it’s equally possible to write a harmless program that merely either just “waits for the user” or is in an endless loop.\nIn either case, it’s very useful to be able to stop a program from continuing to execute.\nThonny users: Thonny already has an easy way to do this from the Run menu: simply click on Interrupt Execution or type control-c (the control key and the c key simultaneously).\nSpyder users: Stopping a running program is a bit more complicated in Spyder because Spyder behaves differently depending on which part of Spyder “has the focus”.\nStep 1: \nBy default, when you write code in Spyder, it’s in the window that says the name of the file (on your screen, you may have chosen for the layout to look slightly different where the file is on the right, or on the bottom or on the top, but the location doesn’t matter for this).\nAs you write code, the outline of that area (called a window) has what is called “focus”, in that when you type something, even ctrl+c, Spyder believes it is meant for that window.\nYou can tell which window has focus because Spyder will outline it in a faint blue line. We’ve drawn in some red arrows to help you see the outline.\nStep 2: \nIf you move your cursor to a different “window”, Spyder will then highlight that window’s outline in a slightly brighter blue to let you know you’ve moved your cursor to a different area. In order to stop a program, the “focus” must be on the output window, called the “IPython Console”, instead of any other window (like the window in which you type your code).\nWe’ve drawn in some more red arrows to highlight Spyder outlining the IPython Console in a lighter blue.\nStep 3: \nAll you need to do to give the IPython Console “focus”, is to click anywhere in that window. Then, you’ll notice that the outline of the window changes slightly. The IPython Console window will be outlined in a faint blue, and the other windows will no longer be outlined.\nWe’ve drawn in some red arrows to show what it looks like when a window has focus (on the right), and some green arrows (on the left) to show what it looks like when a window doesn’t have focus.\nStep 4: \nOnce you’ve clicked anywhere in the IPython Console Window (again, the output window), then, once you press ctrl+c, your program will terminate. If the IPython Console doesn’t have focus when you press ctrl+c, it won’t know you mean to terminate the program, and so it will ignore the ctrl+c."
  },
  {
    "objectID": "units/unit0/guides/thonny-mac.html",
    "href": "units/unit0/guides/thonny-mac.html",
    "title": "Thonny Installation Guide for macOS",
    "section": "",
    "text": "This guide will take you through the step-by-step process of installing Thonny, a user-friendly Python IDE, on your macOS system. Thonny simplifies Python programming and is ideal for learners and developers alike."
  },
  {
    "objectID": "units/unit0/guides/thonny-mac.html#introduction",
    "href": "units/unit0/guides/thonny-mac.html#introduction",
    "title": "Thonny Installation Guide for macOS",
    "section": "",
    "text": "This guide will take you through the step-by-step process of installing Thonny, a user-friendly Python IDE, on your macOS system. Thonny simplifies Python programming and is ideal for learners and developers alike."
  },
  {
    "objectID": "units/unit0/guides/thonny-mac.html#prerequisites",
    "href": "units/unit0/guides/thonny-mac.html#prerequisites",
    "title": "Thonny Installation Guide for macOS",
    "section": "Prerequisites",
    "text": "Prerequisites\nBefore you start, make sure you have the following:\n\nA macOS computer.\nAn active internet connection.\nAdequate disk space for the installation."
  },
  {
    "objectID": "units/unit0/guides/thonny-mac.html#installation-steps",
    "href": "units/unit0/guides/thonny-mac.html#installation-steps",
    "title": "Thonny Installation Guide for macOS",
    "section": "Installation Steps",
    "text": "Installation Steps\n\n1. Visit Thonny’s Official Website\nGo to https://www.thonny.org/ to access Thonny’s official download page.\n\n\n\nVisit Official Website\n\n\n\n\n2. Select the macOS Download Option\nHover your cursor over the “Mac” option in the “Download version…” box and click to initiate the download.\n\n\n\nDownload Thonny\n\n\n\n\n3. Execute the Installer\nLocate the downloaded file, typically in your “Downloads” folder. Double-click the Thonny installer and click “Allow” if prompted.\n\n\n\nRun Installer\n\n\n\n\n4. Confirm Installation\nFollow the on-screen instructions. Click “Continue” and agree to the license agreements.\n\n\n\nFollow the Installation Wizard\n\n\n\n\n\nLicense Agreement\n\n\n\n\n5. Choose Installation Destination\nSelect a destination for installation; the default option is acceptable.\n\n\n\nInstallation Destination\n\n\n\n\n6. Initiate Installation\nClick “Install” and allow the installation process to complete.\n\n\n\nInstall Thonny\n\n\n\n\n7. Grant Folder Access\nIf necessary, click “OK” to allow the installer access to folders.\n\n\n\nFolder Access\n\n\n\n\n8. Completion Confirmation\nClick “Close” to finalize the installation.\n\n\n\nInstallation Complete\n\n\n\n\n9. Optional Cleanup\nConsider moving the installer file to the trash if desired.\n\n\n\n10. Launch Thonny\nThonny is now installed on your computer. Open the Thonny editor by clicking on its icon.\n\n\n\n11. Initial Configuration\nUse the dropdown menu to select default options. Click “Let’s go.”\n\n\n\nInitial Configuration\n\n\n\n\n12. Verification\nConfirm the successful installation by viewing the Thonny screen window.\n\n\n\nVerification"
  },
  {
    "objectID": "units/unit0/guides/thonny-mac.html#conclusion",
    "href": "units/unit0/guides/thonny-mac.html#conclusion",
    "title": "Thonny Installation Guide for macOS",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! Thonny is now successfully installed on your macOS system.\nStart coding with Thonny, and if you need more guidance, consult the official documentation at https://docs.thonny.org/.\nFor any issues or questions, feel free to seek assistance from the Thonny community or refer to the documentation for troubleshooting tips."
  },
  {
    "objectID": "units/unit0/modules/module0.5.html",
    "href": "units/unit0/modules/module0.5.html",
    "title": "Module 0.5: Strings and Characters",
    "section": "",
    "text": "Home » Unit 0 » Module 0.5"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#objectives",
    "href": "units/unit0/modules/module0.5.html#objectives",
    "title": "Module 0.5: Strings and Characters",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module, for simple HelloWorld-like programs, you will be able to:\n\nWrite simple code that works with strings and characters (letters, digits, symbols like $)\nIdentify some syntax errors related to characters and strings.\nHave some stress relieving fun after that long integer module."
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#strings",
    "href": "units/unit0/modules/module0.5.html#strings",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.0 Strings",
    "text": "0.5.0 Strings\nAbout strings:\n\nWe have already seen examples of strings, as in:\nprint('Hello')\nHere, whatever is in between the quotes is treated as one thing: a sequence of letters, digits or symbols.\nHere are examples with digits, symbols and spaces:\nprint('Hello there. I'm on my way to 123 Main Street')\nprint('#@%&! I'm late!')\nThe entire sequence of letters, digits, punctuation etc from the H in Hello to the t in Street is one string.\nAnd you already know that “#@%&!” translates to “Drat!”\n\nJust like integer values can be placed in variables, we can do the same with strings:\n\nExample:\ns = 'The quick brown fox jumps over the lazy dog'\nprint(s)\nHere, the variable s has the string 'The quick brown fox jumps over the lazy dog'\nIf you’re wondering how a variable (we used a box as an analogy) can fit so many letters, that is a somewhat advanced topic.\nFor now, let’s proceed with the notion that we can do this.\n\nConsider this example:\n# Make a string and print it:\ns = 'The quick brown fox jumps over the lazy dog'\nprint(s)\n\n# Extract the length of the string and print that:\nk = len(s)\nprint(k)\n\nHere, we are using a function called len to extract the length of a string.\nThe function len is like print in one respect: there is something that goes in between the parentheses: \nBut it is different in another respect: something comes out of the function and gets placed into the variable k\nWe will later look further into how we can write our own functions that have this property of “making something and giving the result” to a variable.\n\n\n\n\n\n\n\n0.5.1 Exercise\n\n\n\nType up the above in my_string_example.py. What is the printed length? Use comments (text followed by ‘#’ symbol) to describe the error in the python-file."
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#string-concatenation",
    "href": "units/unit0/modules/module0.5.html#string-concatenation",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.1 String concatenation",
    "text": "0.5.1 String concatenation\nStrings would be of limited use if there were no way of combining them, just as integers would be if there were no way of performing arithmetic.\nThe joining of two strings end to end is called concatenation.\nConsider this program:\nx = 'The'\ny = 'quick'\nz = 'brown'\n\ns = x + y + z\nprint(s)\n\n\n\n\n\n\n0.5.2 Exercise\n\n\n\nType up the above in my_string_example2.py. What is the output? Use comments (text followed by ‘#’ symbol) to describe the output in the python-file.\n\n\nAbout concatenation:\n\nThe same + that we used for integer addition is what’s used to concatenate strings.\nThus multiple-usage of symbols in a programming language is common: we’ll see other examples of a single symbol or function serving multiple purposes.\n\nHow come Python doesn’t get confused and think that x, y, z are integers wanting to be added?\nPython is smart about context, and understands that when + is used with strings, the only reasonable thing to do is to concatenate. Likewise, with numbers, Python will add them.\n\nYou may have noticed the words all strung together without a space. So let’s add the spaces:\nx = 'Sphinx'\ny = 'of'\nz = 'black'\n\ns = x + ' ' + y + ' ' + z + ' quartz, judge my vow'\nprint(s)\n\nprint(len(s))\nNotice how multiple strings, some from variables, and some just written into the statement, are concatenated: \n\n\n\n\n\n\n\n0.5.3 Exercise\n\n\n\nType up the above in my_string_example3.py. What is the output? How many times did a concatenation occur? Use comments (text followed by ‘#’ symbol) to describe the output in the python-file.\n\n\nWe also introduced something new:\nprint(len(s))\nHere’s how to read this line:\n\nFirst look at print and notice that there’s something between the parentheses:\nprint(len(s))\nThink to yourself: something is going to be given to print to get printed.\nNow look at what’s going to print:\nprint(len(s))\nHere we see that the length of the string s is being computed.\nWhat you should be thinking is:\n\nThe length will first get computed.\nAnd then the result (36, in this case) will be sent to print.\nprint then prints it to the output, which is what we see.\n\nOne way to think about this is to use a term, nesting, that we’ve seen before:\n\nHere, the function invocation to len is nested in the function invocation to print\nThe innermost in this case executes first.\n\nIn case you were wondering: yes, one can nest deeply with one function invocation inside another, inside another etc. But we won’t need that anytime soon.\n\nOften we want to concatenate strings with numbers, or other kinds of things:\nFor example: consider\nk = 26\ns = str(k)\nt = 'A pangram must have all ' + s + ' letters'\nprint(t)\n\nHere, the value in k is an integer.\nPrior to concatenation with a string, we first need to make a string out of the integer:\ns = str(k)\nWe do this by sending the integer k to the str function, which builds a string version of the integer and gives that back.\nThe string so computed is then placed into the variable s above.\nThis string s gets concatenated with the other strings to produce the final result.\n\n\n\n\n\n\n\n0.5.4 Exercise\n\n\n\nType up the above in my_string_example4.py to confirm.\n\n\nLet’s examine a small variation:\nk = 26\n# You can also build a string in the print statement itself:\nprint('A pangram must have all ' + str(k) + ' letters')\n\n\n\n\n\n\n0.5.5 Exercise\n\n\n\nType up the above in my_string_example5.py to see the resulting output.\n\n\n\n0.5.6 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#fun-with-string-concatenation",
    "href": "units/unit0/modules/module0.5.html#fun-with-string-concatenation",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.2 Fun with string concatenation",
    "text": "0.5.2 Fun with string concatenation\nWe will occasionally introduce programs we’ve written to both simplify your programming and yet allow for interesting examples.\nIf all we did was compute with integers, it would be boring.\nYou’ve already seen one example of such a tool: drawtool.\nWe’ll now use wordtool, another tool that you will use by calling appropriate functions.\nYou are welcome and are encouraged to “look inside” by skimming over the code in any tool.\nLet’s look at an example that will also introduce some new ideas:\nimport wordtool\n\n# Invoke functions in wordtool to pick random words:\nadj = wordtool.get_random_adjective()\nnoun = wordtool.get_random_noun()\nnoun2 = wordtool.get_random_noun()\nverb = wordtool.get_random_verb()\nprep = wordtool.get_random_preposition()\n\n# Build a sentence with these random words:\nsentence = (\n    'The ' + adj + ' ' + noun + ' ' + verb + 's' +\n    ' ' + prep + ' a ' + noun2)\nprint(sentence)\n\n\n\n\n\n\n0.5.7 Exercise\n\n\n\nType up the above in my_random_sentence.py. Don’t run it just yet. First download wordtool.py and wordsWithPOS.txt into the same folder as your program. Now run the program several times. Run the program several times. Use comments (text followed by ‘#’ symbol) to and include each output in the python-file.\n\n\nLet’s point out:\n\nwordtool.py is merely another Python program, like the ones you’ve been writing, just a bit more complex.\nwordsWithPOS.txt is plain text data (about English words, and parts-of-speech).\nwordtool.py is written to read the data and make some functionality available, one of which is to randomly pick words from amongst the nouns, adjectives, and so on.\nTo use functions in wordtool.py in your program, you need (and this is a new thing we’ve introduced) the import statement at the top of your program:\nimport wordtool\n\n\n\n\n\n\nTip\n\n\n\nThe .py part is not in the import statement\n\n\nThen, to use a function defined in that other file, we use syntax like this:\nadj = wordtool.get_random_adjective()\n\nHere, adj is a string variable that we made.\nThe combination of wordtool, a period, and the desired function get_random_adjective(), is what’s needed to invoke that particular function.\nIn this case, it results in a randomly selected adjective (from the thousands in the data) being copied into the adj variable.\n\nSimilarly, after getting a random noun, verb, and so on, we put those together to make a sentence. Hopefully, with hilarious results.\nWe’ll point out one other new thing:\nsentence = (\n    'The ' + adj + ' ' + noun + ' ' + verb + 's' +\n    ' ' + prep + ' a ' + noun2)\n\nHere, we are concatenating many strings into a long one.\nHowever, if it’s unwieldy to type them all in one line, we can spill over into multiple lines.\nOne way to do that is to use parentheses as shown above.\n\n\n\n\n\n\n\n\n0.5.8 Exercise\n\n\n\nOpen wordtool.py and examine the functions within. Then, make a longer random sentence in my_random_sentence2.py.\n\n\n\n0.5.9 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#input-from-the-terminal",
    "href": "units/unit0/modules/module0.5.html#input-from-the-terminal",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.3 Input from the terminal",
    "text": "0.5.3 Input from the terminal\nThus far we have printed (output) to the screen but have not taken in any input.\nThus, we haven’t written any programs that interact with potential users of our programs.\nThere’s a limited market for programs that only execute once with no input whatsoever, right?\nSo, let’s do something more interesting by asking the user to type in a string:\nimport wordtool\n\n# We will get the user to type their name:\nname = input('Enter your name: ')\n\n# We'll use that and make rudimentary conversation:\nprint('Hi ' + name + '!')\n\n\n\n\n\n\n0.5.10 Exercise\n\n\n\nTry out the above program in my_random_conversation.py. Since you are writing this in the same folder, you won’t need to download wordtool.py. and its data.\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nThe function input is exactly what it sounds like: get input (from the user typing).\nname = input('Enter your name: ')\nHere, there’s a string that goes into the input function. This string is displayed as a prompt in the output:\nEnter your name: \nOf course, you aren’t writing this tiny program to send to someone who will run your program and type in their name. You are playing both roles: programmer and intended user.\nWhatever the user types in (from the keyboard) becomes a single string that’s placed in the variable we’ve called name\nThen, we’ve concatenated whatever gets into namewith two other strings and printed the result:\nprint('Hi ' + &lt;b&gt;name&lt;/b&gt; + '!')\n\n\n\nNext, let’s make it more interesting:\nimport wordtool\n\nname = input('Enter your name: ')\n\nprint('Hi ' + name + '!')\n\nadv = wordtool.get_random_adverb()\nadj = wordtool.get_random_adjective()\nsentence = name + ', you are ' + adv + ' ' + adj\nprint(sentence)\n\n\n\n\n\n\n0.5.11 Exercise\n\n\n\nImprove on the above program by writing your version of a longer conversation my_random_conversation2.py. Allow the user to type in something at least three or four times. This will require using input multiple times to go back and forth with the user. Unleash your guile and creativity.\n\n\n\n\n\n\n\n\n0.5.12 Exercise\n\n\n\nTry out a conversation with a chatbot. For example, one of the earliest chatbots in history was Eliza, which you can try out. There is nothing to submit in this exercise."
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#strings-and-for-loops",
    "href": "units/unit0/modules/module0.5.html#strings-and-for-loops",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.4 Strings and for-loops",
    "text": "0.5.4 Strings and for-loops\nConsider this program:\nn = 6\ns = ''\n\nfor j in range(1, n):\n    s = s + '*'\n\nprint(s)\n\n\n\n\n\n\nNote\n\n\n\n\nWe can initialize the value of s to the empty string '' (nothing between the quotes).\nThe loop successively concatenates a string with an asterisk ('*') onto the gradually accumulative string s.\n\n\n\n\n\n\n\n\n\n0.5.13 Exercise\n\n\n\nTrace the execution of the loop, showing the contents of the string s in each iteration of the for-loop changing values using a table in a spreadsheet or a document. Then confirm the final output in your trace by typing it up in my_loop_example.py. Then change the value of n to 8 and examine the output. Submit your program with n set to 8.\n\n\nNext, let’s use a nested loop to output a triangle of asterisks:\nn = 5\ns = ''\n\nfor i in range(1, n+1):\n    for j in range(0, i):\n        s = s + '*'\n    s = s + '\\n'\n\nprint('A triangle with base=' + str(n))\nprint(s)\n\n\n\n\n\n\n0.5.14 Exercise\n\n\n\nBefore typing up the program, trace the execution of the loop, showing the contents of the string s in each iteration of the outer for-loop. Then confirm the final output in your trace by typing it up in my_triangle.py. Use the tabular tracing approach as in the example from Module 3.\n\n\nNext, we’ll make this more interactive:\ns = ''\n\nn_str = input('Enter triangle base size: ')\nn = int(n_str)\n\nfor i in range(1, n+1):\n    for j in range(0, i):\n        s = s + '*'\n    s = s + '\\n'\n\nprint('A triangle with base=' + str(n))\nprint(s)\n\n0.5.15 Video\n\n\n\n\n\n\n\n0.5.16 Exercise\n\n\n\nType up the above in my_triangle2.py.\n\n\nWe’ve introduced some new concepts above:\n\nSince everything typed as input initially is made into a string, the actual input, even if it’s an integer, is a string.\nThis is a little strange but it’s how Python works.\n\nConsider this example:\nn = 42       # This is an integer\ns = '42'     # This is a string\n\nk = 5        # Integer\nt = '5'      # String\n\nThus, when the user types in what they intend to be an integer, the input function makes a string out of it:\nn_str = input('Enter triangle base size: ')\nHere, the variable n_str will have a string.\nWe need to convert that string version of an integer into an actual integer using the int function:\nn = int(n_str)\nHere the variable n will have the actual integer, which we can use in loops, in arithmetic, and so on.\nNotice that, since we want the loop to run n times, we’ve begun the outer loop at 1, running through to n (inclusive).\nThis means using range(1, n+1) in the outer loop.\n\n\n\n\n\n\n\n0.5.17 Exercise\n\n\n\nTrace (using a table) through what happens above when the user enters 5.\n\n\n\n\n\n\n\n\n0.5.18 Exercise\n\n\n\nWhat happens when the conversion from string to integer is not done? Find out by trying this:\nn = input('Enter an integer: ')\nk = 5 * n\nprint(k)\nFix the issue by converting the string that’s in n and making an integer. Type your code in my_conversion.py.\n\n\n\n\n0.5.19 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#the-useful-relationship-between-characters-and-integers",
    "href": "units/unit0/modules/module0.5.html#the-useful-relationship-between-characters-and-integers",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.5 The useful relationship between characters and integers",
    "text": "0.5.5 The useful relationship between characters and integers\nConsider these three strings:\nx = 'hello'\ny = 'h'\nz = '$'\n\n\n\n\n\n\nNote\n\n\n\n\nThe strings in variables y and z are fundamentally different from the one in x in that the strings in y and z have only one letter (or symbol) in them.\nWe call such a single-letter or single-symbol string a character.\n\n\n\nThere is a special relationship between characters and some integers:\n\nFor example:\n\nThe character ‘a’ is sometimes represented by the integer 97.\nThe character ‘b’ is sometimes represented by the integer 98.\n… and there are other examples.\n\nThink of this as a “secret code” maintained by Python, with that associates a number for every letter.\nThe technical term for this “secret code” is Ascii code.\nWe often use the shorter term “char” instead of “character”.\nSo, every char has an Ascii code (pronounced “ass-key”). Who said computer nerds don’t have a sense of humor?\n\nConsider this program:\nfirst_letter = 'a'\nlast_letter = 'z'\n\nk = ord(first_letter)\nprint(k)\n\nn = ord(last_letter)\nprint(n)\n\n\n\n\n\n\n0.5.20 Exercise\n\n\n\nType up the above in my_char_example.py.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nWe’ve used longer, more descriptive variable names like first_letter.\nWe’ll say more about this in a separate section below.\n\n\n\n\nThe ord function takes a char and produces the corresponding Ascii code.\nk = ord(first_letter)\n\nGoing the other way: from Ascii code to char\nConsider this program:\nk = 97\ns = chr(k)\nprint(s)      # Prints the char 'a'\n\n\n\n\n\n\n0.5.21 Exercise\n\n\n\nType up the above in my_char_example2.py. Then, change 97 to 98. What should the value of k be to print the char ‘z’ (last lowercase letter)?\n\n\nThe usefulness of the Ascii code:\n\nThe value of knowing the code is that we can iterate over numbers and use that to iterate over letters.\nFor example:\nfor i in range(97, 123):\n    s = chr(i)\n    print(s, end='')\nprint()\nInside a computer, it turns out all characters are actually stored as integers, and merely interpreted as characters when the occasion calls for it.\n\n\n\n\n\n\n\n0.5.22 Exercise\n\n\n\nType up the above in my_char_example3.py. What does it print? What is the significance of the number 123?"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#variable-names",
    "href": "units/unit0/modules/module0.5.html#variable-names",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.6 Variable names",
    "text": "0.5.6 Variable names\nMost often, we’ve been using single letter variable names, for example:\ni = 7\nj = 15 * i\nprint(j)\n\nx = 'Hello' \ny = 'World'\nz = x + ' ' + y\nprint(z)\nLet’s rewrite the above with more meaningful variable names:\ndays_in_a_week = 7\ndays_in_a_semester = 15 * days_in_a_week\nprint(days_in_a_semester)\n\nfirst_greeting_word = 'Hello' \nsecond_greeting_word= 'World'\nfull_greeting = first_greeting_word + ' ' + second_greeting_word\nprint(full_greeting)\nAbout variable names:\n\nFirst, let’s review the very notion of a name in Python, along with other kinds of “words” that are allowed in Python programs.\nReserved words or keywords:\n\nSome words in the language belong formally to the language itself.\nThese are words like for, in, def, and others.\nIn fact, just to complete this, here’s the full set of 33 reserved words:\n\nand as assert break class continue def del elif else except False finally for from global if import in is lambda None nonlocal not or pass raise return True try while with yield\n\nEveryone of these must be used in very specific ways, in statements or in more complex structures.\nWe will learn more about these as we proceed in the course.\nWe won’t learn about all of them, because full mastery of the language takes more than one course.\n\nAt the other end of the spectrum, there are words that we freely create for our use, as in these examples:\ndef print_hello():\n    print('Hello')\n\nprint_hello()\n\nx = 'How goes?'\nprint(x)\n\nfor i in range(1,10):\n    print(i)\n\nHere, we made a function and decided to call it print_hello\nWe decided to call the string variable x\nAnd to call the loop variable i\nThese are called identifiers (jargon alert).\n\nSince we get to choose them, we could rewrite the above program as:\ndef say_greeting():\n  print('Hello')\n\nsay_greeting()\n\nfollow_up = 'How goes?'\nprint(follow_up)\n\nfor my_loop_variable in range(1,10):\n    print(my_loop_variable)\nSo, what should dictate our choice of these names?\n\nGenerally, for numbers, loop-variables and short calculations, we prefer single-letter names like x and i.\nFunction names should carry some meaning so that anyone else who needs to use them should be able to make sense of them.\nSometimes, variable names should be longer when we want the code to be readable long after it’s written.\nFor example, it would not make sense for Python to use cryptic_blob_42 instead of print.\n\nThe use of underscores:\n\nYou’ve noticed by now the presence of underscores in our variable and function names.\nAn underscore is a convenient visual aid to help us read.\nWriting days_in_a_week is better than daysinaweek because it’s easier to see.\nImportant: we cannot use spaces, so days in a week would be incorrect as a variable name.\n\nGenerally, we shouldn’t go overboard and make unnecessarily long names either, as in the_number_of_days_in_a_week.\nAnother important rule: use only letters, digits and underscores, and always start with a letter. Do NOT use other symbols like % or $ in variable names.\nFinally, there are some function and variable names “already taken”. That is we can’t use them (or shouldn’t) because Python has decided to use them.\n\nFor example: print is a function name.\nAs are chr and ord and various math functions.\nWhile we could technically use these names, we should avoid the conflict because it breaks convention and can cause hard-to-find problems.\n\nHere is a list of “avoid” names:\n\nabs, all, any, ascii, bin, bool, bytearray, bytes, callable, chr, classmethod, compile, complex, delattr, dict, dir, divmod, enumerate, eval, exec, filter, float, format, frozenset, getattr, globals, hasattr, hash, help, hex, id, input, int, isinstance, issubclass, iter, len, list, locals, map, max, memoryview, min, next, object, oct, open, ord, pow, print, property, range, repr, reversed, round, set, setattr, slice, sorted, str, sum, super, tuple, type, vars, zip\n\nDo NOT use these as your own variable or function names.\n\n\n\n\n\n\n\n0.5.23 Exercise\n\n\n\nLet’s see what can go wrong if we use one of the words “already taken”. Consider this program:\ns = 'Hello'\nlen = 5       # This is a BAD idea\nprint(len)\nWe really should not be using a variable called len since len is a predefined “already taken” name. What happens if you type and run this? Type your program in my_variable_name3.py.Then, type this program in my_variable_name4.py:\ns = 'Hello'\nlen = 5       # This is a BAD idea\nprint(len)\n\nt = 'Some looooooong sentence'\nk = len(t)\nprint(k)\nUse comments (text followed by ‘#’ symbol) to describe the error in the python-file.\n\n\n\n0.5.24 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#a-problem-solving-example",
    "href": "units/unit0/modules/module0.5.html#a-problem-solving-example",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.7 A problem solving example",
    "text": "0.5.7 A problem solving example\nPossibly the hardest aspect of programming is problem-solving:\n\nTypically, we’re given an English description of a problem, with the goal of writing a program to solve the problem.\nThe hard part is not the typing, and remembering syntactic details like parentheses.\nThe hard part is figuring out what to write in code to solve the problem.\n\nLet’s work through an example problem and solve it.\nBefore that, we’ll learn one more string function:\ns = 'The quick brown fox jumps over the lazy dog'\nn = s.count('a')     # How many a's occur in the string s?\nprint(n)\n\n\n\n\n\n\nNote\n\n\n\n\nWe’ve introduced a new feature of strings: the ability to count occurences of a letter in that string.\nNotice the unusual way by which the function must be used:\nn = s.count('a')\nand NOT\nn = count(s, 'a')\nThat is, the function count appears to be part of the string variable s.\nThis is a somewhat advanced topic, so we’ll just use it and be glad we have this feature. (There are other such functions we’ll avail of.)\nThis is possible for any string, such as:\nx = 'helloooooooo'\nprint(x.count('o'))    # Number of o's in string x\ny = 'missisippi'\nprint(y.count('i'))    # Number of i's in string x\n\n\n\n\n\n\n\n\n\n0.5.25 Exercise\n\n\n\nConfirm by typing up the above in my_letter_count.py.\n\n\nOK, now the problem:\n\nA pangram is an English sentence that contains all 26 letters.\nWe’ve already seen two examples:\nThe quick brown fox jumps over the lazy dog\nSphinx of black quartz, judge my vow\nThere’s an informal competition running over a hundred years to find the shortest grammatically correct English sentence that’s a pangram.\nOur smaller problem: given a sentence, print the number of a’s, the number of b’s … and so on. This could be useful in judging such a competition.\n\nLet’s work towards a solution:\n\nGiven a candidate pangram, we could count the number of a’s:\ns = 'The quick brown fox jumps over the lazy dog'\nprint(s.count('a'))\nThen, we could also count the number of b’s:\ns = 'The quick brown fox jumps over the lazy dog'\nprint(s.count('a'))\nprint(s.count('b'))\nIf we repeated this 26 times, we’d have a count for each letter.\nBut the moment we see a bunch of repetition, our computational problem-solving instincts (yes, still developing) should kick in:\n\nRepetition ⇒ use a loop!\n\nWhat is the nature of iteration in this problem?  We are iterating through the letters ‘a’ to ‘z’\nAnd we already know how to iterate over the letters:\nfor i in range(97, 123):\n  letter = chr(i)       \n  # Recall: We're going from Ascii code to letter\nCould we combine this with the counting of occurences inside the given string? So, the idea would be:\nfor i in range(97, 123):\n  letter = chr(i)       \n  # Now somehow use that to do the counting of occurences\nCombining:\ns = 'The quick brown fox jumps over the lazy dog'\n\nfor i in range(97, 123):\n  letter = chr(i)       \n  k = s.count(letter)\n  print('Number of occurrences of ' + letter + ' is ' + str(k))\n\n\n\n\n\n\n\n0.5.26 Exercise\n\n\n\nType up the above idea my_count_problem.py. Then, find another pangram and apply the program to that pangram. Submit your program with the pangram shown above (not the one you found).\n\n\n\n\n\n\n\n\n0.5.27 Exercise\n\n\n\nThis can be taken a step further. Instead of typing the pangram in the program itself (as was done above), ask the user to enter it as input. In my_count_problem2.py, read a string from the user and print the letter counts. When you test your program, use the pangram you found as input.\n\n\n\n0.5.28 Video\n\nLastly, we’ll point out a slightly more elegant way of iterating over the 26 letters:\nascii_a = ord('a')\nascii_z = ord('z')\nfor i in range(ascii_a, ascii_z + 1):\n    letter = chr(i)       \n    # Now somehow use that to do the counting of occurences\n\n\n\n\n\n\nNote\n\n\n\n\nInstead of typing in the numbers 97 and 123 (which we’d have to remember), we’re instead using the ord function itself to identify the limits of the loop.\nAn even more (but harder to read) compact way is to write:\nfor i in range(ord('a'), ord('z') + 1):\n    letter = chr(i)       \nWe’ll understand this better once we see functions in more detail.\n\n\n\nFinally, we’ve written a program to solve an actual problem. Perhaps there’s a market out there for pangram-checkers?"
  },
  {
    "objectID": "units/unit0/modules/module0.5.html#when-things-go-wrong",
    "href": "units/unit0/modules/module0.5.html#when-things-go-wrong",
    "title": "Module 0.5: Strings and Characters",
    "section": "0.5.8 When things go wrong",
    "text": "0.5.8 When things go wrong\nIn each of the exercises below, try to identify the error before typing it up and confirming. Report the error in the module pdf. Then, fix the error in the code, using the specified program (.py) name.\n\n\n\n\n\n\n0.5.30 Exercise\n\n\n\nx = 'Hello'\ny = 'World'\ns = 'x' + ' ' + 'y'\n(This should print Hello World, with a space in between). Fix the error in error1.py.\n\n\n\n\n\n\n\n\n0.5.31 Exercise\n\n\n\nk = 8\ns = 'There are ' + k + ' planets in our solar system'\nprint(s)\nFix the error in error2.py.\n\n\n\n\n\n\n\n\n0.5.32 Exercise\n\n\n\nlong_sentence = 'How' + ' ' + 'vexingly' + ' ' +\n   'quick' + ' ' + 'daft' + ' ' + 'zebras' + ' ' + 'jump'\nFix the error in error3.py.\n\n\n\n\n\n\n\n\n0.5.33 Exercise\n\n\n\nx = input('Enter a number between 1 and 10')\ny = 2 * x\nprint(y)\nFix the error in error4.py.\n\n\n\n\n\n\n\n\n0.5.34 Exercise\n\n\n\nfor i in range(1, 6):\n    s = s + '**'\nprint(s)\n(This should print a string with 10 asterisks). Fix the error in error5.py.\n\n\n\n\n\n\n\n\n0.5.35 Exercise\n\n\n\nmiles = 10\nfeet per mile = 5280\nfeet in ten miles = miles * feet per mile\nprint(feet in ten miles)\nFix the error in error6.py.\n\n\n Previous Module: Module 0.4 Next Module: Module 0.6"
  },
  {
    "objectID": "units/unit0/modules/module0.0.html",
    "href": "units/unit0/modules/module0.0.html",
    "title": "Module 0.0: Your First Program",
    "section": "",
    "text": "Home » Unit 0 » Module 0.0"
  },
  {
    "objectID": "units/unit0/modules/module0.0.html#objectives",
    "href": "units/unit0/modules/module0.0.html#objectives",
    "title": "Module 0.0: Your First Program",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module you will be able to:\n\nExperince writing a really simple program.\nExplain the difference between command-line outputs vs GUI for programs.\n\n\n0.0.0: Our First Program\nLets take a look at our first program as it appears in a textbook (like this one):\n\nprint(\"Hello World\")\n\nHello World\n\n\nThis is a simple program written in the Python programming language, possibly one of the smallest programs one can write, and a traditional starting point for learning programming.\nWe will very soon (below) write this program ourselves.\nFor now, let’s point out a few things:\n\nWhat we see above is the text of the program. \nThe entire program will appear inside of a code editor when we write.\nWe could use one of several code editors.\nFor example, this is how it would look inside the Spyder code editor: \nAnd how it might look in the Thonny code editor: \nVarious editors colorize in different ways for convenience of reading, none of which affect the actual text of the program.\nApart from typing it in (which you’ll do shortly), we haven’t actually run the program.\nIntuitively, just looking at the program we might think that:\n\nIt has to do with some kind of “printing” (because we see print)\nWe have no idea what is meant by the somewhat odd phrase “Hello World!”, but we see it there.\n\nThere are several ways to run a program:\n\nRun the program inside the very same editor used to type in the program.\nRun it without any editor (a slightly advanced topic).\n\nFor example, if we run the program using the Thonny editor, we will see this: \n\nNext, you will try this yourself.\n\n\n\n\n\n\n0.0.1 Exercise\n\n\n\nWrite and run the helloworld program using these instructions\n\n\nSo, what’s with printing the unusual phrase “Hello World!”?\n\nIt’s a tradition in computer science that your first program will print “Hello World!”.\nIt’s meant to pretend that a program is a creature that’s itself communicating to the outside world by saying hello.\n\n\n\n0.0.1 The recipe-cook-dish analogy\nWhat just happened above?\nLet’s use an analogy \n\nA recipe is a bunch of instructions in text form.       ⇒ A program is also a set of instructions in text form.\nBy itself, a recipe doesn’t do anything until it’s acted on.       ⇒ You can type up a program but not do anything with it (i.e., not run it).\nA cook executes a recipe by following the instructions       ⇒ A combination of elements in your laptop executes a program.\nThe net result of a cook executing a recipe is, typically, a dish.       ⇒ The result of executing a program is the program’s output\nWe of course design and write up programs to get useful or interesting output.\nWhen a recipe is poorly written, or if the cook messes up, the result may be failure.       ⇒ A program and the laptop are even more exacting: the slightest error can result in failure.\n\n\n\n0.0.2 Programming vs. computerese\nWhat we mean by computerese:\n\nThe computer-related tasks and knowledge that are needed, but not the intellectual core of programming.\nWe use the term slightly pejoratively, like legalese.       ⇒ A necessary evil.\nExamples of computerese:\n\nNavigating directories\nLocating files, copying them, moving them.\nMastery of editor keys, shortcuts.\nHandling the quirks of an operating system.\nUploading files to a website, downloading.\n\n\n\n\n\n\n\n\n0.0.2 Exercise\n\n\n\nDevelop your computerese skills by following these instructions.\n\n\n\n\n\n\n\n\nNote\n\n\n\nThere is nothing to submit for this particula exercise; it is aimed at generally helping you get proficien with using your computer for programming.\n\n\n\n\n0.0.3 A slight variation\nWe will now spend a bit of time trying a few variations, and also examining what happens when typing mistakes are made.\nConsider this program:\nprint('Hello World!')\nprint('My name is X')\n\n\n\n\n\n\n0.0.3 Exercise\n\n\n\nType up this program but use your own name instead of X. Save the file in the module0.0 folder as myname.py.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn the future we will be asking you to “type up” programs; in all such cases, please also save the file (for eventual submission)\n\n\n\n\n0.0.4 What happens when things go (even slightly) wrong\nWe’ll now deliberately make a few tiny errors and see what happens:\n\nError #1: forgetting to type the closing parenthesis.\n\nHere’s the program:\n\nprint('Hello World!'\nNote the missing right parenthesis at the end of the line.\n\nWhat happens when we nonetheless try and run the program?\n\nHere’s an example with the Thonny editor: \n\nError #2: What happens if we forget the quotation marks?\n\nHere’s the program:\n\nprint(Hello World!)\n\nWe get something quite similar: \n\n\n\n\n\n\n\n\n0.0.4 Exercise\n\n\n\nConfirm that you get the errors above by typing up the two programs as error1.py and save the programs in the module0.0 folder.\n\n\n\n\n0.0.5 A peek at a more complex program\nJust to see what’s coming later, let’s get a sense of what a more complex program looks like.\nYour goal is to look through it with bemused curiosity, as if studying an incomprensible work of abstract art.\nWe’ll just examine the some surface features, as we would when examining some undeciphered ancient script such as: \nLet’s start by running the program.\n\n\n\n\n\n\n0.0.5 Exercise\n\n\n\nDownload whackamole.py into your module0.0 folder Then open it and run it. You should see  The purpose of the program and how you use it should be easy to figure out.\n\n\nLet’s point out a few things:\n\nUnlike the toy helloworld.py example, this program actually does something nontrivial.\nThe program brings up a window, and allows a user to interact with it (the program).\n\nNow let’s list the program and then point out some “surface” features.\nThe full program:\n# whackamole with nerf gun\n\n# Use programs written by others through \"import\"\nimport tkinter as tk  \n\n# Define a window\nwindow = tk.Tk()\n\n# The instructions at the top\ninstructions = 'Click reset, then click fire to strike the mole'\nlabel = tk.Label(text=instructions)\nlabel.pack()\n\n# Build a rectangular space on which to draw \n# shapes like circles\nw = 300\nh = 200\ncanvas = tk.Canvas(master=window, width=w, height=h)\ncanvas.pack()\n\n# These are variables that control the \n# position of the target and nerf ball\ntargetX = 0\ntargetVX = 10\nnerfX = 0\nnerfY = h-10\nnerfVX = 20\nnerfVY = 0\nnerfAY = -3\ndelT = 0.1\nnerfFired = False\n\n\n# This is what we want to do when the \n# reset button is clicked:\ndef reset():\n    global nerfFired, targetX, nerfX, nerfY, nerfVY\n    nerfFired = False\n    targetX = 0\n    nerfX = 0\n    nerfY = h-1\n    nerfVY = 0\n    canvas.delete(\"all\")\n    print('reset')\n\n# When the fire button is clicked, we change \n# the status of the nerf gun\ndef fire():\n    # start launch\n    global nerfFired\n    nerfFired = True\n    print('fired')\n\n# Build the three buttons called \"reset\", \"fire\" and \"quit\"\nframe = tk.Frame(master=window)\nframe.pack()\n\nresetb = tk.Button(\n    master=frame, text=\"reset\", relief=tk.RIDGE, \n    fg='black', bg='grey', height=2, width=5,command=reset)\nresetb.grid(row=0, column=0)\n\nfireb = tk.Button(\n    master=frame, text=\"fire\", relief=tk.RIDGE, \n    fg='black', bg='grey', height=2, width=5, command=fire)\nfireb.grid(row=0, column=1)\n\nquitb = tk.Button(\n    master=frame, text=\"quit\", relief=tk.RIDGE, fg='black', \n    bg='grey', height=2, width=5, command=window.destroy)\nquitb.grid(row=0, column=2)\n\n# This part of the code draws and animates\ndef run():\n    global targetX, nerfX, nerfVY, nerfY\n    canvas.delete(\"all\")\n    targetX += targetVX * delT\n    canvas.create_rectangle(\n        targetX, h-10, targetX+10, h, fill=\"green\")\n    if nerfFired:\n        nerfX += nerfVX * delT\n        nerfVY += nerfAY * delT\n        nerfY += nerfVY * delT\n    canvas.create_oval(\n        nerfX+5,h-nerfY+5, nerfX+15, h-nerfY+15, \n        fill=\"red\")\n    window.after(1, run)\n\n# Launch the window and start the animation\nwindow.after(1, run)\nwindow.mainloop()\nYes, that’s a long program! Now let’s point out some features:\nFirst, some features from the first half of the program: \nAnd some from the latter part:And some from the latter part: \n\n\n0.0.6 GUI vs command-line\nGUI stands for: Graphical User Interface.\nAnd is pronounced like “gooey”.\nThe difference between GUI and command-line programs:\n\nPrograms like helloworld.py from earlier printed plain text. These are Command-line programs.\nPrograms like whackamole.py bring up their own little window on your screen. These are called GUI programs.\nGUI programs are typically more complicated because one has to specify all the elements (buttons etc) of the interface.\nWe will spend quite a bit of time learning programming with simpler (albeit less exciting) command-line programs.\nHowever, we will occasionally work with GUI programs because they are visually more interesting, and demonstrate applications.\n\n\n\n0.0.7 Computer science: beyond programming\nIs computer science the same as programming?\nNot at all:\nProgramming is certainly a significant part, just as narrative non-fiction is a significant part of an English degree.        ⇒ But there’s much more to it.\nWhat else does a computer science degree feature? Typically:\n\nProgramming devices (units 9-10).\nAn understanding of the hardware (units 11-12).\nAlgorithms: the science in computer science.\nTheory: understanding fundamental theoretical limitations of computation.\nA deeper understanding of how computer systems work: networks, databases, operating systems.\n\nBut also electives among (to name a few):\n\nArtificial intelligence, machine learning, robotics, computer vision, natural language processing.\nDesign of interfaces.\nGraphics, animation, visualization.\nDigital humanities, computing for arts and social sciences.\nScientific computing.\nComputational X, where X=biology, physics, economics …\nEducational tools, health data systems.\nMedical devices, prosthetics, control of mechanical systems\n\n\n\n0.0.8 How to succeed as a student\nThe challenge in learning programming:\n1: it’s an alien world.        ⇒ Takes getting used to.\n2: it’s a mental skill        ⇒ Skills are acquired slowly, with much practice, and in fits and starts.\n3: there are confounding issues        ⇒ some knowledge of (regrettably) computerese needed.\n4: it’s easy to feel overwhelmed or intimidated        ⇒ your neighbor may appear to be “getting it” while you feel you don’t.\nWhat you should expect:\n\nYou can’t learn instantly        ⇒ You may have to see a concept multiple times to “get it”.\nYou may occasionally feel bewildered.\nThere are some things that can’t be understoodat this stage.        ⇒ Not enough background.\nIt’s deceptively easy to understand an idea when reading or viewing but devilishly harder to do it yourself.\n\nHow to succeed:\n\nMake progress every day        ⇒ Each module builds on previous modules        ⇒ Can’t afford to let anything slide.\nBe willing to put the effort        ⇒ Do all exercises, assignments etc.\nPractice being irrepressibly positive.\n\n\n\n\n\n\n\nNote\n\n\n\nWhat to rememeber about submitting work\n\n\n Next Module: Module 0.1"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html",
    "href": "units/unit0/modules/module0.3.html",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "",
    "text": "Home » Unit 0 » Module 0.3"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#objectives",
    "href": "units/unit0/modules/module0.3.html#objectives",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this module, for simple HelloWorld-like programs, you will be able to:\n\nIdentify the new syntactic elements with the basic output-only for-loop.\nDemonstrate ability to mentally trace execution of for-loops.\nProduce desired output using for-loop and print’s.\nDistinguish between count-up and count-down loops.\nUse some nested for-loops with independent variables.\nUse some nested for-loops with dependent conditions.\nIdentify and correct syntax errors related to above objectives.\nDistinguish between syntax errors and debugging."
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#an-example",
    "href": "units/unit0/modules/module0.3.html#an-example",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.0 An example",
    "text": "0.3.0 An example\nConsider the following program:\ndef print_big_M():  \n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():  \n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\nprint_big_M()\nprint_big_O()  \nprint_big_O()  # 1st repetition\nprint_big_O()  # 2nd repetition\nprint_big_O()\nprint_big_O()\nprint_big_O()  # 5th repetition - 6 O's in all\nWhat we would like is a way to organize repetition.\nWe will do this using one version (there are many) of the for-loop, one of the most important programming constructs:\ndef print_big_M():  \n    print('*   *')\n    print('** **')\n    print('* * *')\n    print('*   *')\n    print('*   *\\n')\n\ndef print_big_O():  \n    print('*****')\n    print('*   *')\n    print('*   *')\n    print('*   *')\n    print('*****\\n')\n\n\nprint_big_M()\nfor i in range(6):\n    print_big_O()\n\n\n\n\n\n\n0.3.1 Exercise\n\n\n\nType up the above in animal_sounds_loop.py and run it. Also save the file so that it can be submitted (You will need to save the appropriate files for every such “type up” exercise).\n\n\n\n\n\n\n\n\n0.3.2 Exercise\n\n\n\nUsing the example above as a point of reference, print out your own animal sound. Be sure to use a for-loop to repeatedly print one letter in the sound. Write your code in my_pet_sound_loop.py.\n\n\nLet’s zoom in on the for-loop and examine it.\nTo do so, we’ll write a different for-loop:\nfor i in range(6):\n    print(i)\n\n\n\n\n\n\n0.3.3 Exercise\n\n\n\nType up the above in my_forloop_example.py and run it. You should observe this:\n0\n1\n2\n3\n4\n5\nIn the place in the code where you see the number 6, replace 6 with 10 and then run the program. Next, try 2 instead of 6. Finally, try 0 instead of 6. What is the output in each case? Discuss the program with your TA to understand what happens when you replace the number 6 with 10 and 2.\n\n\nLet’s now examine elements of the loop: - There’s the special word for \n\nThen, there’s the for-loop variable \nThe special word \nThe element that controls the spread of different values that variable i takes on at each iteration of the loop: \nThe colon at the end: \nFinally, the block of code (in this case, just one line) that’s called the body of the loop: \n\nLet’s change the program slightly and then set about explaining how the loop works:\nfor i in range(6):\n    print(i)\n    print('Hello')\n\n\n\n\n\n\n0.3.4 Exercise\n\n\n\nType up the above in my_forloop_example2.py and run the program.\n\n\nObserve that the body of this for-loop has two statements: \nLet’s now use a slightly fictionalized way to explain the action of this loop:\n\nThink of the Python part of your computer (since your laptop does many things) as reading your program and then carrying out the instructions.\nWhen it encounters the for word, it says “Ah, here’s a for-loop”.\nThen it sees the variable i and says (to itself), “This is the variable whose value will change after each iteration”.\nThen it sees the term range(6) and says “Oh, i will start at 0 and end just before 6, which means it will be 0 in the first iteration, 1 in the second, 2 in the third, 3 in the fourth, 4 in the fifth, 5 in the last”.\nThen, it starts executing the body of the loop for the first iteration:\n\nFor the first iteration, i=0.\nThe entire body of the loop executes with i being replaced by 0: \nFor the second iteration, i=1 \nThird iteration: \nFourth iteration: \nFifth iteration: \nSixth and final iteration: \n\nNow the for-loop is done and the execution goes past the whole for-loop to whatever’s there.\n\nIn this case, there’s no other code and the program completes.\n\n\n\n0.3.5 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#variations",
    "href": "units/unit0/modules/module0.3.html#variations",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.1 Variations",
    "text": "0.3.1 Variations\nTo explore for-loops further, we’ll look at some variations of the basic for-loop:\n1. First, we could have named our for-loop variable\nfor count in range(6):\n    print(count)\n\n\n\n\n\n\nNote\n\n\n\nIt’s customary to use short variable names like i and j\n\n\n2. To go through a loop five times, any range of numbers will do:\nfor i in range(10, 16):\n    print(i)\n\n\n\n\n\n\nNote\n\n\n\n\nHere, the range feature has both a starting value (10) and just-after-ending value (16) specified.\nThis will print the numbers 10 through 15.\n\n\n\n3. We don’t have to increment the for-loop variable by 1.\nfor i in range(10, 16, 2):\n    print(i)\n\nThis prints the numbers 10, 12, 14.\nThe number 2 in range(10, 16, 2) specifies an increment amount.\nThus, we start with i taking the value 10 in the first iteration.\nIn the second iteration, i becomes 12 (because 10+2 = 12).\nIn the third iteration, i becomes 14 (incrementing 12 by 2).\nIf we were to increment 14 by 2 it becomes 16 which is past the last value allowed.\nImportant: think of 16 as “the variable cannot have this value or anything past this value”.\n\n4. We can decrement, as in:\nfor i in range(16, 10, -1):\n    print(i)\n\nThis will print 16, 15, 14, 13, 12, 11.\nWe start with 16 (the first part of the range).\nAfter each iteration we apply the increment/decrement amount.\nIn this case, applying -1 to 16 gives us 15, which gets printed.\nThen, the third time through, i becomes 14. And so on.\nIn the last iteration, i becomes 11.\nFinally, when i is decremented to 10, the loop is ended.\n\n\n\n\n\n\n\n0.3.6 Exercise\n\n\n\nType up the above four examples in my_forloop_variation1.py, my_forloop_variation2.py, my_forloop_variation3.py, and my_forloop_variation4.py. Run to confirm the output.\n\n\n\n\n\n\n\n\n0.3.7 Exercise\n\n\n\nIn count_odd_up.py, write a loop to print the odd numbers from 1 to 25 (thus, skipping by 2, and including 1 and 25 in the output).\n\n\n\n\n\n\n\n\n0.3.8 Exercise\n\n\n\nIn count_even_down.py, write a loop to print the even numbers from 24 down to 2 (inclusive of 24 and 2).\n\n\n\n0.3.9 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#nested-for-loops",
    "href": "units/unit0/modules/module0.3.html#nested-for-loops",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.2 Nested for-loops",
    "text": "0.3.2 Nested for-loops\nWe’ll start by writing a program to print a little number triangle like this:\n1\n22\n333\n4444\nNotice: there’s repetition across a row of numbers: a potential use of for-loops!\nWe’ll do this in stages, starting with this program:\nprint(1)               # print 1 all by itself\n\nfor i in range(2):     # i will start at 0, go up to 1\n    print(2, end='')\nprint()                # Print nothing but go to the next line.\n\nfor i in range(3):     # i ranges from 0 to 2\n    print(3, end='')\nprint()\n\nfor i in range(4):     # i ranges from 0 to 3\n    print(4, end='')\nprint()\nObserve:\n\nWe’ve used end='' (two single quotes in succession) to avoid printing each number on a single line.\nOne could use two double quotes in succession as well.\nprint() merely goes to the next line. (Or, stated differently, ends the current line being printed.)\n\n\n\n\n\n\n\n0.3.10 Exercise\n\n\n\nAdd a row for 5 (with five of them), writing your code in my_forloop_print.py.\n\n\n\n\n\n\n\n\n0.3.11 Exercise\n\n\n\nJust for the heck of it, could one use a for-loop to achieve the printing of 1 all by itself? That is, can a for-loop be set up so that you go into it exactly once? Write you code in my_foorloop_print2.py\n\n\nNext, observe that the upper-limits of the for-loops are themselves increasing: \nAlso, observe that the very thing we’re printing across a row is the loop limit itself: \nAnother way to say this: \n\nWhen the value is 2, print a row of two 2’s When the value is 3, print a row of three 3’s When the value is 4, print a row of four 4’s\n\n\nThus, we could try to do is:\nfor j in range(2, 5):   # let j iterate from 2 to 4\n    # print j occurences of j using a loop\nBut we already know how to print a row of j’s:\nfor j in range(2, 5):   # let j iterate from 2 to 4\n    # print a row of j's (j of them)\n    for i in range (j):\n        print(j, end='')\nLet’s put this together in a complete program:\nprint(1)                   # print 1 all by itself\n\nfor j in range(2, 5):      # j iterates from 2 to 4\n    for i in range(j):     # for each j, print j of them\n        print(j, end='')\n    print()    \n\n0.3.12 Video\n\n\n\n\n\n\n\n0.3.13 Exercise\n\n\n\nChange the program to print a fifth row with five 5’s. Also adjust the for-loop so that the for-loop also takes care of printing the sole 1 that appears in the row of the sole 1’s. That is, adjust the for-loop conditions so that you don’t need the stand-alone print(1) to print 1. Write your code in my_forloop_print3.py.\n\n\nLet’s review what we learned above:\n\nThe outer loop variable’s value is used in the inner loop: \nConsider a single iteration of the outer-loop (e.g., when j is 3). \n\nFor this value of j, the inner loop executes j times.\nThus, when j is 3, the inner loop has 3 iterations.\n\nThis is an example of a nested for-loop in which the inner loop’s execution depends on the value of the outer-loop variable.\nAnother way to say it: a nested for-loop has one for-loop inside another.\nWe will use nesting in other contexts as well, when one structure is placed inside another."
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#tracing-through-a-program-in-detail",
    "href": "units/unit0/modules/module0.3.html#tracing-through-a-program-in-detail",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.3 Tracing through a program in detail",
    "text": "0.3.3 Tracing through a program in detail\nWe’ll now look at an example of how to execute a program “by hand”. That is, how to trace a program’s execution by painstakingly following its execution step-by-step.\nAt first this will appear tedious, but it is critical to a firm understanding of how programs execute, and eventually to your own writing of programs.\nWe’ll first do a longer, more narrative version here, and then show you how to submit a much shorter version for your exercises.\nFor our example, let’s look at the program we last saw:\nprint(1)                   \n\nfor j in range(2, 5):      \n    for i in range(j):     \n        print(j, end='')\n    print()    \nLet’s now dive into the longer version, just for the sake of understanding.\nTo make best use of this:\n\nOpen this same page in another browser, and have the program side-by-side, as you read what’s below.\nRead out aloud what you see below.\n\nReady? Let’s trace through: \n\nRight at the start, the first line is print(1). This prints out 1, and moves to the next line. \nInitially j=2 at the start of the outer for-loop: \nSince j is 2, it’s within the range, and we enter the outer for-loop.\n\nNow we encounter the inner for-loop, where i is set to 0\n\n\n\n\n\n\nNote\n\n\n\nwhen range has only one number specified, it’s understood to be the upper limit.\n\n\nThe upper limit is the current value of j, which is 2. \nInside the inner loop, we execute print(1), which, because j is now 2, will print 2. \nWe’re at the end of the inner loop, so now i increments to 1: \nSo now inside the inner-loop, we print 2 again \nThen, at the end of the inner for-loop, we return to the top where i increments to 2.\nSince i is at the limit, we exit the inner for-loop. \n\n\n\n\n\n\nNote\n\n\n\nThe inner loop iterated twice.\n\n\n\nNext, we go past the inner loop to print(), which goes to the beginning of the next line. \nThis completes the first iteration of the outer, after which we go to the top of the outerloop and increment j. \nExecution now enters the outerloop with j set to 3.\n\nNow we encounter the inner for-loop, where i is set to 0\nThe upper limit is the current value of j, which is 3.\nSo, the inner loop executes three times, with i first set to 0, then to 1, then to 2.\nThis will result in printing three 3’s.\nWhen i becomes 3, it hits the inner-loop limit and proceeds to the print() that follows.\nThe output so far is:\n\n\n1\n2 2\n3 3 3\n\nThis completes the iterations of the inner loop with the outer loop j set to 3.\nNext, j becomes 4 \n\nThe inner loop starts with i set to 0.\nEach time through i increments.\nUntil i hits the limit j (which is 4 now).\nThis results in four 4’s being printed in a line.\nThen we come out of the inner loop and execute print(), which goes to the next line.\n\nThe output so far is\n1\n2 2\n3 3 3\n4 4 4 4\nFinally at the end of the outer loop, j becomes 5 and hits the limit of the outer loop \n\nYes, that was long. But doing this many times will help you understand how to read programs. Later, you will become good at this and will, with a quick glance at the inner-loop, say “Oh, this prints 2 twice in the first iteration of the outer.”\nImportant: when you need to submit a program’s traced-out execution, use a shorter version. For example, see this PDF for the above program.\n\n\n\n\n\n\n0.3.14 Exercise\n\n\n\nConsider this program:\nfor i in range(1, 6):\n    for j in range(i, 0, -1):\n        print('*', end='')\n    print(' ', end='')\n    for j in range(1, i):\n        print('-', end='')\n    print()\nFirst, trace through the values of i and j by hand and try to figure out what gets printed. Do this painstakingly for each possible value of i and j, remembering that i is now the name of the outerloop variable. You can use the shorter “table” format. See this PDF for the above program Then edit, compile and execute the above program in my_forloop_trace.py. Discuss the program with your TA if you are encountering any errors or for any questions.\n\n\n\n0.3.15 Video\n\n\n\n\n\n\n\n0.3.16 Exercise\n\n\n\nConsider this program: Write a program to print out consecutive integers in a diagonal, as in\n1\n 2\n  3\n   4\n    5\nUse a nested for-loop as in earlier examples to print the requisite number of spaces before printing a digit. Write your code in my_diagonal_print.py.\n\n\n\n\n\n\n\n\n0.3.17 Exercise\n\n\n\nConsider this program: Write a program to print out\nI'm feeling cold: b rrrrrr rrrrr rrrr rrr rr r\nUse a regular print to print everything up to the b. Then, use a nested for-loop for the r’s. Don’t forget the space between each grouping of r’s. Write your code in my_brr_print.py.\n\n\n\n\n0.3.18 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#reading-and-writing",
    "href": "units/unit0/modules/module0.3.html#reading-and-writing",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.4 Reading and writing",
    "text": "0.3.4 Reading and writing\nLet’s consider how to read a single for-loop, such as:\nfor k in range(1, 10, 2):\n    print(k, end=' ')\n    print(2*k)\n    print('-')\n\n\n\n\n\n\n0.3.19 Exercise\n\n\n\nWrite up the above in my_simpleloop.py and run to see the output.\n\n\nInstead of explaining the execution, let’s focus on how to read such a program:\n\nThe first thing to do is to observe two parts to the loop: \nNext, study the for-statement to understand the nature of the iteration: \nNow look inside the body: \n\nLet’s also point out what to keep in mind when writing:\n\nFirst, the for-loop header or for-statement: \nNext, the loop body: \nImportant: we will be nitpicky about writing because good writing habits will save you a lot of trouble.\n\nNext, let’s combine reading with mental execution. Consider the following program:\ndef functionOne():\n    print('*', end='')\n\ndef functionTwo():\n    print('*')\n\ndef functionThree():\n    for j in range(0, 5):\n        functionOne()\n    functionTwo()\n\nfor i in range(1, 11, 2):\n    functionThree()\n\n\n\n\n\n\n0.3.20 Exercise\n\n\n\nWhat does it print? Try to figure this out by mental execution first. Then, type it up, compile and execute to confirm, writing your code in my_execution_exercise.py.\n\n\n\n0.3.21 Video"
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#when-things-go-wrong",
    "href": "units/unit0/modules/module0.3.html#when-things-go-wrong",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.5 When things go wrong",
    "text": "0.3.5 When things go wrong\nAs code gets more complex, it gets easier to make mistakes, and harder to find them.\nIn each of the programs below, try to determine the error without compiling the program. Then, write up the program, compile and see what the compiler says. After that, fix the error.\n\n\n\n\n\n\n0.3.22 Exercise\n\n\n\nfor i in range(0 6):\n    print(i)\nWrite your corrected code in my_loop_exercise1.py.\n\n\n\n\n\n\n\n\n0.3.23 Exercise\n\n\n\nfor i in range(0, 6)\n    print(i)\nWrite your corrected code in my_loop_exercise2.py.\n\n\n\n\n\n\n\n\n0.3.24 Exercise\n\n\n\nfor i in range(0, 6:\n    print(i)\nWrite your corrected code in my_loop_exercise3.py.\n\n\n\n\n\n\n\n\n0.3.25 Exercise\n\n\n\nfor i in range(0, 6):\nprint(i)\nWrite your corrected code in my_loop_exercise4.py.\n\n\n\n\n\n\n\n\n0.3.26 Exercise\n\n\n\nfor in range(0, 6):\n    print(i)\nWrite your corrected code in my_loop_exercise5.py.\n\n\n\n\n\n\n\n\n0.3.27 Exercise\n\n\n\nfor i in range(0, 6):\n    print i\nWrite your corrected code in my_loop_exercise6.py.\n\n\nLet’s point out the difference between a syntax error and a logical error:\n\nA syntax error will not allow a program to run.\nThis means you are using the language incorrectly.\nOn the other hand, you could have a program that has no syntax errors (it runs) but it does not produce the desired output. This means there’s a logical error.\nThe process of identifying and fixing logical errors is called debugging.\nA bug is a logical error.\n\n\n\n\n\n\n\n0.3.28 Exercise\n\n\n\nThe following code intends to print\n55555\n4444\n333\n22\n1\nfor i in range(5, 0, 1):\n    for j in range(1, i):\n        print(i, end='')\n    print()\nBut there are two bugs. First, try to find the problems solely by reading and mental execution. Then, type up the program in my_loop_exercise7.py. Fix the program to get the desired output."
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#a-peek-at-the-future",
    "href": "units/unit0/modules/module0.3.html#a-peek-at-the-future",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.6    A peek at the future",
    "text": "0.3.6    A peek at the future\nConsider the following program:\nimport tkinter as tk\n\nwindow = tk.Tk()\ncanvas = tk.Canvas(master=window, width=200, height=100)\ncanvas.pack()\n\ndef draw_rectangles():\n    for i in range(10, 51, 10):              \n        canvas.create_rectangle(\n            3*i, i, 3*i+20, i+10, outline=\"blue\")\n\ndraw_rectangles()\nwindow.mainloop()\n\n\n\n\n\n\n0.3.29 Exercise\n\n\n\nDownload the above program, my_forloop_rectangle.py, and execute the program. If you’re feeling brave, add a second for-loop so that output looks like: \n\n\nLet’s point out the for-loop’s part in the program:\n\nFirst, we need to understand how coordinates work differently in Python: \nNext, let’s read the for-loop statement to see how it iterates: \n\nWe can see that i will be 10 the first time through the loop.\nThen i becomes 20, then 30 etc until 50.\nThus, there are 5 iterations through the loop.\n\nNotice how i is used in the calculation of the measurements needed to draw the rectangle:  (We spilled a line of code over two lines to make the font large enough.)\n\nWhen i is 10, the first rectangle’s top left corner gets drawn at 30 (which is 3 times i, or 3*i) from the left side, and 10 down from the top.\nIn the second iteration i is 20, which means the top left corner is 60 from the left. And so on.\n\n\n\n\n\n\n\n\n0.3.30 Exercise\n\n\n\nDownload my_forloop_rectangle2.py, and execute the program to see that an animation is really a for-loop.\n\n\nAbout animations:\n\nEven if an object moves across a screen (and is in different positions on the screen), there is something that “repeats”.\nWhat repeats is the drawing of the object in different places (with a gap in time to create the illusion of real movement).\nThus, when locations can be calculated we can use a loop to iterate through the different positions.\nThis is essentially how animation works."
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#some-things-to-keep-mind",
    "href": "units/unit0/modules/module0.3.html#some-things-to-keep-mind",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.7    Some things to keep mind",
    "text": "0.3.7    Some things to keep mind\nLet’s introduce the notion of reserved words:\n\nSome words like for and in are special to the language and are called reserved words or key words of the language. \nThere are special rules associated with the usage of such reserved words, which we’ll describe over time. For now, we’re just pointing them out.\nAnother example of a reserved word we’ve seen: def\nIt turns out that, even though print looks like it should be a reserved word, it’s in fact not.\n\nAt this stage, the distinction is not clear and that’s fine.\nAs you learn the language, you’ll learn how to distinguish.\n\n\nCounting from 0:\n\nWhen a single number like 6 is specified in the range as in range(6) \nThus, i is 0 the first time, then 1, then 2, and so on until i = 5 (last time through).\nThe number 6 specifies that i cannot be 6 or higher.\nThus, there is a certain strangeness to get used to:\n\nUnlike math (where counting starts from 1), in programming, the convention is to start from 0.  (Did you notice that’s why we started with Module 0?)\nThe other strangeness is specifying the limit as one higher (6) than than last iteration value (5).\n\n\nThe different uses of range\n\nWhen a single number is specified, as in range(6) the implied start is 0.\nWhen two numbers are specified as in: range(10, 16) the first is the start of the count, and the second is the limit: \n\nThus i is 10 the first time (this is the first thing that’s printed).\nThen i becomes 11.\nThen 12, and so on until the last time through when i is 15.\n\nWhen three numbers are specified as in range(10, 16, 2) the third number is the increment. \n\nHere, i starts as 10 in the first iteration.\nThen, i is 12 in the second iteration.\nThen i becomes 14. This is the last iteration because after that i would be 16, which ends the loop.\n\nUsing range(10, 15, 2) produces the same result as above, and in fact preferable.\n\nAbout comments:\n\nFirst, comments are for us to read. The computer does not read them.\nThus, in terms of execution, this program\n\n# list the even numbers between 10 and 14, inclusive:\nfor i in range(10, 15, 2):    # Notice the increment\n    print(i)\nwill result in the exact output as this one:\nfor i in range(10, 15, 2):\n    print(i)\n\nWe will use comments in two ways, as in the above example:\n\nThe first comment is an example of using a comment as a prelude to code, to explain what’s coming or intended.\nThe second kind that is to the right side of a line of code is like an alert: we’ll use this to point out something to pay attention to in that line of code."
  },
  {
    "objectID": "units/unit0/modules/module0.3.html#meta",
    "href": "units/unit0/modules/module0.3.html#meta",
    "title": "Module 0.3: Loops: the for-loop",
    "section": "0.3.8 Meta",
    "text": "0.3.8 Meta\nWe will occasionally step back from the details to comment on how best to learn.\nThis module was a bit different, a little more challenging than modules 1-2.\nWhat to keep in mind:\n\nIt is only natural to feel like you are in an alien landscape.        ⇒ You would feel no different doing the first few modules while learning a foreign language with an entirely different script.\nIt takes a while to absorb some of the details, and that’s just fine.\nNotice that some exercises were significantly more challenging than others:\n\nIn prior modules, you merely typed in something and tried it out, or make a small change.\nWith some exercises (like brrrrr) you had to do it all from scratch.\nBoth involved problem-solving        ⇒ Taking a problem described in words and finding a solution.\n\nProblem-solving is a higher-level skill than programming.\n\nIt takes time to acquire this skill.\nThere is no magic formula or words to simply make “problem solving” work for you.\nThe only way is to develop this skill is to struggle with problems, and with lots of them.\n\nFinally, think about this:\n\nAnyone can acquire both programming and problem-solving skills with sufficient dedication. So why not you?\nIf you get past these hurdles with determination, you will leave in the dust all those who gave up earlier.\n\n\n Previous Module: Module 0.2 Next Module: Module 0.4"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Email: Dr. Kartik Bulusu"
  },
  {
    "objectID": "about.html#instructor",
    "href": "about.html#instructor",
    "title": "About",
    "section": "",
    "text": "Email: Dr. Kartik Bulusu"
  },
  {
    "objectID": "about.html#course-learning-outcomes",
    "href": "about.html#course-learning-outcomes",
    "title": "About",
    "section": "Course Learning Outcomes",
    "text": "Course Learning Outcomes\n\nDemonstrate familiarity with key concepts in a procedural programming language such as: variables, control structures, functions, input and output.\nDemonstrate the ability to use programming to solve problems appropriate to a beginning class in programming.\nAcquire familiarity with how programming can be applied to solve problems."
  },
  {
    "objectID": "about.html#timelocation-of-course",
    "href": "about.html#timelocation-of-course",
    "title": "About",
    "section": "Time/Location of course",
    "text": "Time/Location of course"
  },
  {
    "objectID": "about.html#office-hours",
    "href": "about.html#office-hours",
    "title": "About",
    "section": "Office Hours",
    "text": "Office Hours\nFor information regarding the office hours, please refer the Instruction Team page."
  },
  {
    "objectID": "about.html#why-are-there-no-recorded-video-lectures",
    "href": "about.html#why-are-there-no-recorded-video-lectures",
    "title": "About",
    "section": "Why are there no recorded video lectures?",
    "text": "Why are there no recorded video lectures?\nLearning to program by watching some talk about it is less effective than learning by “doing programming”. Thus, most of your learning will consist of reading a concept, seeing an example, and immediately following that with a programming exercise that really gets into the details. At the same time, we know it’s useful to have hints and explanations to help you in your exercises, when you are particularly stuck. Accordingly, although most of the material is written, and includes elaborate instructions, there is recorded media that you can optionally view/listen if you need it. These are recorded from a student point of view (but carefully vetted by us), as you’ll see."
  },
  {
    "objectID": "about.html#teaching-assistants-tas",
    "href": "about.html#teaching-assistants-tas",
    "title": "About",
    "section": "Teaching Assistants (TAs)",
    "text": "Teaching Assistants (TAs)\nFor information about TAs, their office hours and how to reach out to them, please refer the Instruction Team page."
  },
  {
    "objectID": "about.html#prerequisites",
    "href": "about.html#prerequisites",
    "title": "About",
    "section": "Prerequisites",
    "text": "Prerequisites\nNone"
  },
  {
    "objectID": "about.html#official-catalog-description",
    "href": "about.html#official-catalog-description",
    "title": "About",
    "section": "Official catalog description",
    "text": "Official catalog description\nIntroduction to programming a computer using the Python language; variables, types, assignment, conditionals, loops, lists, and program units. (Fall, spring, and summer, Every Year)."
  },
  {
    "objectID": "about.html#informal-description",
    "href": "about.html#informal-description",
    "title": "About",
    "section": "Informal description",
    "text": "Informal description\nThis course is all about getting started with programming in the language called Python."
  },
  {
    "objectID": "about.html#textbook",
    "href": "about.html#textbook",
    "title": "About",
    "section": "Textbook",
    "text": "Textbook\nAll of the material is online (and free)"
  },
  {
    "objectID": "about.html#other-requirements",
    "href": "about.html#other-requirements",
    "title": "About",
    "section": "Other requirements",
    "text": "Other requirements\n\nYou will be expected to have and use your Blackboard account. If you have trouble logging in, you will need to resolve this by the first meeting."
  },
  {
    "objectID": "about.html#staying-on-top-of-the-course",
    "href": "about.html#staying-on-top-of-the-course",
    "title": "About",
    "section": "Staying on top of the course",
    "text": "Staying on top of the course\n\nVisit the course website (this one) and the Blackboard part of this course several times each week.\nBe responsive to email sent to you."
  },
  {
    "objectID": "about.html#course-load",
    "href": "about.html#course-load",
    "title": "About",
    "section": "Course load",
    "text": "Course load\nThis is not a light course. The course has three units, each of which has a number of modules. Based on students who’ve taken the course previously, we’ve identified the approximate number of hours needed for each module.\n\n\n\n\n\n\nWarning\n\n\n\nThe hours needed vary by module, so please plan accordingly. The first unit starts off gently, after which the pace increases. Unit-1 is the hardest."
  },
  {
    "objectID": "about.html#late-work-policy",
    "href": "about.html#late-work-policy",
    "title": "About",
    "section": "Late work policy",
    "text": "Late work policy\nLate work is not accepted, with the following exceptions:\n\nEvery student many turn in as many as four assignments (modules or problem sets) up to 48 hours after the deadline with no penalty. Requesting an extension is not necessary in these cases.\nExtensions will be granted should there arise circumstances beyond your control that impede your ability to complete coursework and turn in a deliverable on time. Notify your professor as soon as feasible in these cases. Examples of such circumstances include (but are not limited to) illness, death in the family, and loss of housing. To ensure fairness toward all students, I will request documentation of such circumstances."
  },
  {
    "objectID": "about.html#accomodations",
    "href": "about.html#accomodations",
    "title": "About",
    "section": "Accomodations",
    "text": "Accomodations\nWe are committed to accommodating student needs in whatever ways are possible and fair. This includes, but is certainly not limited to, Disability Support Services (DSS). Let your professor know of circumstances that may impact your academic commitments if and when such circumstances arise, or before the semester begins, as is appropriate. To ensure fairness toward all students, we will request documentation of such circumstances, either directly or via DSS."
  },
  {
    "objectID": "about.html#minimum-course-load",
    "href": "about.html#minimum-course-load",
    "title": "About",
    "section": "Minimum course load",
    "text": "Minimum course load\nIn a 15-week semester, including exam week, students are expected to spend a minimum of 100 minutes of out-of-class work for every 50 minutes of direct instruction, for a minimum total of 2.5 hours a week. A 3-credit course includes 2.5 hours of direct instruction and a minimum of 5 hours of independent learning, or a minimum of 7.5 hours per week. More information about GW’s credit hour policy can be found at: provost.gwu.edu/policies-forms"
  },
  {
    "objectID": "about.html#statement-on-inclusive-teaching",
    "href": "about.html#statement-on-inclusive-teaching",
    "title": "About",
    "section": "Statement on inclusive teaching",
    "text": "Statement on inclusive teaching\nIt is my intent that students from all backgrounds and perspectives be well-served by this course, and that the diversity that the students bring to this class be viewed as a resource, strength and benefit. Your suggestions are encouraged and appreciated. Please let me know ways to improve the effectiveness of the course for you personally, or for other students or student groups.\n\n\n\n\n\n\nNote\n\n\n\nThat course policies may be adjusted or modified during the course of the semester."
  },
  {
    "objectID": "submit-remember.html",
    "href": "submit-remember.html",
    "title": "What to remember about submitting work",
    "section": "",
    "text": "The submission requirements are stringent. You MUST name folders and files exactly as described.\nYour programs must do what’s asked, no less no more. If you print more than what’s required the autograder will not grade your program.\n\nIf you’ve forgotten how to make folders, zip files etc, now may be a good time to review your computerese skills"
  },
  {
    "objectID": "submit-remember.html#most-important",
    "href": "submit-remember.html#most-important",
    "title": "What to remember about submitting work",
    "section": "",
    "text": "The submission requirements are stringent. You MUST name folders and files exactly as described.\nYour programs must do what’s asked, no less no more. If you print more than what’s required the autograder will not grade your program.\n\nIf you’ve forgotten how to make folders, zip files etc, now may be a good time to review your computerese skills"
  },
  {
    "objectID": "submit-remember.html#correct-folder-structure-on-your-laptop",
    "href": "submit-remember.html#correct-folder-structure-on-your-laptop",
    "title": "What to remember about submitting work",
    "section": "Correct folder structure on your laptop",
    "text": "Correct folder structure on your laptop\nFor the overall class you should have a folder named cs1012 on your computer:\n\nYou can create one such folder on your Desktop, but you could also place this inside some other folder.\n\n\n\n\n\n\n\nWarning\n\n\n\nIt’s all lowercase, with no spaces.\n\n\nIn the cs1012 folder, create a folder for each unit. Eventually, you will create a folder for each unit and each module in a given unit.\nYou must name your folders with the following rules:\n\nThere will be 3 units, so you will ultimately have folders called unit0, unit1 and unit2 inside your cs1012 folder.\nName the unit folders carefully:\n\nFor your Unit 0 work, name that unit’s folder unit0.\nFor your Unit 1 work, name that unit’s folder unit1.\nFor your Unit 2 work, name that unit’s folder unit2.\n\nEach unit has several modules. For each module folder inside the each unit folder, you must name the module folder according to these rules:\n\nFor your Module 0.0 work, name that module’s folder module0.0.\nFor your Module 1.0 work, name that module’s folder module1.0.\nAnd so on.\n\nEach unit has will also have assignments. For each assignment inside each unit, make a folder. You must name the assignment folders according to these rules:\n\nFor your Assignment 1 work, name that folder assignment1.\nFor your Assignment 2 work, name that folder assignment2.\nAnd so on if there are more assignments.\n\nThus, one looks inside your 1012 folder, we’d expect to see three sub-folders called unit0, unit1, and unit2.\nAnd, if one further looks inside the unit0 folder, we’d expect to see 9 sub-folders:\n\n7 of these will be called module0.0, module0.1, module0.2, module0.3, module0.4, module0.5 and module0.6\n2 of these will be called assignment1 and assignment2."
  },
  {
    "objectID": "submit-remember.html#correct-location-and-naming-of-files-within-folders",
    "href": "submit-remember.html#correct-location-and-naming-of-files-within-folders",
    "title": "What to remember about submitting work",
    "section": "Correct location and naming of files within folders",
    "text": "Correct location and naming of files within folders\nEvery module and every assignment will feature multiple files:\n\nMost files will be Python programs. The names of these will end in .py.\nFor example: myname.py.\nAnother example from Module 0 in Unit 0: In Exercise 0.4, you are instructed to create the files error1.py and error2.py. These need to be saved in your module0.0 folder when using your code editor (Thonny or Spyder)."
  },
  {
    "objectID": "submit-remember.html#making-a-zip-to-submit",
    "href": "submit-remember.html#making-a-zip-to-submit",
    "title": "What to remember about submitting work",
    "section": "Making a zip to submit",
    "text": "Making a zip to submit\nWhen you zip your files when preparing to submit them, you must zip only the files for the current module and you must name the zip file for the corresponding folder.\n\nThe easy way to do this is to zip the folder containing the files.\n\nWhen it’s time to submit, you will upload this zip file (example: module0.1.zip) into the appropriate place in Blackboard.\nBe careful to avoid spaces where they shouldn’t be spaces, and to use lowercase when asked. For example:\n\nmodule0.0.zip (correct)\nModule0.0.zip (wrong: starts with uppercase)\nmodule 0.0.zip (wrong: space before 0)\nmodule0.0.docx (wrong: not a zip)."
  }
]